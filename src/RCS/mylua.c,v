head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2002.02.16.14.15.25;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.22.13.03.59;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.15.10.13.01;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.14.02.20.31;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to Lua 4.1-work4.
@
text
@/* mylua.c
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <time.h>
#include <allegro.h>
#include "lua.h"
#include "lualib.h"
#include "mylua.h"
#include "path.h"


lua_State *lua_state;


int mylua_open (void)
{
    if (!(lua_state = lua_open ()))
	return -1;

    lua_baselibopen (lua_state);
    lua_mathlibopen (lua_state); /* XXX: needed? */
    lua_strlibopen (lua_state);

    /* seed RNG */
    lua_getglobal (lua_state, "randomseed");
    lua_pushnumber (lua_state, time (0));
    lua_call (lua_state, 1, 0);

    return 0;
}


void mylua_close (void)
{
    lua_close (lua_state);
}


int lua_dofile_path (lua_State *L, const char *filename)
{
    char **p, tmp[1024];

    for (p = path_share; *p; p++) {
	ustrzcpy (tmp, sizeof tmp, *p);
	ustrzcat (tmp, sizeof tmp, filename);
	if (lua_dofile (L, tmp) == 0)
	    return 0;
    }

    return -1;
}


/*
 * Function to validate arguments to an exported C function.
 * 
 * ARGTYPES contains the types of each of the arguments on top of the
 * stack to be validated against.  Each character can be one of:
 *
 *	u - the next argument should be userdata
 *  	N - nil
 *  	n - number
 * 	s - string
 *  	t - table
 *  	f - function
 *      - - none
 *  	* - anything
 *
 * In addition, [ and ] surrounding multiple characters can be used to
 * specify multiple valid types for the one argument.
 */

static inline int valid (lua_State *L, char argtype, int index)
{
    int type;

    switch (argtype) {
	case 'u': type = LUA_TUSERDATA; break;
	case 'N': type = LUA_TNIL; break;
	case 'n': type = LUA_TNUMBER; break;
	case 's': type = LUA_TSTRING; break;
	case 't': type = LUA_TTABLE; break;
	case 'f': type = LUA_TFUNCTION; break;
	case '-': type = LUA_TNONE; break;
	default: return 1;
    }

    return (lua_type (L, index) == type);
}

int lua_checkargs (lua_State *L, const char *argtypes)
{
    const char *a;
    int index;

    for (a = argtypes, index = 1; *a; a++, index++)
	if (*a == '[') {
	    a++;
	    while (*a != ']') {
		if (valid (L, *a, index)) break;
		a++;
	    }
	    if (*a == ']') return 0;
	    while (*a != ']') a++;
	}
	else if (!valid (L, *a, index)) 
	    return 0;

    return 1;
}
@


1.5
log
@Changed all "()" declarations to "(void)".
@
text
@d18 1
a18 1
int mylua_open (int stacksize)
d20 1
a20 1
    if (!(lua_state = lua_open (stacksize)))
@


1.4
log
@Seed lua random() function.
@
text
@d36 1
a36 1
void mylua_close ()
@


1.3
log
@Updated to Lua 4.1-work3.
@
text
@d7 1
d22 1
d26 6
@


1.2
log
@Open the strlib for use from Lua
@
text
@d8 2
a9 2
#include <lua.h>
#include <lualib.h>
@


1.1
log
@Initial revision
@
text
@d23 1
@

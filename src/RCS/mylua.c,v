head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2002.07.16.00.02.15;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.12.17.27.22;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.12.04.09.18;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.11.12.23.48;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.14.15.25;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.22.13.03.59;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.15.10.13.01;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.14.02.20.31;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Expose TICKS_PER_SECOND and MSECS_PER_TICK to the Lua state.
@
text
@/* mylua.c
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <time.h>
#include <allegro.h>
#include "lua.h"
#include "lualib.h"
#include "mylua.h"
#include "path.h"
#include "ticks.h"


/*
 * Import bindings.
 */

#include "client.h"
#include "explo.h"
#include "extdata.h"
#include "loaddata.h"
#include "svgame.h"
#include "store.h"
#include "object.h"
#include "objtypes.h"


#include "bindings.inc"



/*
 * The actual module stuff.
 */


/* We use one Lua state.  But we don't want clients using functions
 * which only make sense in a server context, and vice versa, i.e. we
 * want namespaces.  To do this, we create an initial state with some
 * globals needed for initialisation registered (e.g. data loading
 * functions).  Afterwards we split the state into two "threads" with
 * different globals tables, then register some more functions.  */

lua_State *the_lua_state;
lua_State *server_lua_namespace;
lua_State *client_lua_namespace;


int mylua_open (void)
{
    the_lua_state = lua_open ();
    if (!the_lua_state)
	return -1;
    server_lua_namespace = NULL;
    client_lua_namespace = NULL;

    lua_baselibopen (the_lua_state);
    lua_mathlibopen (the_lua_state); /* XXX: needed? */
    lua_strlibopen (the_lua_state);

    /* seed RNG */
    lua_getglobal (the_lua_state, "randomseed");
    lua_pushnumber (the_lua_state, time (0));
    lua_call (the_lua_state, 1, 0);

    /* register bindings */
    DO_REGISTRATION_INIT (the_lua_state);

    lua_pushnumber (the_lua_state, TICKS_PER_SECOND);
    lua_setglobal (the_lua_state, "ticks_per_second");
    lua_pushnumber (the_lua_state, MSECS_PER_TICK);
    lua_setglobal (the_lua_state, "msecs_per_tick");

    /* for debugging */
    lua_pushstring (the_lua_state, "initial");
    lua_setglobal (the_lua_state, "_internal_namespace");

    return 0;
}


static lua_State *fork_namespace (lua_State *orig_state)
{
    lua_State *new_state;
    lua_ref_t table;

    new_state = lua_newthread (orig_state);

    /* Make a copy of orig_state's globals table on top of the
     * orig_state stack.  */
    lua_dostring (orig_state, "
	do
	  local t = {}
	  for i,v in globals () do
	    t[i] = v
	  end
	  return t
	end
    ");

    /* Make the new table new_state's global table.  */
    table = lua_ref (orig_state, 1);
    lua_getref (new_state, table);
    lua_setglobals (new_state);
    lua_unref (orig_state, table);

    return new_state;
}


void mylua_open_server_and_client_namespaces (void)
{
    /* Unregister functions from the initial namespace, which are only
     * needed during initialisation.  This won't stop people copying
     * the bindings into other variables.  */
    DO_UNREGISTRATION_INIT (the_lua_state);

    server_lua_namespace = fork_namespace (the_lua_state);
    DO_REGISTRATION_BOTH (server_lua_namespace);
    DO_REGISTRATION_SERVER (server_lua_namespace);

    client_lua_namespace = fork_namespace (the_lua_state);
    DO_REGISTRATION_BOTH (client_lua_namespace);
    DO_REGISTRATION_CLIENT (client_lua_namespace);

    /* for debugging */
    lua_pushstring (server_lua_namespace, "server");
    lua_setglobal (server_lua_namespace, "_internal_namespace");

    lua_pushstring (client_lua_namespace, "client");
    lua_setglobal (client_lua_namespace, "_internal_namespace");
}


void mylua_close (void)
{
    if (client_lua_namespace) {
	lua_closethread (the_lua_state, client_lua_namespace);
	client_lua_namespace = NULL;
    }

    if (server_lua_namespace) {
	lua_closethread (the_lua_state, server_lua_namespace);
	server_lua_namespace = NULL;
    }

    lua_close (the_lua_state);
    the_lua_state = NULL;
}


int lua_dofile_path (lua_State *L, const char *filename)
{
    char **p, tmp[1024];

    for (p = path_share; *p; p++) {
	ustrzcpy (tmp, sizeof tmp, *p);
	ustrzcat (tmp, sizeof tmp, filename);
	if (lua_dofile (L, tmp) == 0)
	    return 0;
    }

    return -1;
}


/*
 * Function to validate arguments to an exported C function.
 * 
 * ARGTYPES contains the types of each of the arguments on top of the
 * stack to be validated against.  Each character can be one of:
 *
 *	u - the next argument should be userdata
 *  	N - nil
 *  	n - number
 * 	s - string
 *  	t - table
 *  	f - function
 *      - - none
 *  	* - anything
 *
 * In addition, [ and ] surrounding multiple characters can be used to
 * specify multiple valid types for the one argument.
 */

static inline int valid (lua_State *L, char argtype, int index)
{
    int type;

    switch (argtype) {
	case 'u': type = LUA_TUSERDATA; break;
	case 'N': type = LUA_TNIL; break;
	case 'n': type = LUA_TNUMBER; break;
	case 'b': type = LUA_TBOOLEAN; break;
	case 's': type = LUA_TSTRING; break;
	case 't': type = LUA_TTABLE; break;
	case 'f': type = LUA_TFUNCTION; break;
	case '-': type = LUA_TNONE; break;
	default: return 1;
    }

    return (lua_type (L, index) == type);
}

int lua_checkargs (lua_State *L, const char *argtypes)
{
    const char *a;
    int index;

    for (a = argtypes, index = 1; *a; a++, index++)
	if (*a == '[') {
	    a++;
	    while (*a != ']') {
		if (valid (L, *a, index)) break;
		a++;
	    }
	    if (*a == ']') return 0;
	    while (*a != ']') a++;
	}
	else if (!valid (L, *a, index)) 
	    return 0;

    return 1;
}
@


1.9
log
@Made lua_checkargs() understand a boolean type.
@
text
@d13 1
d70 5
@


1.8
log
@Separated bindings that were part of the "init" list into two lists
(one for functions used at init-time, and another for functions which
are available to both server and client at game-time).  Functions used
only at init-time are now removed before the state is split into the
namespaces.
@
text
@d190 1
@


1.7
log
@Separated the one Lua state into two namespaces: server and client, so
that scripts run on the server don't have access to client-only
functions, and vice versa.  This makes things much less murky.
@
text
@d67 6
a72 1
    DO_REGISTRATION_BOTH (the_lua_state);
d109 5
d115 1
d119 1
a122 3
    lua_pushstring (the_lua_state, "initial");
    lua_setglobal (the_lua_state, "_internal_namespace");

@


1.6
log
@Updated to Lua 4.1-work4.
@
text
@d15 33
a47 1
lua_State *lua_state;
d52 2
a53 1
    if (!(lua_state = lua_open ()))
d55 2
d58 3
a60 3
    lua_baselibopen (lua_state);
    lua_mathlibopen (lua_state); /* XXX: needed? */
    lua_strlibopen (lua_state);
d63 5
a67 3
    lua_getglobal (lua_state, "randomseed");
    lua_pushnumber (lua_state, time (0));
    lua_call (lua_state, 1, 0);
d73 49
d124 12
a135 1
    lua_close (lua_state);
@


1.5
log
@Changed all "()" declarations to "(void)".
@
text
@d18 1
a18 1
int mylua_open (int stacksize)
d20 1
a20 1
    if (!(lua_state = lua_open (stacksize)))
@


1.4
log
@Seed lua random() function.
@
text
@d36 1
a36 1
void mylua_close ()
@


1.3
log
@Updated to Lua 4.1-work3.
@
text
@d7 1
d22 1
d26 6
@


1.2
log
@Open the strlib for use from Lua
@
text
@d8 2
a9 2
#include <lua.h>
#include <lualib.h>
@


1.1
log
@Initial revision
@
text
@d23 1
@

head	1.47;
access;
symbols;
locks; strict;
comment	@# @;


1.47
date	2002.12.18.15.02.17;	author tjaden;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.15.11.13.27;	author tjaden;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.15.11.07.12;	author tjaden;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.15.09.27.35;	author tjaden;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.15.08.47.27;	author tjaden;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.14.04.25.41;	author tjaden;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.14.01.32.31;	author tjaden;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.13.06.21.53;	author tjaden;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.12.17.28.16;	author tjaden;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.12.05.19.42;	author tjaden;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.12.04.55.27;	author tjaden;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.12.04.09.09;	author tjaden;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.11.07.06.48;	author tjaden;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.11.07.03.34;	author tjaden;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.11.05.55.13;	author tjaden;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.11.05.50.37;	author tjaden;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.11.05.23.27;	author tjaden;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.10.10.29.56;	author tjaden;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.03.07.50.46;	author tjaden;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.29.14.57.43;	author tjaden;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.29.00.07.13;	author tjaden;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.28.14.06.20;	author tjaden;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.28.13.01.12;	author tjaden;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.27.14.05.42;	author tjaden;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.26.11.54.44;	author tjaden;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.24.07.19.13;	author tjaden;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.23.15.00.29;	author tjaden;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.14.09.37;	author tjaden;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.23.03.53.24;	author tjaden;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.21.16.08.54;	author tjaden;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.21.04.16.16;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.21.00.21.09;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.19.12.37.35;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.19.08.21.55;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.01.38.10;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.14.31.17;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.14.28.12;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.17.13.31.43;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.15.13.28.36;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.15.10.12.51;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.16.07.52;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.15.00.24;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.08.41.42;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.02.18.48;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.13.15.01.43;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.13.09.28.02;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Updated for Lua 5.0 beta
@
text
@-- bindgen.lua -- generate Lua <-> C bindings

gsub = string.gsub
getn = table.getn
date = os.date


-- Types that we should know about.
--	field 1: checkargs type char
--	field 2: C type
--	field 3: Lua to C conversion function
--	field 4: optional error check; $ is replaced by the variable name

ctypes = {
    -- builtin types
    Float	= { "n", "float", "lua_tonumber" },
    Function 	= { "f", "lua_ref_t", "lua_ref" },
    Int	 	= { "n", "int", "lua_tonumber" },
    Bool	= { "b", "int", "lua_toboolean" },
    String	= { "s", "const char *", "lua_tostring" },
    -- custom and readability types
    Method   	= { "f", "lua_ref_t", "lua_ref" },
    Object	= { "u", "object_t *", "lua_toobject", "!$" },
    ObjId	= { "n", "objid_t", "lua_tonumber" },
    ObjTag	= { "n", "objtag_t", "lua_tonumber" },
    ClientId	= { "n", "int", "lua_tonumber" },
    StoreKey	= { "s", "const char *", "lua_tostring" }
}

-- convenience
Float = "Float"
Function = "Function"
Int = "Int"
Bool = "Bool"
String = "String"
Method = "Method"
Object = "Object"
ObjId = "ObjId"
ObjTag = "ObjTag"
ClientId = "ClientId"
StoreKey = "StoreKey"


-- Code generator.
--	lname: 	 Lua function name; if omitted is the same as cname
--	cname: 	 C function name
--	check:	 argument checking string; if omitted will be generated
--	args: 	 table of arguments of the form:
--		     { type, variable name, optional error check, optional code snippet }
--	      	   If the error check is specified, it is used in preference
--		     to the general error check in the type table.
--		   If the code snippet is specified, it is used in preference
--		     to the default generated conversion code.  In the snippet,
--		     $# is replaced by the argument number, and $ is replaced
--		     by the variable name
--    	ret: 	 return value, in same format as args
--	success: code to execute on success; default is to return 1
--	error:	 code to execute on error; default is to return nil

function generate_code (lname, cname, check, args, ret, success, error)
    lname = lname or cname
    local tab = "\t"
    local str

    function generate_check ()
	local str = ""
	for i,v in args do
	    local typ = ctypes[v[1]]
	    str = str..typ[1]
	end
	return str
    end

    -- function declaration
    str = "static int bind_"..lname.."(lua_State *L)\n{\n"

    -- argument declarations
    for i,v in args do
	local typ = ctypes[v[1]]
	str = str..tab..typ[2].." "..v[2]..";\n"
    end

    if ret then
	local typ = ctypes[ret[1]]
	str = str..tab..typ[2].." "..ret[2]..";\n"
    end

    -- argument checking
    str = str..tab..'if (!lua_checkargs(L, "'..(check or generate_check())..'")) goto badargs;\n'

    -- argument conversion
    for i,v in args do
	local typ = ctypes[v[1]]
	if v[4] then
	    local x = gsub (gsub (v[4], "%$#", i), "%$", v[2])
	    str = str..tab..x.."\n"
	else
	    str = str..tab..v[2].." = "..typ[3].."(L, "..i..");\n"
	end
	if v[3] then 
	    str = str..tab.."if ("..v[3]..") goto badargs;\n"
	elseif typ[4] then
	    str = str..tab.."if ("..gsub(typ[4], "%$", v[2])..") goto badargs;\n"
	end
    end

    -- function call
    str = str..tab
    if ret and ret[4] then
	local x = gsub (ret[4], "%$", ret[2])
	str = str..x.."\n"
    else
	if ret then str = str..ret[2].." = " end
	str = str..cname.."("
	for i,v in args do
	    if i == getn (args) then
		str = str..v[2]..""
	    else
		str = str..v[2]..", "
	    end
	end
	str = str..");\n"
    end

    -- check return
    if ret and ret[3] then
	str = str..tab.."if ("..gsub(ret[3], "%$", ret[2])..") goto error;\n"
    end

    -- success clause
    str = str..tab..(success or "lua_pushboolean(L, 1); return 1;").."\n"

    -- bad args clause
    str = str..
	"badargs:\n"..tab..'printf("bad args to '..lname..'\\n");\n'..
	tab.."goto error; /* shut up the compiler about unused labels */\n"

    -- error clause
    str = str.."error:\n"..tab..(error or "lua_pushboolean(L, 0); return 1;").."\n"

    str = str.."}\n"
    print (str)
end

reg_init = "#define DO_REGISTRATION_INIT(L) "
unreg_init = "#define DO_UNREGISTRATION_INIT(L) "
reg_both = "#define DO_REGISTRATION_BOTH(L) "
reg_server = "#define DO_REGISTRATION_SERVER(L) "
reg_client = "#define DO_REGISTRATION_CLIENT(L) "

function _generate (table, reglist)
    generate_code (table.lname, table.cname, table.check, table.args, 
		   table.ret, table.success, table.error)

    return reglist..
	' \\\n\tlua_register(L, "'..(table.lname or table.cname)..
	'", bind_'..(table.lname or table.cname)..');'
end

function generate_init (table)	-- expose only at init time
    reg_init = _generate (table, reg_init)
    unreg_init = unreg_init..' \\\n\t'..
	'lua_pushnil(L); '..
	'lua_setglobal(L, "'..(table.lname or table.cname)..'");'
end

function generate_both (table)	-- expose to both namespaces
    reg_both = _generate (table, reg_both)
end

function generate_server (table) -- expose to server namespace only
    reg_server = _generate (table, reg_server)
end

function generate_client (table) -- expose to client namespace only
    reg_client = _generate (table, reg_client)
end


-- Begin output.

print ("/* Generated by bindgen.lua on "..date()..".  Do not edit.  */\n")


-------------
-- store.h --
-------------

generate_init {
    lname	= "store_load",
    args	= {{ String, "filename" },
		   { String, "prefix" }},
    ret		= { Int, "ret", "$",
		    "$ = !store_load_ex(filename, prefix, load_extended_datafile);" }
}


----------------
-- loaddata.h --
----------------

generate_init {
    cname	= "tiles_load",
    args	= {{ String, "filename" },
                   { String, "prefix" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_init {
    cname	= "lights_load",
    args	= {{ String, "filename" },
                   { String, "prefix" }},
    ret		= { Int, "ret", "$ < 0" }
}


----------------
-- objtypes.h --
----------------

generate_init {
    lname	= "objtype_register",
    cname	= "objtypes_register",
    check	= "[sN]ss[fN-]",
    args	= {{ String, "type", nil,
	             "$ = lua_isnil(L, $#) ? 0 : lua_tostring(L, $#);" },
    		   { String, "name" },
		   { String, "icon" },
		   { Method, "func", nil, 
		     "$ = (lua_isnoneornil(L, $#) ? LUA_NOREF : lua_ref(L, $#));" }},
    ret		= { Int, "ret", "$ < 0" }
}


-------------
-- explo.h --
-------------

generate_init {
    lname	= "explosion_type_register",
    cname	= "explosion_type_register",
    check	= "ssnn[sN-][sN-]",
    args	= {{ String, "name" },
		   { String, "first_frame" },
		   { Int, "nframes" },
		   { Int, "tics" },
	       	   { String, "light", nil,
		     "$ = (lua_isnoneornil(L, $#) ? 0 : lua_tostring(L, $#));" },
	           { String, "sound", nil,
		     "$ = (lua_isnoneornil(L, $#) ? 0 : lua_tostring(L, $#)); "}},
    ret		= { Int, "ret", "$ < 0" }
}


--------------
-- object.h --
--------------

generate_init {
    cname	= "new_object_collision_tag",
    args	= {},
    ret		= { ObjTag, "ret" },
    success	= "lua_pushnumber(L, ret); return 1;"
}

generate_server {
    cname	= "object_set_stale",
    lname	= "object_set_stale",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_hide",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_show",
    args	= {{ Object, "obj" }}
}

generate_client {
    cname	= "object_set_highlighted",
    args	= {{ Object, "obj" },
		   { Bool, "yes_or_no" }}
}

generate_client {
    cname	= "object_moving_horizontally",
    lname	= "_internal_object_moving_horizontally",
    args	= {{ Object, "obj" }},
    ret		= { Bool, "ret", "!$" }
}

generate_server {
    cname	= "object_set_collision_is_player",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_set_collision_is_projectile",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_set_collision_is_ladder",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_set_collision_flags_string",
    lname	= "object_set_collision_flags",
    args	= {{ Object, "obj" },
		   { String, "flags" }}
}

generate_server {
    cname	= "object_set_collision_tag",
    args	= {{ Object, "obj" },
		   { ObjTag, "tag" }}
}

generate_server {
    cname	= "object_add_creation_field",
    args	= {{ Object, "obj" },
		   { String, "name" }}
}

generate_both {
    cname	= "object_set_update_hook",
    args	= {{ Object, "obj" },
		   { Int, "msecs" },
		   { Method, "method" }}
}

generate_both {
    cname	= "object_remove_update_hook",
    args	= {{ Object, "obj" }}
}

generate_client {
    cname 	= "object_add_layer",
    args  	= {{ Object, "obj" },
                   { StoreKey, "image" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret 	= { Int, "layerid" },
    success	= "lua_pushnumber(L, layerid); return 1;"
}

generate_client {
    cname	= "object_replace_layer",
    args	= {{ Object, "obj" },
		   { Int, "layerid" },
		   { StoreKey, "image" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_move_layer",
    args	= {{ Object, "obj" },
		   { Int, "layerid" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_hflip_layer",
    args	= {{ Object, "obj" },
		   { Int, "layerid" },
		   { Bool, "hflip" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_rotate_layer",
    args	= {{ Object, "obj" },
		   { Int, "layerid" },
		   { Int, "angle" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_remove_layer",
    args	= {{ Object, "obj" },
		   { Int, "layerid" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_remove_all_layers",
    args	= {{ Object, "obj" }}
}

generate_client {
    cname 	= "object_add_light",
    args  	= {{ Object, "obj" },
                   { StoreKey, "image" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret 	= { Int, "lightid" },
    success	= "lua_pushnumber(L, lightid); return 1;"
}

generate_client {
    cname	= "object_replace_light",
    args	= {{ Object, "obj" },
		   { Int, "lightid" },
		   { StoreKey, "image" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_move_light",
    args	= {{ Object, "obj" },
		   { Int, "lightid" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_remove_light",
    args	= {{ Object, "obj" },
		   { Int, "lightid" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_client {
    cname	= "object_remove_all_lights",
    args	= {{ Object, "obj" }}
}

generate_server {
    cname	= "object_set_mask",
    args	= {{ Object, "obj" },
		   { Int, "masknumber" },
		   { StoreKey, "mask" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_server {
    cname	= "object_set_masks_centre",
    args	= {{ Object, "obj" },
		   { Int, "xoffset" },
		   { Int, "yoffset" }}
}

generate_server {
    cname	= "object_remove_mask",
    args	= {{ Object, "obj" },
		   { Int, "masknumber" }},
    ret		= { Int, "ret", "$ < 0" }
}

generate_server {
    cname	= "object_remove_all_masks",
    args	= {{ Object, "obj" }}
}


--------------
-- svgame.h --
--------------

generate_server {
    cname	= "svgame_spawn_object",
    lname	= "spawn_object",
    args	= {{ String, "typename" },
		   { Float, "x" },
		   { Float, "y" }},
    ret		= { Object, "obj", "!$" },
    success	= "lua_pushobject(L, obj); return 1;"
}

generate_server {
    cname	= "svgame_spawn_projectile",
    lname	= "spawn_projectile",
    check	= "sun[nN-]",
    args	= {{ String, "typename" },
		   { Object, "owner" },
		   { Float, "speed" },
		   { Float, "delta_angle", nil,
		     "$ = (lua_isnoneornil(L, $#) ? 0. : lua_tonumber(L, $#));" }},
    ret		= { Object, "obj", "!$" },
    success	= "lua_pushobject(L, obj); return 1;"
}

generate_server {
    cname	= "svgame_spawn_projectile_raw",
    lname	= "spawn_projectile_raw",
    args	= {{ String, "typename" },
		   { ObjId, "ownerid" },
		   { Float, "x" },
		   { Float, "y" },
		   { Float, "angle" },
		   { Float, "speed" }},
    ret		= { Object, "obj", "!$" },
    success	= "lua_pushobject(L, obj); return 1;"
}

generate_server {
    cname	= "svgame_spawn_blood",
    lname	= "spawn_blood_on_clients",
    args	= {{ Float, "x" },
		   { Float, "y" },
		   { Int, "nparticles" },
		   { Float, "spread" }}
}

generate_server {
    cname	= "svgame_spawn_sparks",
    lname	= "spawn_sparks_on_clients",
    args	= {{ Float, "x" },
		   { Float, "y" },
		   { Int, "nparticles" },
		   { Float, "spread" }}
}

generate_server {
    cname	= "svgame_spawn_respawn_particles",
    lname	= "spawn_respawn_particles_on_clients",
    args	= {{ Float, "x" },
		   { Float, "y" },
		   { Int, "nparticles" },
		   { Float, "spread" }}
}

generate_server {
    cname	= "svgame_spawn_blod",
    lname	= "spawn_blod_on_clients",
    args	= {{ Float, "x" },
		   { Float, "y" },
		   { Int, "nparticles" }}
}

generate_server {
    cname	= "svgame_spawn_explosion",
    lname	= "spawn_explosion_on_clients",
    args	= {{ String, "name" },
		   { Float, "x" },
		   { Float, "y" }}
}

generate_server {
    cname	= "svgame_spawn_blast",
    lname	= "spawn_blast",
    args	= {{ Float, "x" },
		   { Float, "y" },
	           { Float, "radius" },
	       	   { Int, "damage" },
	           { ClientId, "ownerid" }}
}

generate_server {
    cname	= "svgame_call_method_on_clients",
    lname	= "call_method_on_clients",
    check	= "us[sN-]",
    args	= {{ Object, "obj" },
		   { String, "method" },
		   { String, "arg", nil,
		     "$ = (lua_isnoneornil(L, $#) ? \"\" : lua_tostring(L, $#));" }}
}

generate_server {
    cname	= "svgame_object_would_collide_with_player_if_unhidden",
    lname	= "_internal_would_collide_with_player_if_unhidden",
    args	= {{ Object, "obj" }},
    ret		= { Int, "ret", "!$" }
}

generate_server {
    cname	= "svgame_tell_health",
    lname	= "_internal_tell_health",
    args	= {{ Object, "obj" },
		   { Int, "health" }}
}

generate_server {
    cname	= "svgame_tell_armour",
    lname	= "_internal_tell_armour",
    args	= {{ Object, "obj" },
		   { Int, "armour" }}
}

generate_server {
    cname	= "svgame_tell_ammo",
    lname	= "_internal_tell_ammo",
    args	= {{ Object, "obj" },
		   { Int, "ammo" }}
}

generate_server {
    cname	= "svgame_set_score",
    lname	= "set_score",
    args	= {{ ClientId, "clientid" },
		   { String, "score" }}
}

generate_server {
    cname	= "svgame_play_sound_on_clients",
    lname	= "play_sound_on_clients",
    args	= {{ Object, "obj" },
		   { String, "sample" }}
}

generate_server {
    cname	= "svgame_get_client_name",
    lname	= "get_client_name",
    args	= {{ ClientId, "clientid" }},
    ret		= { String, "ret", "!$" },
    success	= "lua_pushstring(L, ret); return 1;"
}

generate_server {
    cname	= "svgame_broadcast_text_message",
    lname	= "broadcast_text_message",
    args	= {{ String, "message" }}
}

generate_server {
    cname	= "svgame_send_text_message",
    lname	= "send_text_message",
    args	= {{ ClientId, "clientid" },
		   { String, "message" }}
}


--------------
-- client.h --
--------------

generate_client {
    cname	= "client_spawn_explosion",
    lname	= "spawn_explosion",
    args	= {{ String, "name" },
		   { Float, "x" },
		   { Float, "y" }}
}

generate_client {
    cname	= "client_play_sound",
    lname	= "play_sound",
    args	= {{ Object, "obj" },
		   { String, "sample" }}
}

generate_client {
    cname	= "client_set_camera",
    lname	= "_internal_set_camera",
    args	= {{ Bool, "pushable" },
		   { Int, "max_dist" }}
}


-- End of declarations

print (reg_init) print ()
print (unreg_init) print ()
print (reg_both) print ()
print (reg_server) print ()
print (reg_client)


-- bindgen.lua ends here
@


1.46
log
@Be a bit tighter with types.
@
text
@d3 4
d230 1
a230 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? LUA_NOREF : lua_ref(L, $#));" }},
d248 1
a248 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? 0 : lua_tostring(L, $#));" },
d250 1
a250 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? 0 : lua_tostring(L, $#)); "}},
d491 1
a491 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? 0. : lua_tonumber(L, $#));" }},
d569 1
a569 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? \"\" : lua_tostring(L, $#));" }}
@


1.45
log
@Exported function to create new collision tags and to set tags.
@
text
@d20 3
d34 3
d258 1
a258 1
    ret		= { Int, "ret" },
d288 1
a288 1
    ret		= { Int, "ret", "!$" }
d316 1
a316 1
		   { Int, "tag" }}
d496 1
a496 1
		   { Int, "owner" },
d555 1
a555 1
	           { Int, "owner" }}
d599 1
a599 1
    args	= {{ Int, "clientid" },
d613 1
a613 1
    args	= {{ Int, "clientid" }},
d627 1
a627 1
    args	= {{ Int, "clientid" },
@


1.44
log
@Made it so only player objects can obstruct other objects from
spawning.
@
text
@d249 7
d305 6
@


1.43
log
@Made mines work.
@
text
@d550 2
a551 2
    cname	= "svgame_object_would_collide_with_objects",
    lname	= "_internal_would_collide_with_objects",
@


1.42
log
@Added function to send a message to only one client.
@
text
@d474 13
@


1.41
log
@Initial armour support.
@
text
@d592 7
@


1.40
log
@Added svgame_get_client_name and svgame_broadcast_text_message
exports.  Also made bindings return true and false by default instead
of 1 and nil.
@
text
@d551 7
@


1.39
log
@Made generated bindings use a proper Bool type where appropriate
instead of an Int.  Added object_set_highlighted binding.
@
text
@d121 1
a121 1
    str = str..tab..(success or "lua_pushnumber(L, 1); return 1;").."\n"
d129 1
a129 1
    str = str.."error:\n"..tab..(error or "lua_pushnil(L); return 1;").."\n"
d569 14
@


1.38
log
@Made all spawn-and-forget server functions be named *_on_clients,
e.g. spawn_blod_on_clients.  Added a different spawn_explosion
binding, so clients can create their own explosions.
@
text
@d15 1
d27 1
d266 6
d351 1
a351 1
		   { Int, "hflip" }},	-- XXX should be Bool
d594 1
a594 1
    args	= {{ Int, "pushable" },	-- XXX should be Bool
@


1.37
log
@Print an warning message if a binding is called with bad arguments.
@
text
@d467 1
a467 1
    lname	= "spawn_blood",
d476 1
a476 1
    lname	= "spawn_sparks",
d485 1
a485 1
    lname	= "spawn_respawn_particles",
d494 1
a494 1
    lname	= "spawn_blod",
d502 1
a502 1
    lname	= "spawn_explosion",
d567 8
@


1.36
log
@Separated bindings that were part of the "init" list into two lists
(one for functions used at init-time, and another for functions which
are available to both server and client at game-time).  Functions used
only at init-time are now removed before the state is split into the
namespaces.
@
text
@d49 1
d63 1
a63 1
    str = "static int bind_"..(lname or cname).."(lua_State *L)\n{\n"
d77 1
a77 1
    str = str..tab..'if (!lua_checkargs(L, "'..(check or generate_check())..'")) goto error;\n'
d89 1
a89 1
	    str = str..tab.."if ("..v[3]..") goto error;\n"
d91 1
a91 1
	    str = str..tab.."if ("..gsub(typ[4], "%$", v[2])..") goto error;\n"
d120 5
@


1.35
log
@object_set_stale is server-only.
@
text
@d127 2
d142 8
a149 1
function generate_both (table)
d153 1
a153 1
function generate_server (table)
d157 1
a157 1
function generate_client (table)
d171 1
a171 1
generate_both {
d184 1
a184 1
generate_both {
d191 1
a191 1
generate_both {
d203 1
a203 1
generate_both {
d221 1
a221 1
generate_both {
d579 4
a582 4
print (reg_both)
print ()
print (reg_server)
print ()
@


1.34
log
@Renamed Lua's "object_destroy" to "object_set_stale", as that's what
it is called in C (I confused myself).

Also, initial part of separating server and client namespaces.
@
text
@d232 1
a232 1
generate_both {
@


1.33
log
@Removed the Lua binding to store_get_index (it wasn't used).
@
text
@d127 3
a129 1
reg = "#define DO_REGISTRATION(L) "
d131 1
a131 1
function generate (table)
d135 15
a149 1
    reg = reg..' \\\n\tlua_register(L, "'..(table.lname or table.cname)..'", bind_'..(table.lname or table.cname)..');'
d162 1
a162 1
generate {
d175 1
a175 1
generate {
d182 1
a182 1
generate {
d194 1
a194 1
generate {
d212 1
a212 1
generate {
d232 1
a232 1
generate {
d234 1
a234 1
    lname	= "object_destroy",
d238 1
a238 1
generate {
d243 1
a243 1
generate {
d248 1
a248 1
generate {
d255 1
a255 1
generate {
d260 1
a260 1
generate {
d265 1
a265 1
generate {
d270 1
a270 1
generate {
d277 1
a277 1
generate {
d283 1
a283 1
generate {
d290 1
a290 1
generate {
d295 1
a295 1
generate {
d305 1
a305 1
generate {
d315 1
a315 1
generate {
d324 1
a324 1
generate {
d332 1
a332 1
generate {
d340 1
a340 1
generate {
d347 1
a347 1
generate {
d352 1
a352 1
generate {
d362 1
a362 1
generate {
d372 1
a372 1
generate {
d381 1
a381 1
generate {
d388 1
a388 1
generate {
d393 1
a393 1
generate {
d403 1
a403 1
generate {
d410 1
a410 1
generate {
d417 1
a417 1
generate {
d427 1
a427 1
generate {
d437 1
a437 1
generate {
d450 1
a450 1
generate {
d459 1
a459 1
generate {
d468 1
a468 1
generate {
d477 1
a477 1
generate {
d485 1
a485 1
generate {
d493 1
a493 1
generate {
d503 1
a503 1
generate {
d513 1
a513 1
generate {
d520 1
a520 1
generate {
d527 1
a527 1
generate {
d534 1
a534 1
generate {
d541 1
a541 1
generate {
d553 1
a553 1
generate {
d560 1
a560 1
generate {
d570 5
a574 1
print (reg)
@


1.32
log
@Added cross-references about where the prototypes of corresponding C
functions can be found.
@
text
@a153 8
generate {
    cname	= "store_get_index",
    lname	= "store_index", -- XXX: temporary
    args	= {{ String, "key" }},
    ret		= { Int, "ret", "!$" },
    success	= "lua_pushnumber(L, ret); return 1;"
}

@


1.31
log
@Added blast accreditation.
@
text
@d141 5
d155 13
d181 4
a184 7
generate {
    cname	= "store_get_index",
    lname	= "store_index", -- XXX: temporary
    args	= {{ String, "key" }},
    ret		= { Int, "ret", "!$" },
    success	= "lua_pushnumber(L, ret); return 1;"
}
d199 5
d219 5
d414 5
d540 5
d558 3
@


1.30
log
@Added bindings for svgame_set_score and svgame_play_sound_on_clients.
@
text
@d461 2
a462 1
	       	   { Int, "damage" }}
@


1.29
log
@Updated for new Store
@
text
@d496 14
@


1.28
log
@Added initial (very incomplete) sound support for weapons.
@
text
@d145 2
a146 2
    ret		= { Int, "ret", "$ < 0",
		    "$ = store_load_ex(filename, prefix, load_extended_datafile);" }
d164 2
a165 1
    cname	= "store_index",
@


1.27
log
@Added sound to explosions.
@
text
@d495 7
@


1.26
log
@Made it so that projectiles cannot hit other projectiles.
@
text
@d186 1
a186 1
    check	= "ssnn[sN-]",
d192 3
a194 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? 0 : lua_tostring(L, $#));" }},
@


1.25
log
@Added client health and ammo displays.
@
text
@d225 5
@


1.24
log
@Added blasts.
@
text
@d474 14
@


1.23
log
@Added support for explosion graphics.
@
text
@d448 9
@


1.22
log
@Changes following cleanup of server and client sources.
@
text
@d184 13
d437 8
@


1.21
log
@Added _internal_would_collide_with_objects().
@
text
@d369 1
a369 1
    cname	= "game_server_spawn_object",
d379 1
a379 1
    cname	= "game_server_spawn_projectile",
d392 1
a392 1
    cname	= "game_server_spawn_blood",
d401 1
a401 1
    cname	= "game_server_spawn_sparks",
d410 1
a410 1
    cname	= "game_server_spawn_respawn_particles",
d419 1
a419 1
    cname	= "game_server_spawn_blod",
d427 1
a427 1
    cname	= "game_server_call_method_on_clients",
d437 1
a437 1
    cname	= "game_server_object_would_collide_with_objects",
d444 1
a444 1
    cname	= "game_client_set_camera",
@


1.20
log
@Added particles for respawning ball.
@
text
@d437 7
@


1.19
log
@Added spark particles.
@
text
@d410 9
@


1.18
log
@Made last argument to call_method_on_clients() optional.
@
text
@d401 9
@


1.17
log
@Made switching to the sniper rifle increase the max distance the
camera can see.
@
text
@d411 1
d414 2
a415 1
		   { String, "arg" }}	-- XXX this should be optional
@


1.16
log
@Added mechanism for server scripts to tell clients to execute object
methods (i.e. remote calls).
@
text
@d416 7
@


1.15
log
@Made spawn_object, spawn_projectile return the objects they create.
@
text
@d397 1
a397 2
		   { Float, "spread" }},
    ret		= { Int, "ret", "$ < 0" }
d405 9
a413 2
		   { Int, "nparticles" }},
    ret		= { Int, "ret", "$ < 0" }
@


1.14
log
@Added a delta_angle parameter to game_server_spawn_projectile().
@
text
@d374 2
a375 1
    ret		= { Int, "ret", "$ < 0" }
d387 2
a388 1
    ret		= { Int, "ret", "$ < 0" }
@


1.13
log
@Allow objects without a category which don't show up in the editor.
@
text
@d380 1
d383 3
a385 1
		   { Float, "speed" }},
@


1.12
log
@Added blods.
@
text
@d173 3
a175 2
    check	= "sss[fN-]",
    args	= {{ String, "type" },
d179 2
a180 1
		     "$ = ((lua_isnil(L, $#) || lua_isnull(L, $#)) ? LUA_NOREF : lua_ref(L, $#));" }}
@


1.11
log
@Prefixed internal functions/variables that are somehow accessible from
Lua with "_internal".
@
text
@d394 9
@


1.10
log
@Added support for ladders.
@
text
@a196 2
-- little hack for player walking animation code in basic-player.lua
-- don't use it!
d199 1
a199 1
    lname	= "_object_moving_horizontally",
@


1.9
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@d212 5
@


1.8
log
@Updated to Lua 4.1-work3.
@
text
@d387 1
a387 1
		   { Int, "spread" }},
@


1.7
log
@Added ``hidden'' attribute to objects.
@
text
@d54 2
a55 2
	for i,v in %args do
	    local typ = %ctypes[v[1]]
d269 1
a269 1
		   { Int, "hflip" }},
@


1.6
log
@Added object_set_masks_centre() for the situation where you want to
change where the centre of all the bitmasks are at once.
@
text
@d187 10
@


1.5
log
@Added `object_moving_horizontally' function, which is a hack for the
player walking animation.
@
text
@d335 7
@


1.4
log
@Added an ``update hook'' feature to objects
@
text
@d187 9
@


1.3
log
@Bound object_add_creation_field
@
text
@d206 12
@


1.2
log
@New lua binding to spawn an arbitrary object
@
text
@d200 6
@


1.1
log
@Initial revision
@
text
@d320 9
@

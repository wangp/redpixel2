head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	2002.07.11.12.24.33;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.03.07.49.22;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.01.14.52.15;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.22.04.04.23;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.19.01.35.55;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Separated the one Lua state into two namespaces: server and client, so
that scripts run on the server don't have access to client-only
functions, and vice versa.  This makes things much less murky.
@
text
@/* objtypes.c
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <allegro.h>
#include "alloc.h"
#include "bitmask.h"
#include "bitmaskg.h"
#include "error.h"
#include "mylua.h"
#include "objtypes.h"
#include "store.h"


struct objtype {
    char *type;
    char *name;
    char *icon;
    lua_ref_t init_func;
    bitmask_t *icon_mask;
};


static int num;
static objtype_t **types;


static objtype_t *create (const char *type, const char *name,
			  const char *icon, lua_ref_t init_func,
			  bitmask_t *icon_mask)
{
    objtype_t *p, **tmp;

    p = alloc (sizeof *p);

    tmp = realloc (types, sizeof (objtype_t *) * (num + 1));
    if (!tmp) {
	free (p);
	return 0;
    }

    p->type = type ? ustrdup (type) : 0;
    p->name = ustrdup (name);
    p->icon = ustrdup (icon);
    p->init_func = init_func;
    p->icon_mask = icon_mask;

    types = tmp;
    types[num++] = p;

    return p;
}


static void destroy_all (void)
{
    int i;

    for (i = 0; i < num; i++) {
	bitmask_destroy (types[i]->icon_mask);
	lua_unref (the_lua_state, types[i]->init_func);
	free (types[i]->icon);
	free (types[i]->name);
	free (types[i]->type);
	free (types[i]);
    }

    free (types);
}


void objtypes_init (void)
{
    types = 0;
    num = 0;
}


void objtypes_shutdown (void)
{
    destroy_all ();
}


int objtypes_register (const char *type, const char *name,
			const char *icon, lua_ref_t init_func)
{
    BITMAP *icon_bmp;
    char buf[512];

    icon_bmp = store_get_dat (icon);
    if (!icon_bmp) {
	uszprintf (buf, sizeof buf, "Bad icon %s\n", icon);
	error (buf);
    }

    return (create (type, name, icon, init_func,
		    bitmask_create_from_magic_bitmap (icon_bmp))
	    ? 0 : -1);
}


objtype_t *objtypes_lookup (const char *name)
{
    int i;

    for (i = 0; i < num; i++)
	if (!ustrcmp (types[i]->name, name))
	    return types[i];

    return NULL;
}


void objtypes_enumerate (void (*proc) (objtype_t *type))
{
    int i;

    for (i = 0; i < num; i++)
	proc (types[i]);
}


const char *objtype_type (objtype_t *type)
{
    return type->type;
}


const char *objtype_name (objtype_t *type)
{
    return type->name;
}


const char *objtype_icon (objtype_t *type)
{
    return type->icon;
}


lua_ref_t objtype_init_func (objtype_t *type)
{
    return type->init_func;
}


bitmask_t *objtype_icon_mask (objtype_t *type)
{
    return type->icon_mask;
}
@


1.6
log
@Updated for new Store
@
text
@d63 1
a63 1
	lua_unref (lua_state, types[i]->init_func);
@


1.5
log
@Updated mingw port.
@
text
@d93 1
a93 1
    icon_bmp = store_dat (icon);
@


1.4
log
@Changed all "()" declarations to "(void)".
@
text
@d95 1
a95 1
	snprintf (buf, sizeof buf, "Bad icon %s\n", icon);
@


1.3
log
@Abort with an error if icon argument to objtype_register() does not
point to a valid bitmap.
@
text
@d57 1
a57 1
static void destroy_all ()
d74 1
a74 1
void objtypes_init ()
d81 1
a81 1
void objtypes_shutdown ()
@


1.2
log
@Return error code if registering an object type failed.
@
text
@d11 1
d90 9
d100 1
a100 1
		    bitmask_create_from_magic_bitmap (store_dat (icon)))
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
    p->type = ustrdup (type);
d86 1
a86 1
void objtypes_register (const char *type, const char *name,
d89 3
a91 2
    create (type, name, icon, init_func,
	    bitmask_create_from_magic_bitmap (store_dat (icon)));
@

head	1.7;
access;
symbols;
locks; strict;
comment	@# @;


1.7
date	2002.12.18.15.02.37;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.17.03.35.52;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.14.15.57;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.19.12.37.08;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.17.14.29.39;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.15.10.14.01;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Updated for Lua 5.0 beta
@
text
@-- objgen.lua -- generate game object field accessors


-- supported types

Float = 'Float'
Int = 'Int'
Bool = 'Bool'

types = {
    Float = { 
	predicate = 'lua_isnumber',
	get = 'lua_pushnumber(L, @@VAR@@);',
	set = '@@VAR@@ = lua_tonumber(@@LUA@@);'
    },
    Int = {
	predicate = 'lua_isnumber',
	get = 'lua_pushnumber(L, @@VAR@@);',
	set = '@@VAR@@ = lua_tonumber(@@LUA@@);'
    },
    Bool = {
	predicate = nil,
	get = 'if (@@VAR@@) lua_pushnumber(L, 1); else lua_pushnil(L);',
	set = '@@VAR@@ = !lua_isnil(@@LUA@@);'
    }
}


-- variables from struct object that should be read/write from Lua
-- XXX: actually, most should probably be read-only

cvars = {{ Int, 'id' },
	 { Float, 'x' },
	 { Float, 'y' },
	 { Float, 'xv' },
	 { Float, 'yv' },
	 { Float, 'xv_decay' },
	 { Float, 'yv_decay' },
	 { Float, 'mass' },
	 { Bool, 'is_proxy' },
	 { Int, 'collision_tag' }}


-- helpers
	 
function p (indent, string)
    for i = 1,indent do string = '\t'..string end
    print (string)
end


-- header

p (0, '/* Generated by objgen.lua on '..os.date()..'.  Do not edit.  */\n')

p (0, [[
static void type_mismatch_in_assign(lua_State *L)
{
    lua_pushstring(L, "type mismatch in assignment");
    lua_error(L);
}
]])


-- index metatable method

p (0, 'static int')
p (0, 'object_metatable_index(lua_State *L)')
p (0, '{')
p (1, 'struct object *quux = lua_unboxpointer(L, 1);')
p (1, 'const char *index = lua_tostring(L, 2);')
for i,v in cvars do
    local vtype, vname = types[v[1]], v[2]
    p (1, ((i == 1) and '' or 'else ')..'if (0 == strcmp(index, "'..vname..'")) {')
    p (2, string.gsub(vtype.get, '@@VAR@@', 'quux->'..vname))
    p (1, '}')
end
p (1, 'else {')
p (2, 'lua_getref(L, quux->table);')
p (2, 'lua_pushvalue(L, 2);')
p (2, 'lua_rawget(L, -2);')
p (1, '}')
p (1, 'return 1;')
p (0, '}\n')


-- newindex metatable method

p (0, 'static int')
p (0, 'object_metatable_newindex(lua_State *L)')
p (0, '{')
p (1, 'struct object *quux = lua_unboxpointer(L, 1);')
p (1, 'const char *index = lua_tostring(L, 2);')
for i,v in cvars do
    local vtype, vname = types[v[1]], v[2]
    p (1, ((i == 1) and '' or 'else ')..'if (0 == strcmp(index, "'..vname..'")) {')
    if vtype.predicate then
	p (2, 'if (!'..vtype.predicate..'(L, 3)) type_mismatch_in_assign(L);')
    end
    p (2, string.gsub(string.gsub(vtype.set, '@@VAR@@', 'quux->'..vname), '@@LUA@@', 'L, 3'))
    p (1, '}')
end
p (1, 'else {')
p (1, '\tlua_getref(L, quux->table);')
p (1, '\tlua_pushvalue(L, 2);')
p (1, '\tlua_pushvalue(L, 3);')
p (1, '\tlua_rawset(L, -3);')
p (1, '}')
p (1, 'return 1;')
p (0, '}')


-- tag method registration
print ([[
#define REGISTER_OBJECT_METATABLE_METHODS(L)			\
	lua_pushliteral(L, "__index");				\
	lua_pushcfunction(L, object_metatable_index);		\
	lua_settable(L, -3);					\
	lua_pushliteral(L, "__newindex");			\
	lua_pushcfunction(L, object_metatable_newindex);	\
	lua_settable(L, -3);
]])


-- objgen.lua ends here
@


1.6
log
@Updated to Lua 5.0 alpha.
@
text
@d65 1
a65 1
-- gettable metatable method
d68 1
a68 1
p (0, 'object_metatable_gettable(lua_State *L)')
d87 1
a87 1
-- settable metatable method
d90 1
a90 1
p (0, 'object_metatable_settable(lua_State *L)')
d116 2
a117 2
	lua_pushliteral(L, "__gettable");			\
	lua_pushcfunction(L, object_metatable_gettable);	\
d119 2
a120 2
	lua_pushliteral(L, "__settable");			\
	lua_pushcfunction(L, object_metatable_settable);	\
@


1.5
log
@Updated to Lua 4.1-work4.
@
text
@d54 9
a62 1
p (0, '/* Generated by objgen.lua on '..date()..'.  Do not edit.  */\n')
d70 1
a70 1
p (1, 'struct object *quux = lua_touserdata(L, 1);')
d75 1
a75 1
    p (2, gsub(vtype.get, '@@VAR@@', 'quux->'..vname))
d92 1
a92 1
p (1, 'struct object *quux = lua_touserdata(L, 1);')
d98 1
a98 1
	p (2, 'if (!'..vtype.predicate..'(L, 3)) lua_error(L, "type mismatch in assignment");')
d100 1
a100 1
    p (2, gsub(gsub(vtype.set, '@@VAR@@', 'quux->'..vname), '@@LUA@@', 'L, 3'))
d116 1
a116 1
	lua_pushliteral(L, "gettable");				\
d119 1
a119 1
	lua_pushliteral(L, "settable");				\
@


1.4
log
@Exposed object's id value.  This was done for corpse tracking after
death, but I'm not too sure it should be done like this generally.
@
text
@d57 1
a57 1
-- gettable eventtable method
d60 1
a60 1
p (0, 'object_eventtable_gettable(lua_State *L)')
d79 1
a79 1
-- settable eventtable method
d82 1
a82 1
p (0, 'object_eventtable_settable(lua_State *L)')
d107 1
a107 1
#define REGISTER_OBJECT_EVENTTABLE_METHODS(L)			\
d109 1
a109 1
	lua_pushcfunction(L, object_eventtable_gettable);	\
d112 1
a112 1
	lua_pushcfunction(L, object_eventtable_settable);	\
@


1.3
log
@Removed player-only `jump' and `_ramp' variables from object struc,
and used the generic lua table instead.
@
text
@d30 1
d32 2
a33 1
cvars = {{ Float, 'x' },
@


1.2
log
@Updated to Lua 4.1-work3.
@
text
@a38 1
	 { Int, '_ramp' },
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
-- gettable tag method
d59 1
a59 1
p (0, 'object_gettable_tm(lua_State *L)')
d78 1
a78 1
-- settable tag method
d81 1
a81 1
p (0, 'object_settable_tm(lua_State *L)')
d106 7
a112 3
#define REGISTER_OBJECT_TAG_METHODS(L,TAG)						\
	lua_pushcfunction(L, object_gettable_tm); lua_settagmethod(L, TAG, "gettable"); \
	lua_pushcfunction(L, object_settable_tm); lua_settagmethod(L, TAG, "settable"); \
@

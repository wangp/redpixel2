head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2002.01.24.15.33.33;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Added client sending text messages, scrolling message text and
slightly better input (e.g. backspacing).
@
text
@/* messages.c - client message interface
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <stdarg.h>
#include <string.h>
#include <allegro.h>
#include "client.h"
#include "magic4x4.h"
#include "messages.h"
#include "store.h"
#include "timeout.h"


typedef unsigned short ucs16_t;


#define MAX_LINES	100
#define VISIBLE_LINES	5
#define MAX_INPUT_LEN	30
#define SCROLL_SPEED	5000


static char *lines[MAX_LINES];
static int num_lines;
static int top_line;

static timeout_t next_scroll;

static ucs16_t input_line[MAX_INPUT_LEN]; /* UCS-2 string */
static int input_pos;
static int input_enabled;
static int input_blink;

static FONT *fnt;
static int text_colour;
static int input_colour;


static const char *ucs16_to_utf8 (const ucs16_t *text)
{
    return uconvert ((const char *) text, U_UNICODE, NULL, U_UTF8, 0);
}


int messages_init (void)
{
    if (!(fnt = store_dat ("/basic/font/mini")))
	return -1;
    
    text_colour = makecol24 (0xaf, 0xdf, 0xaf);
    input_colour = makecol24 (0xaf, 0xaf, 0xff);
    
    top_line = 0;
    input_enabled = 0;
    input_line[0] = 0;
    return 0;
}


void messages_shutdown (void)
{
    int i;
    for (i = 0; i < num_lines; i++)
	free (lines[i]);
    num_lines = 0;
}


#define XMARGIN	4
#define YMARGIN	2


static void textout_right_magic (BITMAP *bmp, FONT *font, const char *buf,
				 int x, int y, int color)
{
    int len = text_length (font, buf);
    int rtm = text_mode (-1);
    BITMAP *tmp;

    tmp = create_magic_bitmap (len, text_height (font));
    clear_bitmap (tmp);
    textout (tmp, font, buf, 0, 0, color);
    draw_magic_sprite (bmp, tmp, x - len, y);
    destroy_bitmap (tmp);

    text_mode (rtm);
}


void messages_render (BITMAP *bmp)
{
    int i, y, h;
    
    y = YMARGIN;
    h = text_height (fnt);

    for (i = top_line; i < num_lines; i++, y += h)
	textout_right_magic (bmp, fnt, lines[i], bmp->w/3 - XMARGIN, y,
			     text_colour);

    if (input_enabled) {
	textout_right_magic (bmp, fnt, ucs16_to_utf8 (input_line),
			     bmp->w/3 - XMARGIN - text_length (fnt, "_"), y,
			     input_colour);
	if (input_blink & 0x8)
	    textout_right_magic (bmp, fnt, "_", bmp->w/3 - XMARGIN, y,
				 input_colour);
	input_blink = (input_blink+1) & 0xf;
    }
}


static void scroll_line (void)
{
    if (num_lines > 0) {
	free (lines[0]);
	memmove (lines, lines+1, (sizeof lines[0]) * (num_lines-1));
	num_lines--;
    }

    timeout_set (&next_scroll, SCROLL_SPEED);
}


static void push_line (const char *msg)
{
    if (num_lines == MAX_LINES)
	scroll_line ();

    lines[num_lines] = strdup (msg);
    num_lines++;

    if ((num_lines - top_line) > VISIBLE_LINES)
	top_line++;

    if (num_lines == 1)
	timeout_set (&next_scroll, SCROLL_SPEED);
}


void messages_add (const char *fmt, ...)
{
    char buf[1024];
    va_list ap;
    
    va_start (ap, fmt);
    uvszprintf (buf, sizeof buf, fmt, ap);
    va_end (ap);
    
    push_line (buf);
}


void messages_poll_input (void)
{
    if ((num_lines > 0) && timeout_test (&next_scroll))
	scroll_line ();
    
    while (keypressed ()) {
	int c, sc;
	c = ureadkey (&sc);

	if (sc == KEY_ENTER) {
	    if (input_enabled) {
		if (input_line[0])
		    client_send_text_message (ucs16_to_utf8 (input_line));
		input_enabled = 0;
	    }
	    else {
		input_line[0] = 0;
		input_pos = 0;
		input_enabled = 1;
	    }
	    continue;
	}

	if (!input_enabled)
	    continue;

	switch (sc) {

	    case KEY_ESC:
		input_enabled = 0;
		break;
		
	    case KEY_BACKSPACE:
		if (input_pos > 0)
		    input_line[--input_pos] = 0;
		break;

	    case KEY_LEFT:
	    case KEY_RIGHT:
	    case KEY_UP:
	    case KEY_DOWN:
	    case KEY_PGUP:
	    case KEY_PGDN:
	    case KEY_HOME:
	    case KEY_END:
		/* todo */
		break;

	    case '':
		input_line[0] = 0;
		input_pos = 0;
		break;

	    default:
		if ((c) && (input_pos < MAX_INPUT_LEN - 1)) {
		    input_line[input_pos++] = c;
		    input_line[input_pos] = 0;
		}
		break;
	}
    }
}


int messages_grabbed_keyboard (void)
{
    return input_enabled;
}
@


1.2
log
@Changed all "()" declarations to "(void)".
@
text
@d1 1
a1 1
/* messages.c
d10 1
d14 4
d22 3
d30 3
a32 1
static char input_line[512];
d38 8
d52 4
d58 1
d72 1
a72 1
#define XMARGIN	8
d76 2
a77 1
static void textout_right_magic (BITMAP *bmp, FONT *font, const char *buf, int x, int y, int color)
d101 2
a102 1
	textout_right_magic (bmp, fnt, lines[i], bmp->w/3 - XMARGIN, y, -1);
d105 6
a110 4
	textout_right_magic (bmp, fnt, input_line, bmp->w/3 - XMARGIN - 
			     text_length (fnt, "_"), y, -1);
	if ((input_blink & 0x8))
	    textout_right_magic (bmp, fnt, "_", bmp->w/3 - XMARGIN, y, -1);
d116 1
a116 1
static void push_line (const char *msg)
d118 1
a118 1
    if (num_lines == MAX_LINES) {
d124 10
a133 1
    lines[num_lines] = ustrdup (msg);
d138 3
d159 3
a161 2
    int c;

d163 2
a164 1
	c = readkey ();
d166 4
a169 2
	if ((c >> 8) == KEY_ENTER) {
	    if (input_enabled) 
d171 1
d173 1
a173 1
		usetat (input_line, 0, 0);
d177 1
d179 37
a215 3
	else if (input_enabled) {
	    usetat (input_line, input_pos++, c & 0xff);
	    usetat (input_line, input_pos, 0);
d218 6
@


1.1
log
@Initial revision
@
text
@d11 1
d30 1
a30 1
int messages_init ()
d40 1
a40 1
void messages_shutdown ()
a70 1
    FONT *fnt = font;		/* XXX current font doesn't work yet */
d118 1
a118 1
void messages_poll_input ()
@

head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2002.02.01.14.56.13;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Changed the Windows port to use critical sections instead of
semaphores for synchronisation between client and server.  Also made
the client not yield() in non-multithreaded, as it's really not
necessary and worsens performance under Windows (see also recent
change to yield.c).
@
text
@/* sync.c - client and server thread synchronisation
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <allegro.h>
#include "sync.h"
#include "yield.h"


#ifdef THREADS_PTHREAD


#include <pthread.h>


static int threaded;
static pthread_t thread;
static pthread_mutex_t mutex;
static pthread_cond_t cond;


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	pthread_mutex_init (&mutex, NULL);
	pthread_cond_init (&cond, NULL);
	pthread_create (&thread, NULL, server_thread, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	pthread_join (thread, NULL);
	pthread_cond_destroy (&cond);
	pthread_mutex_destroy (&mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	pthread_mutex_lock (&mutex);
	pthread_cond_wait (&cond, &mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


int sync_server_stop_requested (void)
{
    return 0;
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	pthread_mutex_unlock (&mutex);
}


void sync_client_lock (void)
{
    if (threaded) {
	pthread_mutex_lock (&mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (threaded) {
	pthread_cond_signal (&cond);
	pthread_mutex_unlock (&mutex);
    }
}


#endif



/* Win32 code based on fibres. 
   Doesn't exit properly yet, and I'm not sure it's any better than critical sections.
 */
#if 0


#include <winalleg.h>
#include <process.h>


static int threaded;
static int stop_requested;
static void *server_fiber;
static void *client_fiber;


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	ConvertThreadToFiber (NULL);
	stop_requested = 0;
	client_fiber = GetCurrentFiber ();
	server_fiber = CreateFiber (1024, (LPFIBER_START_ROUTINE) server_thread, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	stop_requested = 1;
	WaitForSingleObject (server_fiber, INFINITE);
// XXX non-proper cleanup
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	SwitchToFiber (client_fiber);
}


int sync_server_stop_requested (void)
{
    return stop_requested;
}


void sync_client_lock (void)
{
    if (threaded) {
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else
	SwitchToFiber (server_fiber);
}


#endif



/* Win32 code based on critical sections. */
#ifdef THREADS_WIN32


#include <winalleg.h>
#include <process.h>


static int threaded;
static HANDLE thread;
static int stop_requested;
static CRITICAL_SECTION cs;


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	InitializeCriticalSection (&cs);
	stop_requested = 0;
	thread = (HANDLE) _beginthread ((void (*) (void*)) server_thread, 0, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	stop_requested = 1;
	WaitForSingleObject (thread, INFINITE);
	DeleteCriticalSection (&cs);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	EnterCriticalSection (&cs);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	LeaveCriticalSection (&cs);
}


int sync_server_stop_requested (void)
{
    return stop_requested;
}


void sync_client_lock (void)
{
    if (threaded) {
	EnterCriticalSection (&cs);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else
	LeaveCriticalSection (&cs);
}


#endif



/* Win32 code based on events. */
#if 0


#include <winalleg.h>
#include <process.h>


static int threaded;
static HANDLE thread;
static int stop_requested;
static HANDLE server_event;
static HANDLE client_event;


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	server_event = CreateEvent (NULL, FALSE, FALSE, NULL);
	client_event = CreateEvent (NULL, FALSE, FALSE, NULL);	
	stop_requested = 0;
	thread = (HANDLE) _beginthread ((void (*) (void*)) server_thread, 0, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	stop_requested = 1;
	WaitForSingleObject (thread, INFINITE);
	CloseHandle (server_event);
	CloseHandle (client_event);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	SignalObjectAndWait (client_event, server_event, INFINITE, FALSE);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
}


int sync_server_stop_requested (void)
{
    return stop_requested;
}


void sync_client_lock (void)
{
    if (threaded) {
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else
	SignalObjectAndWait (server_event, client_event, INFINITE, FALSE);
}


#endif



/* Win32 code based on semaphores.  */
#if 0


#include <winalleg.h>
#include <process.h>


static int threaded;
static HANDLE thread;
static int stop_requested;
static HANDLE semaphore;


#define SEM_VALUE_MAX   ((int) ((~0u) >> 1))


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	semaphore = CreateSemaphore (NULL, 1, 1, NULL);
	stop_requested = 0;
	thread = (HANDLE) _beginthread ((void (*) (void*)) server_thread, 0, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	stop_requested = 1;
	WaitForSingleObject (thread, INFINITE);
	CloseHandle (semaphore);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	WaitForSingleObject (semaphore, INFINITE);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	ReleaseSemaphore (semaphore, 1, NULL);
}


int sync_server_stop_requested (void)
{
    return stop_requested;
}


void sync_client_lock (void)
{
    if (threaded) {
	WaitForSingleObject (semaphore, INFINITE);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else
	ReleaseSemaphore (semaphore, 1, NULL);
}


#endif
@


1.2
log
@Changed all "()" declarations to "(void)".
@
text
@d83 61
d146 15
a160 3
    else {
	pthread_cond_signal (&cond);
	pthread_mutex_unlock (&mutex);
d165 9
d177 2
d180 166
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
void sync_shutdown ()
d47 1
a47 1
void sync_server_lock ()
d57 1
a57 1
int sync_server_stop_requested ()
d63 1
a63 1
void sync_server_unlock ()
d72 1
a72 1
void sync_client_lock ()
d81 1
a81 1
void sync_client_unlock ()
d122 1
a122 1
void sync_shutdown ()
d134 1
a134 1
void sync_server_lock ()
d143 1
a143 1
void sync_server_unlock ()
d152 1
a152 1
int sync_server_stop_requested ()
d158 1
a158 1
void sync_client_lock ()
d167 1
a167 1
void sync_client_unlock ()
@

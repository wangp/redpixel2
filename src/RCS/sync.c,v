head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2002.01.24.07.23.01;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Changed all "()" declarations to "(void)".
@
text
@/* sync.c - client and server thread synchronisation
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <allegro.h>
#include "sync.h"
#include "yield.h"


#ifdef THREADS_PTHREAD


#include <pthread.h>


static int threaded;
static pthread_t thread;
static pthread_mutex_t mutex;
static pthread_cond_t cond;


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	pthread_mutex_init (&mutex, NULL);
	pthread_cond_init (&cond, NULL);
	pthread_create (&thread, NULL, server_thread, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	pthread_join (thread, NULL);
	pthread_cond_destroy (&cond);
	pthread_mutex_destroy (&mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	pthread_mutex_lock (&mutex);
	pthread_cond_wait (&cond, &mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


int sync_server_stop_requested (void)
{
    return 0;
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	pthread_mutex_unlock (&mutex);
}


void sync_client_lock (void)
{
    if (threaded) {
	pthread_mutex_lock (&mutex);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else {
	pthread_cond_signal (&cond);
	pthread_mutex_unlock (&mutex);
    }
}


#endif


#ifdef THREADS_WIN32


#include <winalleg.h>
#include <process.h>


static int threaded;
static HANDLE thread;
static int stop_requested;
static HANDLE semaphore;


#define SEM_VALUE_MAX   ((int) ((~0u) >> 1))


void sync_init (void *(*server_thread)(void *))
{
    if (server_thread) {
	threaded = 1;
	semaphore = CreateSemaphore (NULL, 1, 1, NULL);
	stop_requested = 0;
	thread = (HANDLE) _beginthread ((void (*) (void*)) server_thread, 0, NULL);
    }
}


void sync_shutdown (void)
{
    if (threaded) {
	stop_requested = 1;
	WaitForSingleObject (thread, INFINITE);
	CloseHandle (semaphore);
	allegro_errno = &errno;	/* errno is thread-specific */
	threaded = 0;
    }
}


void sync_server_lock (void)
{
    if (threaded) {
	WaitForSingleObject (semaphore, INFINITE);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_server_unlock (void)
{
    if (!threaded)
	yield ();
    else
	ReleaseSemaphore (semaphore, 1, NULL);
}


int sync_server_stop_requested (void)
{
    return stop_requested;
}


void sync_client_lock (void)
{
    if (threaded) {
	WaitForSingleObject (semaphore, INFINITE);
	allegro_errno = &errno;	/* errno is thread-specific */
    }
}


void sync_client_unlock (void)
{
    if (!threaded)
	yield ();
    else
	ReleaseSemaphore (semaphore, 1, NULL);
}


#endif
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
void sync_shutdown ()
d47 1
a47 1
void sync_server_lock ()
d57 1
a57 1
int sync_server_stop_requested ()
d63 1
a63 1
void sync_server_unlock ()
d72 1
a72 1
void sync_client_lock ()
d81 1
a81 1
void sync_client_unlock ()
d122 1
a122 1
void sync_shutdown ()
d134 1
a134 1
void sync_server_lock ()
d143 1
a143 1
void sync_server_unlock ()
d152 1
a152 1
int sync_server_stop_requested ()
d158 1
a158 1
void sync_client_lock ()
d167 1
a167 1
void sync_client_unlock ()
@

head	1.49;
access;
symbols;
locks; strict;
comment	@ * @;


1.49
date	2002.07.15.11.06.06;	author tjaden;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.15.08.47.33;	author tjaden;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.14.03.09.14;	author tjaden;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.14.01.32.36;	author tjaden;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.13.13.03.01;	author tjaden;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.13.07.23.25;	author tjaden;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.12.06.52.13;	author tjaden;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.12.05.21.01;	author tjaden;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.11.12.25.18;	author tjaden;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.11.05.23.47;	author tjaden;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.10.15.38.59;	author tjaden;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.10.10.34.47;	author tjaden;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.09.15.20.29;	author tjaden;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.09.14.36.40;	author tjaden;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.09.10.00.47;	author tjaden;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.03.07.50.33;	author tjaden;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.11.04.27.13;	author tjaden;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.05.04.09.04;	author tjaden;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.01.14.57.50;	author tjaden;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.31.12.20.58;	author tjaden;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.29.14.57.49;	author tjaden;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.28.13.19.28;	author tjaden;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.28.13.01.09;	author tjaden;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.27.14.05.50;	author tjaden;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.26.12.14.36;	author tjaden;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.26.11.54.57;	author tjaden;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.24.15.32.32;	author tjaden;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.24.07.18.21;	author tjaden;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.23.14.09.30;	author tjaden;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.06.30.47;	author tjaden;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.23.03.52.43;	author tjaden;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.22.01.48.20;	author tjaden;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.21.15.26.58;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.21.04.15.37;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.21.00.21.29;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.20.13.53.35;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.12.35.17;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.14.31.08;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.13.29.43;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.15.13.28.24;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.16.07.37;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.14.14.28.50;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.13.53.33;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.08.38.05;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.42.19;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.02.22.09;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.13.15.01.43;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.13.09.30.22;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Changed the type of object collision tags.
@
text
@/* client.c
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <math.h>
#include <allegro.h>
#include "libnet.h"
#include "alloc.h"
#include "blod.h"
#include "camera.h"
#include "client.h"
#include "clsvface.h"
#include "error.h"
#include "fps.h"
#include "list.h"
#include "magic4x4.h"
#include "map.h"
#include "mapfile.h"
#include "mathcnst.h"
#include "messages.h"
#include "mylibnet.h"
#include "netmsg.h"
#include "object.h"
#include "packet.h"
#include "particle.h"
#include "render.h"
#include "screen.h"
#include "server.h"
#include "sound.h"
#include "store.h"
#include "sync.h"
#include "textout.h"
#include "timeout.h"


#if 0
# define dbg(msg)	puts ("[client] " msg)
#else
# define dbg(msg)
#endif


typedef unsigned char uchar_t;
typedef unsigned long ulong_t;

#define Lclt client_lua_namespace


/* our connection */
static NET_CONN *conn;
static int client_id;
static char *client_name;

/* for rendering */
static BITMAP *bmp;
static camera_t *cam;

static BITMAP *bkgd;
static int parallax_x = 2;
static int parallax_y = 2;

static BITMAP *crosshair;
static BITMAP *health_icon;
static BITMAP *armour_icon;
static BITMAP *ammo_icon;

/* the game state */
static map_t *map;
static object_t *local_object;
static object_t *tracked_object;
static struct {	/* for displaying only; the real values are on server */
    int health;
    int armour;
    int ammo;
} display_values;

/* network stuff */
static int pinging;
static ulong_t last_ping_time;
static int lag;
static int last_controls;
static float aim_angle;
static float last_aim_angle;

/* how bright the scoresheet is (0-15).  0 = disabled */
static int scores_brightness;



/*
 *----------------------------------------------------------------------
 *	Display switch callbacks
 *----------------------------------------------------------------------
 */


static int backgrounded;


static void switch_in_callback (void)
{
    backgrounded = 0;
}


static void switch_out_callback (void)
{
    backgrounded = 1;
}


static void display_switch_init (void)
{
    set_display_switch_callback (SWITCH_IN, switch_in_callback);
    set_display_switch_callback (SWITCH_OUT, switch_out_callback);
    backgrounded = 0;
}


static void display_switch_shutdown (void)
{
    remove_display_switch_callback (switch_out_callback);
    remove_display_switch_callback (switch_in_callback);
}



/*
 *----------------------------------------------------------------------
 *	Tick counter
 *----------------------------------------------------------------------
 */


/* keep in sync with server */
#define TICKS_PER_SECOND	(50)
#define MSECS_PER_TICK		(1000 / TICKS_PER_SECOND)


static volatile ulong_t ticks;


static void ticker (void)
{
    ticks++;
}

END_OF_STATIC_FUNCTION (ticker);


static void ticks_init (void)
{
    LOCK_VARIABLE (ticks);
    LOCK_FUNCTION (ticker);
    install_int_ex (ticker, BPS_TO_TIMER (TICKS_PER_SECOND));
    ticks = 0;
}


static void ticks_shutdown (void)
{
    remove_int (ticker);
}



/*
 *----------------------------------------------------------------------
 *	Remember some info about other clients
 *----------------------------------------------------------------------
 */


typedef struct client_info {
    struct client_info *next;
    struct client_info *prev;
    int id;
    char *name;
    char *score;
} client_info_t;


static list_head_t client_info_list;


static void client_info_list_init (void)
{
    list_init (client_info_list);
}


static void client_info_list_add (int id, const char *name, const char *score)
{
    client_info_t *c = alloc (sizeof *c);

    c->id = id;
    c->name = ustrdup (name);
    c->score = ustrdup (score);
    list_append (client_info_list, c);
}


static client_info_t *get_client_info (int id)
{
    client_info_t *c;

    list_for_each (c, &client_info_list)
	if (c->id == id)
	    return c;

    return NULL;
}


static void client_info_list_remove (int id)
{
    client_info_t *c = get_client_info (id);
    if (c)
	list_remove (c);
}


static void client_info_list_set_score (int id, const char *score)
{
    client_info_t *c = get_client_info (id);
    if (c) {
	free (c->score);
	c->score = ustrdup (score);
    }
}


static void _free_client_info (client_info_t *c)
{
    free (c->score);
    free (c->name);
    free (c);
}


static void client_info_list_free (void)
{
    list_free (client_info_list, _free_client_info);
}


/*
 * Process incoming client add/remove packets from the server.
 * These can come in at almost any time.
 */


static void process_sc_client_add (const char *buf)
{
    long id;
    short nlen;
    char name[NETWORK_MAX_PACKET_SIZE];
    short slen;
    char score[NETWORK_MAX_PACKET_SIZE];

    packet_decode (buf, "lss", &id, &nlen, name, &slen, score);
    client_info_list_add (id, name, score);
}


static void process_sc_client_remove (const char *buf)
{
    long id;
    packet_decode (buf, "l", &id);
    client_info_list_remove (id);
}



/*
 *----------------------------------------------------------------------
 *	Perform simple physics (simulation)
 *----------------------------------------------------------------------
 */


static void perform_simple_physics (ulong_t curr_ticks, int delta_ticks)
{
    list_head_t *object_list;
    object_t *obj;
    int i;

    object_list = map_object_list (map);
    list_for_each (obj, object_list) {
	if (!object_is_client_processed (obj)) {
	    object_do_simulation (obj, curr_ticks);
	    continue;
	}

	/*
	 * For CLIENT PROCESSED objects, we have to do some thinking
	 * about the physics ourselves, as if we were the server.  But
	 * we do not have accurate data to work with, so ONLY use
	 * proxy-only objects when:
	 *
	 *  (1) inaccurate results for this object don't matter, and
	 *  (2) this object will not influence other objects,
	 *	e.g. in collisions
	 *
	 * In short, this means eye-candy only.
	 */
	for (i = 0; i < delta_ticks; i++)
	    object_do_physics (obj, map);
    }

    for (i = 0; i < delta_ticks; i++) {
	particles_update (map_particles (map), map);
	map_explosions_update (map);
	map_blasts_update_visually_only (map);
    }
}



/*
 *----------------------------------------------------------------------
 *	Poll object update hooks
 *----------------------------------------------------------------------
 */


static void poll_update_hooks (int elapsed_msecs)
{
    list_head_t *object_list;
    object_t *obj;

    if (elapsed_msecs <= 0)
	return;

    object_list = map_object_list (map);
    list_for_each (obj, object_list)
	if (!object_stale (obj))
	    object_poll_update_hook (obj, elapsed_msecs);
}



/*
 *----------------------------------------------------------------------
 *	Send input controls to server
 *----------------------------------------------------------------------
 */


static void send_gameinfo_controls (void)
{
    int controls = 0;
    int update = 0;

    if (!messages_grabbed_keyboard ()) {
	if (key[KEY_A]) controls |= CONTROL_LEFT;
	if (key[KEY_D]) controls |= CONTROL_RIGHT;
	if (key[KEY_W]) controls |= CONTROL_UP;
	if (key[KEY_S]) controls |= CONTROL_DOWN;
	if (key[KEY_SPACE]) controls |= CONTROL_RESPAWN;
    }

    {
	static int last_b;
	int b = mouse_b;

	if (b & 1)
	    controls |= CONTROL_FIRE;

	if ((b & 2) && !(last_b & 2))
	    controls |= CONTROL_DROP_MINE;

	last_b = b;
    }

    if (controls != last_controls)
	update = 1;

    if (last_aim_angle != aim_angle) {
	if (!update)
	    update = ((controls & CONTROL_FIRE)
		      ? (ABS (aim_angle - last_aim_angle) > (M_PI/256))
		      : (ABS (aim_angle - last_aim_angle) > (M_PI/16)));
	if (local_object)
	    object_set_number (local_object, "aim_angle", aim_angle);
    }

    if (update) {
	net_send_rdm_encode (conn, "cccf", MSG_CS_GAMEINFO,
			      MSG_CS_GAMEINFO_CONTROLS, controls, aim_angle);

	last_controls = controls;
	last_aim_angle = aim_angle;
    }
}


/* XXX stuff in the same packet as _CONTROLS? */
/* XXX a bit dirty this function */
static void send_gameinfo_weapon_switch (void)
{
    int keyboard_grabbed;
    int already_set = 0;

    keyboard_grabbed = messages_grabbed_keyboard ();

    /* KEY_1 - KEY_9 */
    {
	static char last_key[9] = {0,0,0,0,0,0,0,0,0};
	int i;

	for (i = 0; i < 9; i++) {
	    int is_down = key[KEY_1 + i];

	    if (!already_set && !keyboard_grabbed &&
		is_down && !last_key[i]) {
		lua_getglobal (Lclt, "weapon_order");
		lua_pushnumber (Lclt, i+1);
		lua_rawget (Lclt, -2);
		if (lua_isstring (Lclt, -1)) {
		    net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
					 MSG_CS_GAMEINFO_WEAPON_SWITCH,
					 lua_tostring (Lclt, -1));
		}
		lua_pop (Lclt, 1);
		already_set = 1;
	    }

	    last_key[i] = is_down;
	}
    }

    /* KEY_Q, KEY_E */
    {
	static int last_Q;
	static int last_E;

	int Q = key[KEY_Q];
	int E = key[KEY_E];

	int prev = !last_Q && Q;
	int next = !last_E && E;

	last_Q = Q;
	last_E = E;

	if (!already_set && !keyboard_grabbed) {
	    if (prev && !next) {
		net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
				     MSG_CS_GAMEINFO_WEAPON_SWITCH,
				     "_internal_prev");
		already_set = 1;
	    }
	    else if (next && !prev) {
		net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
				     MSG_CS_GAMEINFO_WEAPON_SWITCH,
				     "_internal_next");
		already_set = 1;
	    }
	}
    }

    /* mouse wheelie */
    {
	static int last_mouse_z;
	int dir = last_mouse_z - mouse_z;
	last_mouse_z = mouse_z;

	if (!already_set) {
	    if (dir > 0) {
		net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
				     MSG_CS_GAMEINFO_WEAPON_SWITCH,
				     "_internal_prev");
		already_set = 1;
	    }
	    else if (dir < 0) {
		net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
				     MSG_CS_GAMEINFO_WEAPON_SWITCH,
				     "_internal_next");
		already_set = 1;
	    }
	}
    }
}



/*
 *----------------------------------------------------------------------
 *	Process server-to-client gameinfo packets
 *----------------------------------------------------------------------
 */


#define SC_GAMEINFO_HANDLER(NAME)	\
static const uchar_t *NAME (const uchar_t *buf)


SC_GAMEINFO_HANDLER (sc_mapload)
{
    char filename[NETWORK_MAX_PACKET_SIZE];
    short len;

    buf += packet_decode (buf, "s", &len, filename);
    if (map)
	map_destroy (map);
    map = map_load (filename, 1, NULL);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_client_aim_angle)
{
    long id;
    float angle;
    object_t *obj;

    buf += packet_decode (buf, "lf", &id, &angle);
    if ((id != client_id) && (obj = map_find_object (map, id)))
	object_set_number (obj, "aim_angle", angle);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_client_status)
{
    long id;
    char type;
    long val;

    buf += packet_decode (buf, "lcl", &id, &type, &val);
    if (id == client_id) {	/* XXX a waste to broadcast this */
	switch (type) {
	    case 'h':
		display_values.health = val;
		break;
	    case 'A':
		display_values.armour = val;
		break;
	    case 'a':
		display_values.ammo = val;
		break;
	    default:
		error ("unknown type in gameinfo client status packet (client)\n");
		break;
	}
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_client_score)
{
    long id;
    char score[NETWORK_MAX_PACKET_SIZE];
    short len;

    buf += packet_decode (buf, "ls", &id, &len, score);
    client_info_list_set_score (id, score);
    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_create)
{
    int top = lua_gettop (Lclt);

    char type[NETWORK_MAX_PACKET_SIZE];
    short len;
    objid_t id;
    char hidden;
    float x, y;
    float xv, yv;
    objtag_t ctag;
    object_t *obj;
    const char *realtype;

    /* decode the start of the packet */
    buf += packet_decode (buf, "slcffffl", &len, type, &id, &hidden,
			  &x, &y, &xv, &yv, &ctag);

    /* look up the object type alias */
    lua_getglobal (Lclt, "reverse_object_alias");
    lua_pushstring (Lclt, type);
    lua_rawget (Lclt, -2);
    if (lua_isstring (Lclt, -1))
	realtype = lua_tostring (Lclt, -1);
    else
	realtype = type;

    /* create proxy object */
    obj = object_create_proxy (realtype, id);
    if (!obj)
	error ("error: unable to create a proxy object (unknown type?)");
    if (hidden)
	object_hide (obj);
    else
	object_show (obj);
    object_set_auth_info (obj, ticks - lag, x, y, xv, yv, 0, 0);
    object_set_xy (obj, x, y);
    object_set_collision_tag (obj, ctag);
    if (id == client_id) {
	tracked_object = local_object = obj;
	object_set_number (obj, "is_local", 1);
    }

    /* decode optional extra fields */
    {
	char type;
	char name[NETWORK_MAX_PACKET_SIZE];
	short len;

	do {
	    buf += packet_decode (buf, "c", &type);
	    if (type == 'f') {
		float f;
		buf += packet_decode (buf, "sf", &len, name, &f);
		object_set_number (obj, name, f);
	    }
	    else if (type == 's') {
		char s[NETWORK_MAX_PACKET_SIZE];
		short slen;
		buf += packet_decode (buf, "ss", &len, name, &slen, &s);
		object_set_string (obj, name, s);
	    }
	    else if (type) {
		error ("error: unknown field type in object "
		       "creation packet (client)\n");
	    }
	} while (type);
    }

    /* if the object is of a client, set the name */
    if (object_is_client (obj)) {
	client_info_t *c = get_client_info (id);
	if (c)
	    object_set_string (obj, "name", c->name);
    }

    /* link and init */
    map_link_object (map, obj);
    object_run_init_func (obj);

    /* hack to get the camera to track a player's corpse */
    if (object_get_number (obj, "_internal_stalk_me") == client_id)
	tracked_object = obj;

    lua_settop (Lclt, top);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_destroy)
{
    objid_t id;
    object_t *obj;

    buf += packet_decode (buf, "l", &id);
    if ((obj = map_find_object (map, id))) {
	object_set_stale (obj);
	if (obj == local_object)
	    local_object = NULL;
	if (obj == tracked_object)
	    tracked_object = NULL;
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_update)
{
    objid_t id;
    float x, y;
    float xv, yv;
    float xa, ya;
    object_t *obj;

    buf += packet_decode (buf, "lffffff", &id, &x, &y, &xv, &yv, &xa, &ya);
    if ((obj = map_find_object (map, id)))
	object_set_auth_info (obj, ticks - lag, x, y, xv, yv, xa, ya);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_hidden)
{
    objid_t id;
    char hidden;
    object_t *obj;

    buf += packet_decode (buf, "lc", &id, &hidden);
    if ((obj = map_find_object (map, id))) {
	if (hidden)
	    object_hide (obj);
	else
	    object_show (obj);
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_call)
{
    long id;
    short method_len;
    char method[NETWORK_MAX_PACKET_SIZE];
    short arg_len;
    char arg[NETWORK_MAX_PACKET_SIZE];
    object_t *obj;

    buf += packet_decode (buf, "lss", &id, &method_len, method, &arg_len, arg);
    if ((obj = map_find_object (map, id))) {
	lua_pushstring (Lclt, arg);
	object_call (Lclt, obj, method, 1);
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_particles_create)
{
    char type;
    float x;
    float y;
    long nparticles;
    float spread;
    void (*spawner)(particles_t *, float, float, long, float) = NULL;

    buf += packet_decode (buf, "cfflf", &type, &x, &y, &nparticles, &spread);
    switch (type) {
	case 'b': spawner = particles_spawn_blood; break;
	case 's': spawner = particles_spawn_spark; break;
	case 'r': spawner = particles_spawn_respawn_particles; break;
    }

    if (!spawner)
	error ("error: unknown particle type in gameinfo packet (client)\n");
    else
	(*spawner) (map_particles (map), x, y, nparticles, spread);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_blod_create)
{
    float x;
    float y;
    long nparticles;

    buf += packet_decode (buf, "ffl", &x, &y, &nparticles);
    blod_spawn (map, x, y, nparticles);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_explosion_create)
{
    char name[NETWORK_MAX_PACKET_SIZE];
    short len;
    float x;
    float y;

    buf += packet_decode (buf, "sff", &len, name, &x, &y);
    map_explosion_create (map, name, x, y);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_blast_create)
{
    float x;
    float y;
    float rad;
    long damage;

    buf += packet_decode (buf, "fffl", &x, &y, &rad, &damage);
    map_blast_create (map, x, y, rad, damage, OBJID_CLIENT_PROCESSED);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_sound_play)
{
    float x;
    float y;
    char sample_name[NETWORK_MAX_PACKET_SIZE];
    short len;
    SAMPLE *spl;

    buf += packet_decode (buf, "ffs", &x, &y, &len, &sample_name);
    spl = store_get_dat (sample_name);
    if (spl)
	sound_play_once (spl, x, y);
    return buf;
}


static void process_sc_gameinfo_packet (const uchar_t *buf, size_t size)
{
    const void *end = buf + size;

    dbg ("process gameinfo packet");

    while (buf != end) {

	switch (*buf++) {

	    case MSG_SC_GAMEINFO_MAPLOAD:
		buf = sc_mapload (buf);
		break;

	    case MSG_SC_GAMEINFO_CLIENT_AIM_ANGLE:
		buf = sc_client_aim_angle (buf);
		break;

	    case MSG_SC_GAMEINFO_CLIENT_STATUS:
		buf = sc_client_status (buf);
		break;

	    case MSG_SC_GAMEINFO_CLIENT_SCORE:
		buf = sc_client_score (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_CREATE:
		buf = sc_object_create (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_DESTROY:
		buf = sc_object_destroy (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_UPDATE:
		buf = sc_object_update (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_HIDDEN:
		buf = sc_object_hidden (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_CALL:
		buf = sc_object_call (buf);
		break;

	    case MSG_SC_GAMEINFO_PARTICLES_CREATE:
		buf = sc_particles_create (buf);
		break;

	    case MSG_SC_GAMEINFO_BLOD_CREATE:
		buf = sc_blod_create (buf);
		break;

	    case MSG_SC_GAMEINFO_EXPLOSION_CREATE:
		buf = sc_explosion_create (buf);
		break;

	    case MSG_SC_GAMEINFO_BLAST_CREATE:
		buf = sc_blast_create (buf);
		break;

	    case MSG_SC_GAMEINFO_SOUND_PLAY:
		buf = sc_sound_play (buf);
		break;

	    default:
		error ("error: unknown code in gameinfo packet (client)\n");
	}
    }

    dbg ("done process gameinfo packet");
}



/*
 *----------------------------------------------------------------------
 *	Send text message
 *----------------------------------------------------------------------
 */


void client_send_text_message (const char *text)
{
    net_send_rdm_encode (conn, "cs", MSG_CS_TEXT, text);
}



/*
 *----------------------------------------------------------------------
 *	Lua bindings
 *----------------------------------------------------------------------
 */


void client_spawn_explosion (const char *name, float x, float y)
{
    map_explosion_create (map, name, x, y);
}


void client_play_sound (object_t *obj, const char *sample)
{
    SAMPLE *spl = store_get_dat (sample);

    if (spl)
	sound_play_once (spl, object_x (obj), object_y (obj));
}


void client_set_camera (int pushable, int max_dist)
{
    camera_set (cam, pushable, max_dist);
}



/*
 *----------------------------------------------------------------------
 *	Camera stuff
 *----------------------------------------------------------------------
 */


static int update_camera (void)
{
    int oldx, oldy;

    if (backgrounded)
	return 0;

    if (!tracked_object)
	return 0;

    oldx = camera_x (cam);
    oldy = camera_y (cam);

    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y);

    return (oldx != camera_x (cam)) || (oldy != camera_y (cam));
}



/*
 *----------------------------------------------------------------------
 *	Draw stuff to screen
 *----------------------------------------------------------------------
 */


static void draw_status (BITMAP *bmp)
{
    FONT *f = store_get_dat ("/basic/font/ugly");
    int col = makecol24 (0xfb, 0xf8, 0xf8);

    int w = bmp->w/3;
    int y = bmp->h - text_height (f);
    
    text_mode (-1);

    draw_trans_magic_sprite (bmp, health_icon, w-95, y);
    textprintf_right_trans_magic (bmp, f, w-90, y, col, "%d", display_values.health);

    draw_trans_magic_sprite (bmp, armour_icon, w-65, y);
    textprintf_right_trans_magic (bmp, f, w-60, y, col, "%d", display_values.armour);

    draw_trans_magic_sprite (bmp, armour_icon, w-20, y);
    textprintf_right_trans_magic (bmp, f, w-15, y, col, "%d", display_values.ammo);
}


static void draw_scores (BITMAP *bmp)
{
    if (scores_brightness > 0) {
	FONT *f = store_get_dat ("/basic/font/ugly");
	int br = scores_brightness << 4;
	int col = makecol24 (br|0xb, br|0x8, br|0x8);
	int cx = bmp->w/3/2;

	textout_centre_trans_magic (bmp, f, "SCORES", cx, 20, col);

	{
	    client_info_t *c;
	    int th = text_height (f);
	    int y = (20 + th + 10);

	    list_for_each (c, &client_info_list) {
		textprintf_right_trans_magic (bmp, f, cx, y, col, "%s:", c->name);
		if (c->score)
		    textout_trans_magic (bmp, f, c->score, cx + 8, y, col);
		y += (text_height (f) + 5);
	    }
	}
    }
}
    

static void update_screen (void)
{
    if (backgrounded)
	return;

    clear_bitmap (bmp);

    if (bkgd) {
	int x = -(camera_x (cam) / (3*parallax_x));
	int y = -(camera_y (cam) / parallax_y);
	int w = bkgd->w;
	int h = bkgd->h;

	blit (bkgd, bmp, 0, 0, x, y, w, h);
	blit (bkgd, bmp, 0, 0, x, y+h, w, h);
	blit (bkgd, bmp, 0, 0, x+w, y, w, h);
	blit (bkgd, bmp, 0, 0, x+w, y+h, w, h);
    }

    render (bmp, map, cam);

    if (local_object) {
	int x = object_x (local_object) - camera_x (cam);
	int y = object_y (local_object) - camera_y (cam);

	aim_angle = atan2 (mouse_y - y, mouse_x - x);

	pivot_trans_magic_sprite (bmp, store_get_dat ("/basic/player/torch"),
				  x, y, 0, 115/2,
				  fatan2 (mouse_y - y, mouse_x - x));
    }

    if (crosshair) {
	draw_lit_magic_sprite (bmp, crosshair, mouse_x-2, mouse_y-2,
			       makecol24 (0xff, 0xff, 0xff));
    }

    draw_status (bmp);

    messages_render (bmp);

    text_mode (-1);
    textprintf_trans_magic (bmp, font, 0, 0, makecol24 (0x88, 0x88, 0xf8),
			    "%d FPS", fps);

    draw_scores (bmp);

    scare_mouse ();
    blit_magic_bitmap_to_screen (bmp);
    unscare_mouse ();

    frames++;
}



/*
 *----------------------------------------------------------------------
 *	The game client outer loop (XXX too big)
 *----------------------------------------------------------------------
 */


static void temporary_message (char *s, ...)
{
    va_list ap;
    int y = 0;

    va_start (ap, s);

    clear_bitmap (screen);

    do {
	textout (screen, font, s, 0, y, makecol (255, 255, 255));
	y += text_height (font);
    } while ((s = va_arg (ap, char *)));

    va_end (ap);
}


void client_run (int client_server)
{
    dbg ("connecting (state 1)");
    {
	int status;

	temporary_message ("Connecting to server...",
			   "Press Q to cancel", NULL);

	do {
	    if (key[KEY_ESC])
		return;
	    sync_client_lock ();
	    status = net_poll_connect (conn);
	    sync_client_unlock ();
	} while (!status);

	if (status < 1)
	    return;
    }

    dbg ("connecting (stage 2)");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];

	temporary_message ("Having a chat with the server...", NULL);

	while (1) {
	    sync_client_lock ();

	    if (net_receive_rdm (conn, buf, sizeof buf) <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_JOININFO:
		    packet_decode (buf+1, "l", &client_id);
		    net_send_rdm_encode (conn, "ccs", MSG_CS_JOININFO,
					 NETWORK_PROTOCOL_VERSION, client_name);
		    if (client_server)
			server_set_client_to_quit_with (client_id);
		    sync_client_unlock ();
		    goto lobby;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  lobby:

    dbg ("lobby");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];

	/* XXX */
	BITMAP *load_jpg(AL_CONST char *filename, RGB *pal);
	BITMAP *lobby_bmp;

	lobby_bmp = load_jpg ("data/lobby-tmp.jpg", 0);
	if (lobby_bmp) {
	    BITMAP *tmp = get_magic_bitmap_format (lobby_bmp, 0);
	    destroy_bitmap (lobby_bmp);
	    lobby_bmp = tmp;
	    set_magic_bitmap_brightness (lobby_bmp, 0xf, 0xf, 0xf);
	}
	/* end XXX */

	while (1) {
	    sync_client_lock ();

	    if (!messages_grabbed_keyboard ()) {
		if (key[KEY_ESC]) {
		    if (lobby_bmp) destroy_bitmap (lobby_bmp); /* XXX */
		    sync_client_unlock ();
		    goto disconnect;
		}
	    }

	    {
		const char *s = messages_poll_input ();

		if (s) {
		    if (client_server && (s[0] == ','))
			client_server_interface_add_input (s+1);
		    else
			client_send_text_message (s);
		}
	    }

	    if (!lobby_bmp)
		clear_bitmap (bmp);
	    else
		blit (lobby_bmp, bmp, 0, 0, 0, 0, bmp->w, bmp->h);
	    messages_render (bmp);
	    blit_magic_bitmap_to_screen (bmp);

	    if (net_receive_rdm (conn, buf, sizeof buf) <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMESTATEFEED_REQ:
		    if (lobby_bmp) destroy_bitmap (lobby_bmp); /* XXX */
		    sync_client_unlock ();
		    goto receive_game_state;

		case MSG_SC_CLIENT_ADD:
		    process_sc_client_add (buf+1);
		    break;

		case MSG_SC_CLIENT_REMOVE:
		    process_sc_client_remove (buf+1);
		    break;

		case MSG_SC_DISCONNECTED:
		    if (lobby_bmp) destroy_bitmap (lobby_bmp); /* XXX */
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  receive_game_state:

    dbg ("receive game state");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];
	size_t size;

	sync_client_lock ();
	net_send_rdm_byte (conn, MSG_CS_GAMESTATEFEED_ACK);
	sync_client_unlock ();

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_ESC]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    size = net_receive_rdm (conn, buf, sizeof buf);
	    if (size <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMEINFO:
		    process_sc_gameinfo_packet (buf+1, size-1);
		    break;

		case MSG_SC_GAMESTATEFEED_DONE:
		    dbg ("game state feed done");
		    sync_client_unlock ();
		    goto pause;

		case MSG_SC_CLIENT_ADD:
		    process_sc_client_add (buf+1);
		    break;

		case MSG_SC_CLIENT_REMOVE:
		    process_sc_client_remove (buf+1);
		    break;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  pause:

    dbg ("pause");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];
	size_t size;

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_ESC]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    size = net_receive_rdm (conn, buf, sizeof buf);
	    if (size <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMESTATEFEED_REQ:
		    sync_client_unlock ();
		    goto receive_game_state;

		case MSG_SC_CLIENT_ADD:
		    process_sc_client_add (buf+1);
		    break;

		case MSG_SC_CLIENT_REMOVE:
		    process_sc_client_remove (buf+1);
		    break;

		case MSG_SC_GAMEINFO:
		    process_sc_gameinfo_packet (buf+1, size-1);
		    break;

		case MSG_SC_RESUME:
		    sync_client_unlock ();
		    goto game;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  game:

    dbg ("game");
    {
	ulong_t last_ticks, t;

	/* good time to force gc */
	lua_setgcthreshold (Lclt, 0);

	ticks_init ();
	last_ticks = ticks;

	pinging = 0;
	last_ping_time = 0;

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_ESC]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    dbg ("process network input");
	    {
		uchar_t buf[NETWORK_MAX_PACKET_SIZE];
		size_t size;
		int receive_game_state_later = 0;
		int pause_later = 0;
		int lobby_later = 0;
		int end_later = 0;

		while ((size = net_receive_rdm (conn, buf, sizeof buf)) > 0) {
		    switch (buf[0]) {
			case MSG_SC_GAMESTATEFEED_REQ:
			    receive_game_state_later = 1;
			    break;

			case MSG_SC_CLIENT_ADD:
			    process_sc_client_add (buf+1);
			    break;

			case MSG_SC_CLIENT_REMOVE:
			    process_sc_client_remove (buf+1);
			    break;

			case MSG_SC_PAUSE:
			    pause_later = 1;
			    break;

			case MSG_SC_RESUME:
			    pause_later = 0;
			    break;

			case MSG_SC_GAMEINFO:
			    process_sc_gameinfo_packet (buf+1, size-1);
			    break;

			case MSG_SC_LOBBY:
			    lobby_later = 1;
			    break;

			case MSG_SC_TEXT: {
			    char string[NETWORK_MAX_PACKET_SIZE];
			    short len;

			    packet_decode (buf+1, "s", &len, string);
			    messages_add ("%s", string);
			    break;
			}

			case MSG_SC_PONG:
			    pinging = 0;
			    lag = (ticks - last_ping_time) / 2;
			    net_send_rdm_byte (conn, MSG_CS_BOING);
			    break;

			case MSG_SC_DISCONNECTED:
			    end_later = 1;
			    break;
		    }
		}

		if (receive_game_state_later) { sync_client_unlock (); goto receive_game_state; }
		if (pause_later) { sync_client_unlock (); goto pause; }
		if (lobby_later) { sync_client_unlock (); goto lobby; }
		if (end_later) { sync_client_unlock (); goto end; }
	    }

	    t = ticks;
	    if (last_ticks != t) {
		dbg ("send gameinfo");
		send_gameinfo_controls ();
		send_gameinfo_weapon_switch ();

		/* XXX dunno where to put this */
		if (!messages_grabbed_keyboard ()) {
		    int want_scores = key[KEY_TAB];
		    scores_brightness += (want_scores ? 1 : -1);
		    scores_brightness = MID (0, scores_brightness, 15);
		}

		/* Hack: this makes Allegro half-heartedly grab the
		 * mouse inside a window. */
		{int x,y; get_mouse_mickeys (&x, &y);}

		dbg ("do physics");
		perform_simple_physics (t, t - last_ticks);

		dbg ("poll update hooks");
		poll_update_hooks ((t - last_ticks) * MSECS_PER_TICK);

		map_destroy_stale_objects (map);

		{
		    const char *s;

		    if ((s = messages_poll_input ())) {
			if (client_server && (s[0] == ','))
			    client_server_interface_add_input (s+1);
			else
			    client_send_text_message (s);
		    }
		}

		dbg ("update camera");
		{
		    int n = t - last_ticks;
		    while ((n--) && update_camera ());
		}

		dbg ("update screen");
		update_screen ();

		dbg ("update sound reference point");
		if (local_object)
		    sound_update_reference_point (object_x (local_object),
						  object_y (local_object));

		last_ticks = t;
	    }

	    dbg ("handling pinging");
	    if ((!pinging) && (ticks > last_ping_time + (2 * TICKS_PER_SECOND))) {
		pinging = 1;
		last_ping_time = ticks;
		net_send_rdm_byte (conn, MSG_CS_PING);
	    }

	    lua_setgcthreshold (Lclt, 0);

	    sync_client_unlock ();
	}

	ticks_shutdown ();
    }

  disconnect:

    dbg ("disconnect");
    {
	timeout_t timeout;
	uchar_t c;

	sync_client_lock ();
	net_send_rdm_byte (conn, MSG_CS_DISCONNECT_ASK);
	sync_client_unlock ();

	timeout_set (&timeout, 2000);

	while (!timeout_test (&timeout)) {
	    sync_client_lock ();
	    if (net_receive_rdm (conn, &c, 1) > 0)
		if (c == MSG_SC_DISCONNECTED) {
		    dbg ("server confirmed disconnect");
		    sync_client_unlock ();
		    break;
		}
	    sync_client_unlock ();
	}

	goto end;
    }

  end:

    dbg ("end");
}



/*
 *----------------------------------------------------------------------
 *	Initialisation and shutdown
 *----------------------------------------------------------------------
 */


int client_init (const char *name, int net_driver, const char *addr)
{
    if (!(conn = net_openconn (net_driver, NULL)))
	return -1;
    net_connect (conn, addr);

    client_name = ustrdup (name);

    bmp = create_magic_bitmap (screen_width, screen_height);
    cam = camera_create (screen_width, screen_height);

    /* XXX */ {
	PALETTE pal;
	BITMAP *tmp;

	bkgd = load_bitmap ("data/basic/basic-bkgd/fluorescence.jpg", pal);
	if (bkgd) {
	    tmp = get_magic_bitmap_format (bkgd, pal);
	    destroy_bitmap (bkgd);
	    bkgd = tmp;
	}
    }

    crosshair = store_get_dat ("/basic/crosshair/000");

    health_icon = store_get_dat ("/basic/player/status/health");
    armour_icon = store_get_dat ("/basic/player/status/armour");
    ammo_icon = store_get_dat ("/basic/player/status/ammo");
    set_magic_bitmap_brightness_skipping_black (health_icon, 15, 15, 15);
    set_magic_bitmap_brightness_skipping_black (armour_icon, 15, 15, 15);
    set_magic_bitmap_brightness_skipping_black (ammo_icon, 15, 15, 15);

    map = NULL;
    local_object = NULL;
    tracked_object = NULL;

    client_info_list_init ();

    fps_init ();

    display_switch_init ();

    last_controls = 0;

    return 0;
}


void client_shutdown (void)
{
    display_switch_shutdown ();
    fps_shutdown ();
    client_info_list_free ();
    if (map) {
	map_destroy (map);
	map = NULL;
    }
    destroy_bitmap (bkgd);
    camera_destroy (cam);
    destroy_bitmap (bmp);
    free (client_name);
    net_closeconn (conn);
}
@


1.48
log
@Made mines work.
@
text
@d579 1
a579 1
    int ctag;
d584 1
a584 1
    buf += packet_decode (buf, "slcffffc", &len, type, &id, &hidden,
@


1.47
log
@Draw transparent icons along with the health, armour, ammo numbers.
@
text
@d365 12
a376 1
    if (mouse_b & 1) controls |= CONTROL_FIRE;
@


1.46
log
@Initial armour support.
@
text
@d65 3
d959 3
d963 9
a971 9
    textprintf_right_trans_magic (
	bmp, f, bmp->w/3 - 80, bmp->h - text_height (f) - 2, col,
	"%d", display_values.health);
    textprintf_right_trans_magic (
	bmp, f, bmp->w/3 - 40, bmp->h - text_height (f) - 2, col,
	"%d", display_values.armour);
    textprintf_right_trans_magic (
	bmp, f, bmp->w/3 - 2, bmp->h - text_height (f) - 2, col,
	"%d", display_values.ammo);
d1538 7
@


1.45
log
@Added up/down weapon switching (aka. Q/E or mouse wheel weapon
switching).
@
text
@d70 5
a74 2
static int health;		/* for displaying only */
static int ammo;		/* the real values are on server */
d525 4
a528 1
		health = val;
d531 1
a531 1
		ammo = val;
d958 3
d962 1
a962 1
	"%d", health);
d965 1
a965 1
	"%d", ammo);
@


1.44
log
@Small hack to make Allegro grab the mouse inside the window.
@
text
@d384 1
d387 53
a439 15
    static char last_key[10] = {0,0,0,0,0,0,0,0,0,0};
    int cant_set = 0;
    int i;

    if (messages_grabbed_keyboard ())
	cant_set = 1;

    for (i = 0; i < 10; i++) {
	int is_down = key[KEY_1 + i];

	if (!cant_set && is_down && !last_key[i]) {
	    lua_getglobal (Lclt, "weapon_order");
	    lua_pushnumber (Lclt, i+1);
	    lua_rawget (Lclt, -2);
	    if (lua_isstring (Lclt, -1)) {
d442 2
a443 1
				     lua_tostring (Lclt, -1));
a444 2
	    lua_pop (Lclt, 1);
	    cant_set = 1;
d446 7
d454 14
a467 1
	last_key[i] = is_down;
d1077 1
a1077 1
	    if (key[KEY_Q])
d1144 1
a1144 1
		if (key[KEY_Q]) {
d1212 1
a1212 1
	    if (key[KEY_Q]) {
d1260 1
a1260 1
	    if (key[KEY_Q]) {
d1319 1
a1319 1
	    if (key[KEY_Q]) {
@


1.43
log
@Made the scores sheet fade in/out gradually.
@
text
@d1345 4
@


1.42
log
@Added a different spawn_explosion binding, so clients can create their
own explosions.
@
text
@d81 2
a82 2
/* whether the scores should be displayed */
static int want_scores;
d904 19
a922 16
    FONT *f = store_get_dat ("/basic/font/ugly");
    int col = makecol24 (0xfb, 0xf8, 0xf8);
    int cx = bmp->w/3/2;

    textout_centre_trans_magic (bmp, f, "SCORES", cx, 20, col);

    {
	client_info_t *c;
	int th = text_height (f);
	int y = (20 + th + 10);

	list_for_each (c, &client_info_list) {
	    textprintf_right_trans_magic (bmp, f, cx, y, col, "%s:", c->name);
	    if (c->score)
		textout_trans_magic (bmp, f, c->score, cx + 8, y, col);
	    y += (text_height (f) + 5);
d973 1
a973 2
    if (want_scores)
	draw_scores (bmp);
d1339 5
a1343 2
		if (!messages_grabbed_keyboard ())
		    want_scores = key[KEY_TAB];
@


1.41
log
@Separated the one Lua state into two namespaces: server and client, so
that scripts run on the server don't have access to client-only
functions, and vice versa.  This makes things much less murky.
@
text
@d826 1
a826 1
 *	Sound stuff
d831 6
a836 1
/* (lua binding) */
d846 6
a857 7


/* (lua binding) */
void client_set_camera (int pushable, int max_dist)
{
    camera_set (cam, pushable, max_dist);
}
@


1.40
log
@Added blast accreditation.
@
text
@d48 2
d310 1
a310 1
	map_blasts_update (map);
a386 1
    lua_State *L = lua_state;
d397 4
a400 4
	    lua_getglobal (L, "weapon_order");
	    lua_pushnumber (L, i+1);
	    lua_rawget (L, -2);
	    if (lua_isstring (L, -1)) {
d403 1
a403 1
				     lua_tostring (L, -1));
d405 1
a405 1
	    lua_pop (L, 1);
d493 1
a493 2
    lua_State *L = lua_state;
    int top = lua_gettop (L);
d510 5
a514 5
    lua_getglobal (L, "reverse_object_alias");
    lua_pushstring (L, type);
    lua_rawget (L, -2);
    if (lua_isstring (L, -1))
	realtype = lua_tostring (L, -1);
d575 1
a575 1
    lua_settop (L, top);
d644 2
a645 2
	lua_pushstring (lua_state, arg);
	object_call (obj, method, 1);
d712 1
a712 4
    map_blast_create (map, x, y, rad, damage,
		      -1,  /* dummy owner */
		      TRUE /* this blast is for looks only */
		      );
d1244 1
a1244 1
	lua_setgcthreshold (lua_state, 0);
d1379 1
a1379 1
	    lua_setgcthreshold (lua_state, 0);
@


1.39
log
@Added screen stretching (double size) and 2xSaI support.
@
text
@d712 4
a715 1
    map_blast_create (map, x, y, rad, damage, 1);
@


1.38
log
@Lots of intermingled changes for:
- initial game types support
- notifying clients about new and quitting clients
- scoring
- allowing the server to play a sound on clients in a simple way
@
text
@d29 1
d970 1
a970 3
    acquire_screen ();
    blit_magic_format (bmp, screen, SCREEN_W, SCREEN_H);
    release_screen ();
d1103 1
a1103 1
	    blit_magic_format (bmp, screen, SCREEN_W, SCREEN_H);
d1436 2
a1437 2
    bmp = create_magic_bitmap (SCREEN_W, SCREEN_H);
    cam = camera_create (SCREEN_W, SCREEN_H);
@


1.37
log
@Moved trans_textprintf to textout.c.
[plus a lot of whitespace changes, by accident]
@
text
@d10 1
d78 3
d162 108
d438 51
d559 7
a650 14
SC_GAMEINFO_HANDLER (sc_client_aim_angle)
{
    long id;
    float angle;
    object_t *obj;

    buf += packet_decode (buf, "lf", &id, &angle);
    if ((id != client_id) && (obj = map_find_object (map, id)))
	object_set_number (obj, "aim_angle", angle);

    return buf;
}


d717 1
a717 1
SC_GAMEINFO_HANDLER (sc_client_status)
d719 5
a723 18
    long id;
    char type;
    long val;

    buf += packet_decode (buf, "lcl", &id, &type, &val);
    if (id == client_id) {
	switch (type) {
	    case 'h':
		health = val;
		break;
	    case 'a':
		ammo = val;
		break;
	    default:
		error ("unknown type in gameinfo client status packet (client)\n");
		break;
	}
    }
d725 4
d747 12
a778 4
	    case MSG_SC_GAMEINFO_CLIENT_AIM_ANGLE:
		buf = sc_client_aim_angle (buf);
		break;

d795 2
a796 2
	    case MSG_SC_GAMEINFO_CLIENT_STATUS:
		buf = sc_client_status (buf);
d897 23
d964 4
d1117 8
d1170 8
d1213 8
d1276 8
d1333 4
d1380 2
d1458 2
d1474 1
@


1.36
log
@Use shared #definition of M_PI.
@
text
@d32 1
d168 1
a168 1
    
d215 1
a215 1
    
d243 1
a243 1
    
d316 1
a316 1
    
d321 1
a321 1
    
d330 1
a330 1
    
d375 1
a375 1
		    
d470 1
a470 1
		
d525 1
a525 1
		
d539 1
a539 1
    
d553 1
a553 1
    
d566 1
a566 1
    
d591 1
a591 1
    
d643 1
a643 1
		
d679 1
a679 1
    
d709 1
a709 1
    
a726 19
static void trans_textprintf (BITMAP *bmp, FONT *font, int x, int y,
			      int color, const char *fmt, ...)
{
    va_list ap;
    BITMAP *tmp;
    char buf[1024];

    va_start (ap, fmt);
    uvszprintf (buf, sizeof buf, fmt, ap);
    va_end (ap);
    
    tmp = create_magic_bitmap (text_length (font, buf), text_height (font));
    clear_bitmap (tmp);
    textout (tmp, font, buf, 0, 0, color);
    draw_trans_magic_sprite (bmp, tmp, x, y);
    destroy_bitmap (tmp);
}


d730 1
d732 7
a738 2
    textprintf_right (bmp, f, bmp->w - 40, bmp->h - text_height (f) - 2, -1, "%d", health);
    textprintf_right (bmp, f, bmp->w - 2, bmp->h - text_height (f) - 2, -1, "%d", ammo);
d746 1
a746 1
    
d754 1
a754 1
	
d766 1
a766 1
	
d769 3
a771 3
 	pivot_trans_magic_sprite (bmp, store_get_dat ("/basic/player/torch"),
 				  x, y, 0, 115/2,
 				  fatan2 (mouse_y - y, mouse_x - x));
d784 2
a785 2
    trans_textprintf (bmp, font, 0, 0, makecol24 (0x88, 0x88, 0xf8),
		      "%d FPS", fps);
d810 1
a810 1
    
d875 1
a875 1
    
d877 1
a877 1
    
d988 1
a988 1
	
d990 1
a990 1
        
d998 1
a998 1
	    
d1033 1
a1033 1
    
d1089 1
a1089 1
			    
d1112 1
a1112 1
	    
d1154 1
a1154 1
	    
d1167 1
a1167 1
    
d1183 1
a1183 1
	    if (net_receive_rdm (conn, &c, 1) > 0) 
d1214 1
a1214 1
    
@


1.35
log
@Allow strings as creation fields
(and force gc before entering game)
@
text
@d20 1
a32 5


#ifndef M_PI
# define M_PI   3.14159265358979323846
#endif
@


1.34
log
@Updated for new Store
@
text
@a377 1
	float f;
d382 1
d386 6
d1053 3
@


1.33
log
@Crosshair is a store bitmap, don't destroy_bitmap it.
@
text
@d675 1
a675 1
    SAMPLE *spl = store_dat (sample);
d745 1
a745 1
    FONT *f = store_dat ("/basic/font/ugly");
d779 1
a779 1
 	pivot_trans_magic_sprite (bmp, store_dat ("/basic/player/torch"),
d1239 1
a1239 1
    crosshair = store_dat ("/basic/crosshair/000");
@


1.32
log
@Added sound panning/volume based on position of the source relative to
the player (although it doesn't update when the player moves yet).
@
text
@a1262 1
    destroy_bitmap (crosshair);
@


1.31
log
@Added how to abort connection in temp message.
@
text
@d28 1
d678 1
a678 12
	play_sample (spl, 255, 128, 1000, FALSE); /* XXX */
	/*
	  what's really supposed to happen is that we allocate a voice
	  and update the panning/volume with respect to the position
	  between the client object and obj

	  also, we need to be able to let lua code control
	  start/stop/loop of the voices

	  voices are released when they are stopped, or the owner
	  object is destroyed
	*/
d1153 5
@


1.30
log
@Changes for client-server mode (mostly hacks which will need fixing
later :-P)
@
text
@d848 2
a849 1
	temporary_message ("Connecting to server...", NULL);
@


1.29
log
@Added initial (very incomplete) sound support for weapons.
@
text
@d13 1
d27 1
d824 19
a842 1
void client_run (void)
d848 2
d866 2
d881 2
d901 13
d917 17
a933 3
	    if (key[KEY_Q]) {
		sync_client_unlock ();
		goto disconnect;
d936 7
d950 1
d955 1
d1143 10
a1152 1
		messages_poll_input ();
a1225 5
    if (messages_init () < 0) {
	net_closeconn (conn);
	return -1;
    }
    
a1271 1
    messages_shutdown ();
@


1.28
log
@Fixed bugs in send_gameinfo_weapon_switch().
@
text
@d664 29
@


1.27
log
@Added client health and ammo displays.
@
text
@d271 1
a271 1
    static int last_key[10] = {0,0,0,0,0,0,0,0,0,0};
d273 1
d277 1
a277 1
	return;
d280 1
a280 2
	int K = KEY_1 + i;
	int is_down = key[K];
d282 1
a282 2
	if (is_down && !last_key[K]) {
	    last_key[K] = 1;
d292 1
a292 1
	    return;
d295 1
a295 1
	last_key[K] = is_down;
@


1.26
log
@Added blasts.
@
text
@d66 2
d556 25
d635 4
d723 9
d768 2
@


1.25
log
@Use shorts instead of longs to specify lengths of strings in packets.
@
text
@d193 1
d540 14
d602 4
@


1.24
log
@Added support for explosion graphics.
@
text
@d313 1
a313 1
    long len;
d330 1
a330 1
    long len;
d372 1
a372 1
	long len;
d457 1
a457 1
    long method_len;
d459 1
a459 1
    long arg_len;
d528 1
a528 1
    size_t len;
d953 1
a953 1
			    long len;
@


1.23
log
@Added client sending text messages.
@
text
@d190 1
a190 1
    for (i = 0; i < delta_ticks; i++)
d192 2
d525 14
d583 4
@


1.22
log
@Cleaned up the client source (and renamed the file).
@
text
@d231 8
a238 5
    if (key[KEY_A]) controls |= CONTROL_LEFT;
    if (key[KEY_D]) controls |= CONTROL_RIGHT;
    if (key[KEY_W]) controls |= CONTROL_UP;
    if (key[KEY_S]) controls |= CONTROL_DOWN;
    if (key[KEY_SPACE]) controls |= CONTROL_RESPAWN;
d270 3
d575 14
@


1.21
log
@Added particles for respawning ball.
@
text
@d1 1
a1 1
/* gameclt.c
d9 1
a9 1
#include <libnet.h>
d12 1
a14 1
#include "gameclt.h"
d20 1
d75 9
a83 1
/* misc */
d87 33
a119 1
/*----------------------------------------------------------------------*/
d122 1
a122 1
/* keep in sync with gamesrv.c */
d130 1
a130 1
static void ticker ()
d138 1
a138 1
static void ticks_init ()
d147 1
a147 1
static void ticks_shutdown ()
a152 1
/*----------------------------------------------------------------------*/
d154 5
a158 21

static int net_send_rdm_byte (NET_CONN *conn, uchar_t c)
{
    return net_send_rdm (conn, &c, 1);
}


static int net_send_rdm_encode (NET_CONN *conn, const char *fmt, ...)
{
    va_list ap;
    uchar_t buf[NETWORK_MAX_PACKET_SIZE];
    size_t size;

    va_start (ap, fmt);
    size = packet_encode_v (buf, fmt, ap);
    va_end (ap);
    return net_send_rdm (conn, buf, size);
}


/*----------------------------------------------------------------------*/
d195 6
a200 1
/*----------------------------------------------------------------------*/
d218 6
a223 1
/*----------------------------------------------------------------------*/
d226 1
a226 1
static void send_gameinfo_controls ()
d260 2
a261 1
static void send_gameinfo_weapon_switch () /* XXX stuff in the same packet as _CONTROLS? */
d290 225
a514 1
/*----------------------------------------------------------------------*/
d528 1
a528 8
	    {
		char filename[NETWORK_MAX_PACKET_SIZE];
		long len;
		
		buf += packet_decode (buf, "s", &len, filename);
		if (map)
		    map_destroy (map);
		map = map_load (filename, 1, NULL);
a529 1
	    }
d532 1
a532 70
	    {
		lua_State *L = lua_state;
		int top = lua_gettop (L);
		char type[NETWORK_MAX_PACKET_SIZE];
		long len;
		objid_t id;
		char hidden;
		float x, y;
		float xv, yv;
		int ctag;
		object_t *obj;
		const char *realtype;

		/* decode the start of the packet */
		buf += packet_decode (buf, "slcffffc", &len, type, &id, &hidden,
				      &x, &y, &xv, &yv, &ctag);

		/* look up the object type alias */
		lua_getglobal (L, "reverse_object_alias");
		lua_pushstring (L, type);
		lua_rawget (L, -2);
		if (lua_isstring (L, -1))
		    realtype = lua_tostring (L, -1);
		else
		    realtype = type;

		/* create proxy object */
		obj = object_create_proxy (realtype, id);
		if (!obj)
		    error ("error: unable to create a proxy object (unknown type?)");
		if (hidden)
		    object_hide (obj);
		else
		    object_show (obj);
		object_set_auth_info (obj, ticks - lag, x, y, xv, yv, 0, 0);
		object_set_xy (obj, x, y);
		object_set_collision_tag (obj, ctag);
		if (id == client_id) {
		    tracked_object = local_object = obj;
		    object_set_number (obj, "is_local", 1);
		}

		/* decode optional extra fields */
		{
		    char type;
		    char name[NETWORK_MAX_PACKET_SIZE];
		    long len;
		    float f;
		    
		    do {
			buf += packet_decode (buf, "c", &type);
			if (type == 'f') {
			    buf += packet_decode (buf, "sf", &len, name, &f);
			    object_set_number (obj, name, f);
			}
			else if (type) {
			    error ("error: unknown field type in object creation packet (client)\n");
			}
		    } while (type);
		}

		/* link and init */
		map_link_object (map, obj);
		object_run_init_func (obj);

		/* hack to get the camera to track a player's corpse */
		if (object_get_number (obj, "_internal_stalk_me") == client_id)
		    tracked_object = obj;

		lua_settop (L, top);
a533 1
	    }
d536 1
a536 12
	    {
		objid_t id;
		object_t *obj;

		buf += packet_decode (buf, "l", &id);
		if ((obj = map_find_object (map, id))) {
		    object_set_stale (obj);
		    if (obj == local_object)
			local_object = NULL;
		    if (obj == tracked_object)
			tracked_object = NULL;
		}
a537 1
	    }
d540 1
a540 10
	    {
		objid_t id;
		float x, y;
		float xv, yv;
		float xa, ya;
		object_t *obj;

		buf += packet_decode (buf, "lffffff", &id, &x, &y, &xv, &yv, &xa, &ya);
		if ((obj = map_find_object (map, id)))
		    object_set_auth_info (obj, ticks - lag, x, y, xv, yv, xa, ya);
a541 1
	    }
d544 1
a544 12
	    {
		objid_t id;
		char hidden;
		object_t *obj;

		buf += packet_decode (buf, "lc", &id, &hidden);
		if ((obj = map_find_object (map, id))) {
		    if (hidden)
			object_hide (obj);
		    else
			object_show (obj);
		}
a545 1
	    }
d548 1
a548 13
	    {
		long id;
		long method_len;
		char method[NETWORK_MAX_PACKET_SIZE];
		long arg_len;
		char arg[NETWORK_MAX_PACKET_SIZE];
		object_t *obj;
		
		buf += packet_decode (buf, "lss", &id, &method_len, method, &arg_len, arg);
		if ((obj = map_find_object (map, id))) {
		    lua_pushstring (lua_state, arg);
		    object_call (obj, method, 1);
		}
a549 1
	    }
d552 1
a552 8
	    {
		long id;
		float angle;
		object_t *obj;

		buf += packet_decode (buf, "lf", &id, &angle);
		if ((id != client_id) && (obj = map_find_object (map, id)))
		    object_set_number (obj, "aim_angle", angle);
a553 1
	    }
d556 1
a556 21
	    {
		char type;
		float x;
		float y;
		long nparticles;
		float spread;

		buf += packet_decode (buf, "cfflf", &type, &x, &y, &nparticles, &spread);
		switch (type) {
		    case 'b':
			particles_spawn_blood (map_particles (map), x, y, nparticles, spread);
			break;
		    case 's':
			particles_spawn_spark (map_particles (map), x, y, nparticles, spread);
			break;
		    case 'r':
			particles_spawn_respawn_particles (map_particles (map), x, y, nparticles, spread);
			break;
		    default:
			error ("error: unknown particle type in gameinfo packet (client)\n");
		}
a557 1
	    }
d560 1
a560 7
	    {
		float x;
		float y;
		long nparticles;
		
		buf += packet_decode (buf, "ffl", &x, &y, &nparticles);
		blod_spawn (map, x, y, nparticles);
a561 1
	    }
d572 6
a577 1
/*----------------------------------------------------------------------*/
d580 2
a581 1
void game_client_set_camera (int pushable, int max_dist)
d587 27
d633 1
a633 20
static int update_camera ()
{
    int oldx, oldy;

    if (backgrounded)
	return 0;

    if (!tracked_object)
	return 0;
    
    oldx = camera_x (cam);
    oldy = camera_y (cam);

    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y);

    return (oldx != camera_x (cam)) || (oldy != camera_y (cam));
}


static void update_screen ()
a684 1
/*----------------------------------------------------------------------*/
d686 5
a690 5

static void switch_in_callback ()
{
    backgrounded = 0;
}
d693 1
a693 10
static void switch_out_callback ()
{
    backgrounded = 1;
}


/*----------------------------------------------------------------------*/


void game_client_run ()
d1012 6
a1017 1
/*----------------------------------------------------------------------*/
d1020 1
a1020 1
int game_client_init (const char *name, int net_driver, const char *addr)
d1056 1
a1056 3
    set_display_switch_callback (SWITCH_IN, switch_in_callback);
    set_display_switch_callback (SWITCH_OUT, switch_out_callback);
    backgrounded = 0;
d1064 1
a1064 1
void game_client_shutdown ()
d1066 1
a1066 2
    remove_display_switch_callback (switch_out_callback);
    remove_display_switch_callback (switch_in_callback);
@


1.20
log
@Link objects _before_ calling their init hooks.  This is so that
objects created later in the init hook will appear on top, as
expected.
@
text
@d445 3
@


1.19
log
@Added spark particles.
@
text
@d342 2
a343 1
		/* init and link */
a344 1
		map_link_object (map, obj);
@


1.18
log
@Added object type aliases.
@
text
@a10 1
#include "blood.h"
d23 1
d166 2
a167 2
    for (i = 0; i < delta_ticks; i++) 
	blood_particles_update (map_blood_particles (map), map);
d429 1
a429 1
	    case MSG_SC_GAMEINFO_BLOOD_CREATE:
d431 1
d437 11
a447 2
		buf += packet_decode (buf, "fflf", &x, &y, &nparticles, &spread);
		blood_particles_spawn (map_blood_particles (map), x, y, nparticles, spread);
@


1.17
log
@Added weapon switching with keyboard.
@
text
@d125 1
a125 1
    int size;
d258 1
a258 1
static void process_sc_gameinfo_packet (const uchar_t *buf, int size)
d282 2
d292 1
d294 1
d297 12
a308 1
		obj = object_create_proxy (type, id);
d342 1
d346 1
d350 1
d663 1
a663 1
	int size;
d707 1
a707 1
	int size;
d768 1
a768 1
		int size;
@


1.16
log
@Made switching to the sniper rifle increase the max distance the
camera can see.
@
text
@d226 29
d809 1
@


1.15
log
@Added mechanism for server scripts to tell clients to execute object
methods (i.e. remote calls).
@
text
@a53 1
static int cam_allow_push;
d417 6
d455 1
a455 2
    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y,
				    cam_allow_push ? 300 : 96, cam_allow_push);
@


1.14
log
@Added ability to "push" the camera, i.e. for the sniper rifle so you
can see further that your mouse would normally allow on the screen.
This isn't actually enabled when you pick up a sniper rifle, yet.
@
text
@d354 17
@


1.13
log
@Added tracking corpses after death.
@
text
@d54 1
d433 2
a434 1
    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y, 96);
@


1.12
log
@Added blods.
@
text
@d64 1
d275 1
a275 1
		    local_object = obj;
d300 4
d317 2
d426 1
a426 1
    if (!local_object)
d432 1
a432 1
    camera_track_object_with_mouse (cam, local_object, mouse_x, mouse_y, 96);
d861 1
@


1.11
log
@Added DOWN as a possible input.
@
text
@d10 1
d136 1
a136 1
static void perform_simple_physics ()
d140 1
a140 1
    ulong_t t = ticks;
d143 21
a163 2
    list_for_each (obj, object_list)
	object_do_simulation (obj, t);
d165 2
a166 3
    blood_particles_update (map_blood_particles (map), map);
    /* XXX no good because blood particles can only be updated at a
       regular rate */
d370 11
d752 1
a752 1
		perform_simple_physics ();
@


1.10
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@d180 1
@


1.9
log
@Added ``hidden'' attribute to objects.
@
text
@d343 1
a343 1
		long spread;
d345 1
a345 1
		buf += packet_decode (buf, "ffll", &x, &y, &nparticles, &spread);
@


1.8
log
@Centred mouse sprite on mouse_x, mouse_y properly.
@
text
@d235 1
d241 2
a242 1
		buf += packet_decode (buf, "slffffc", &len, type, &id, &x, &y, &xv, &yv, &ctag);
d246 4
d307 16
@


1.7
log
@Receive remote player's aim angles.  Also, update camera at consistent
rate on different machines.
@
text
@d411 1
a411 2
	draw_lit_magic_sprite (bmp, crosshair, mouse_x, 
			       mouse_y, 
@


1.6
log
@On slower machines `ticks' can change while we are using it, so cache
the value and use that fixed value instead.
@
text
@d190 1
a190 1
		      : (ABS (aim_angle - last_aim_angle) > (M_PI/8)));
d304 12
d709 6
a715 1
		update_camera ();
@


1.5
log
@Added player respawning.
@
text
@d608 1
a608 1
	ulong_t last_ticks;
d682 2
a683 1
	    if (last_ticks != ticks) {
d691 1
a691 1
		poll_update_hooks ((ticks - last_ticks) * MSECS_PER_TICK);
d701 1
a701 1
		last_ticks = ticks;
@


1.4
log
@Poll objects' update hooks.  Also limited the update rate
@
text
@d180 1
@


1.3
log
@Initial creation field stuff.
NET_MAX_PACKET_SIZE -> NETWORK_MAX_PACKET_SIZE.
@
text
@d81 1
d154 18
d607 2
d610 1
d681 3
a683 2
	    dbg ("send gameinfo");
	    send_gameinfo_controls ();
d685 2
a686 2
	    dbg ("do physics");
	    perform_simple_physics ();
d688 2
a689 2
	    if (local_object)
		object_call (local_object, "_client_update_hook");
d691 1
a691 1
	    map_destroy_stale_objects (map);
d693 1
a693 1
	    messages_poll_input ();
d695 6
a700 3
	    dbg ("update screen");
	    update_camera ();
	    update_screen ();
@


1.2
log
@Handle the fact that clients may lose their objects
@
text
@d121 1
a121 1
    uchar_t buf[NET_MAX_PACKET_SIZE];
d200 1
a200 1
		char filename[NET_MAX_PACKET_SIZE];
d212 1
a212 1
		char type[NET_MAX_PACKET_SIZE];
d222 2
d231 20
d437 1
a437 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d468 1
a468 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d501 1
a501 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d545 1
a545 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d603 1
a603 1
		uchar_t buf[NET_MAX_PACKET_SIZE];
d633 1
a633 1
			    char string[NET_MAX_PACKET_SIZE];
@


1.1
log
@Initial revision
@
text
@d171 2
a172 1
	object_set_number (local_object, "aim_angle", aim_angle);
@

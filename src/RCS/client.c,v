head	1.25;
access;
symbols;
locks; strict;
comment	@ * @;


1.25
date	2002.01.26.12.14.36;	author tjaden;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.26.11.54.57;	author tjaden;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.24.15.32.32;	author tjaden;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.24.07.18.21;	author tjaden;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.23.14.09.30;	author tjaden;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.06.30.47;	author tjaden;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.23.03.52.43;	author tjaden;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.22.01.48.20;	author tjaden;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.21.15.26.58;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.21.04.15.37;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.21.00.21.29;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.20.13.53.35;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.12.35.17;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.14.31.08;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.13.29.43;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.15.13.28.24;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.16.07.37;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.14.14.28.50;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.13.53.33;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.08.38.05;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.42.19;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.02.22.09;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.13.15.01.43;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.13.09.30.22;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.16.35;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Use shorts instead of longs to specify lengths of strings in packets.
@
text
@/* client.c
 *
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <math.h>
#include <allegro.h>
#include "libnet.h"
#include "blod.h"
#include "camera.h"
#include "client.h"
#include "error.h"
#include "fps.h"
#include "list.h"
#include "magic4x4.h"
#include "map.h"
#include "mapfile.h"
#include "messages.h"
#include "mylibnet.h"
#include "netmsg.h"
#include "object.h"
#include "packet.h"
#include "particle.h"
#include "render.h"
#include "store.h"
#include "sync.h"
#include "timeout.h"


#ifndef M_PI
# define M_PI   3.14159265358979323846
#endif


#if 0
# define dbg(msg)	puts ("[client] " msg)
#else
# define dbg(msg)
#endif


typedef unsigned char uchar_t;
typedef unsigned long ulong_t;


/* our connection */
static NET_CONN *conn;
static int client_id;
static char *client_name;

/* for rendering */
static BITMAP *bmp;
static camera_t *cam;

static BITMAP *bkgd;
static int parallax_x = 2;
static int parallax_y = 2;

static BITMAP *crosshair;

/* the game state */
static map_t *map;
static object_t *local_object;
static object_t *tracked_object;

/* network stuff */
static int pinging;
static ulong_t last_ping_time;
static int lag;
static int last_controls;
static float aim_angle;
static float last_aim_angle;



/*
 *----------------------------------------------------------------------
 *	Display switch callbacks
 *----------------------------------------------------------------------
 */


static int backgrounded;


static void switch_in_callback (void)
{
    backgrounded = 0;
}


static void switch_out_callback (void)
{
    backgrounded = 1;
}


static void display_switch_init (void)
{
    set_display_switch_callback (SWITCH_IN, switch_in_callback);
    set_display_switch_callback (SWITCH_OUT, switch_out_callback);
    backgrounded = 0;
}


static void display_switch_shutdown (void)
{
    remove_display_switch_callback (switch_out_callback);
    remove_display_switch_callback (switch_in_callback);
}



/*
 *----------------------------------------------------------------------
 *	Tick counter
 *----------------------------------------------------------------------
 */


/* keep in sync with server */
#define TICKS_PER_SECOND	(50)
#define MSECS_PER_TICK		(1000 / TICKS_PER_SECOND)


static volatile ulong_t ticks;


static void ticker (void)
{
    ticks++;
}

END_OF_STATIC_FUNCTION (ticker);


static void ticks_init (void)
{
    LOCK_VARIABLE (ticks);
    LOCK_FUNCTION (ticker);
    install_int_ex (ticker, BPS_TO_TIMER (TICKS_PER_SECOND));
    ticks = 0;
}


static void ticks_shutdown (void)
{
    remove_int (ticker);
}



/*
 *----------------------------------------------------------------------
 *	Perform simple physics (simulation)
 *----------------------------------------------------------------------
 */


static void perform_simple_physics (ulong_t curr_ticks, int delta_ticks)
{
    list_head_t *object_list;
    object_t *obj;
    int i;
    
    object_list = map_object_list (map);
    list_for_each (obj, object_list) {
	if (!object_is_client_processed (obj)) {
	    object_do_simulation (obj, curr_ticks);
	    continue;
	}

	/*
	 * For CLIENT PROCESSED objects, we have to do some thinking
	 * about the physics ourselves, as if we were the server.  But
	 * we do not have accurate data to work with, so ONLY use
	 * proxy-only objects when:
	 *
	 *  (1) inaccurate results for this object don't matter, and
	 *  (2) this object will not influence other objects,
	 *	e.g. in collisions
	 *
	 * In short, this means eye-candy only.
	 */
	for (i = 0; i < delta_ticks; i++)
	    object_do_physics (obj, map);
    }

    for (i = 0; i < delta_ticks; i++) {
	particles_update (map_particles (map), map);
	map_explosions_update (map);
    }
}



/*
 *----------------------------------------------------------------------
 *	Poll object update hooks
 *----------------------------------------------------------------------
 */


static void poll_update_hooks (int elapsed_msecs)
{
    list_head_t *object_list;
    object_t *obj;

    if (elapsed_msecs <= 0)
	return;
    
    object_list = map_object_list (map);
    list_for_each (obj, object_list)
	if (!object_stale (obj))
	    object_poll_update_hook (obj, elapsed_msecs);
}



/*
 *----------------------------------------------------------------------
 *	Send input controls to server
 *----------------------------------------------------------------------
 */


static void send_gameinfo_controls (void)
{
    int controls = 0;
    int update = 0;

    if (!messages_grabbed_keyboard ()) {
	if (key[KEY_A]) controls |= CONTROL_LEFT;
	if (key[KEY_D]) controls |= CONTROL_RIGHT;
	if (key[KEY_W]) controls |= CONTROL_UP;
	if (key[KEY_S]) controls |= CONTROL_DOWN;
	if (key[KEY_SPACE]) controls |= CONTROL_RESPAWN;
    }
    
    if (mouse_b & 1) controls |= CONTROL_FIRE;

    if (controls != last_controls)
	update = 1;

    if (last_aim_angle != aim_angle) {
	if (!update)
	    update = ((controls & CONTROL_FIRE)
		      ? (ABS (aim_angle - last_aim_angle) > (M_PI/256))
		      : (ABS (aim_angle - last_aim_angle) > (M_PI/16)));
	if (local_object)
	    object_set_number (local_object, "aim_angle", aim_angle);
    }

    if (update) {
	net_send_rdm_encode (conn, "cccf", MSG_CS_GAMEINFO,
			      MSG_CS_GAMEINFO_CONTROLS, controls, aim_angle);

	last_controls = controls;
	last_aim_angle = aim_angle;
    }
}


/* XXX stuff in the same packet as _CONTROLS? */
static void send_gameinfo_weapon_switch (void)
{
    static int last_key[10] = {0,0,0,0,0,0,0,0,0,0};
    lua_State *L = lua_state;
    int i;

    if (messages_grabbed_keyboard ())
	return;

    for (i = 0; i < 10; i++) {
	int K = KEY_1 + i;
	int is_down = key[K];

	if (is_down && !last_key[K]) {
	    last_key[K] = 1;
	    lua_getglobal (L, "weapon_order");
	    lua_pushnumber (L, i+1);
	    lua_rawget (L, -2);
	    if (lua_isstring (L, -1)) {
		net_send_rdm_encode (conn, "ccs", MSG_CS_GAMEINFO,
				     MSG_CS_GAMEINFO_WEAPON_SWITCH,
				     lua_tostring (L, -1));
	    }
	    lua_pop (L, 1);
	    return;
	}

	last_key[K] = is_down;
    }
}



/*
 *----------------------------------------------------------------------
 *	Process server-to-client gameinfo packets
 *----------------------------------------------------------------------
 */


#define SC_GAMEINFO_HANDLER(NAME)	\
static const uchar_t *NAME (const uchar_t *buf)


SC_GAMEINFO_HANDLER (sc_mapload)
{
    char filename[NETWORK_MAX_PACKET_SIZE];
    short len;
    
    buf += packet_decode (buf, "s", &len, filename);
    if (map)
	map_destroy (map);
    map = map_load (filename, 1, NULL);
    
    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_create)
{
    lua_State *L = lua_state;
    int top = lua_gettop (L);
    
    char type[NETWORK_MAX_PACKET_SIZE];
    short len;
    objid_t id;
    char hidden;
    float x, y;
    float xv, yv;
    int ctag;
    object_t *obj;
    const char *realtype;

    /* decode the start of the packet */
    buf += packet_decode (buf, "slcffffc", &len, type, &id, &hidden,
			  &x, &y, &xv, &yv, &ctag);

    /* look up the object type alias */
    lua_getglobal (L, "reverse_object_alias");
    lua_pushstring (L, type);
    lua_rawget (L, -2);
    if (lua_isstring (L, -1))
	realtype = lua_tostring (L, -1);
    else
	realtype = type;

    /* create proxy object */
    obj = object_create_proxy (realtype, id);
    if (!obj)
	error ("error: unable to create a proxy object (unknown type?)");
    if (hidden)
	object_hide (obj);
    else
	object_show (obj);
    object_set_auth_info (obj, ticks - lag, x, y, xv, yv, 0, 0);
    object_set_xy (obj, x, y);
    object_set_collision_tag (obj, ctag);
    if (id == client_id) {
	tracked_object = local_object = obj;
	object_set_number (obj, "is_local", 1);
    }

    /* decode optional extra fields */
    {
	char type;
	char name[NETWORK_MAX_PACKET_SIZE];
	short len;
	float f;
		    
	do {
	    buf += packet_decode (buf, "c", &type);
	    if (type == 'f') {
		buf += packet_decode (buf, "sf", &len, name, &f);
		object_set_number (obj, name, f);
	    }
	    else if (type) {
		error ("error: unknown field type in object "
		       "creation packet (client)\n");
	    }
	} while (type);
    }

    /* link and init */
    map_link_object (map, obj);
    object_run_init_func (obj);

    /* hack to get the camera to track a player's corpse */
    if (object_get_number (obj, "_internal_stalk_me") == client_id)
	tracked_object = obj;

    lua_settop (L, top);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_destroy)
{
    objid_t id;
    object_t *obj;

    buf += packet_decode (buf, "l", &id);
    if ((obj = map_find_object (map, id))) {
	object_set_stale (obj);
	if (obj == local_object)
	    local_object = NULL;
	if (obj == tracked_object)
	    tracked_object = NULL;
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_update)
{
    objid_t id;
    float x, y;
    float xv, yv;
    float xa, ya;
    object_t *obj;

    buf += packet_decode (buf, "lffffff", &id, &x, &y, &xv, &yv, &xa, &ya);
    if ((obj = map_find_object (map, id)))
	object_set_auth_info (obj, ticks - lag, x, y, xv, yv, xa, ya);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_hidden)
{
    objid_t id;
    char hidden;
    object_t *obj;

    buf += packet_decode (buf, "lc", &id, &hidden);
    if ((obj = map_find_object (map, id))) {
	if (hidden)
	    object_hide (obj);
	else
	    object_show (obj);
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_object_call)
{
    long id;
    short method_len;
    char method[NETWORK_MAX_PACKET_SIZE];
    short arg_len;
    char arg[NETWORK_MAX_PACKET_SIZE];
    object_t *obj;
		
    buf += packet_decode (buf, "lss", &id, &method_len, method, &arg_len, arg);
    if ((obj = map_find_object (map, id))) {
	lua_pushstring (lua_state, arg);
	object_call (obj, method, 1);
    }

    return buf;
}


SC_GAMEINFO_HANDLER (sc_client_aim_angle)
{
    long id;
    float angle;
    object_t *obj;

    buf += packet_decode (buf, "lf", &id, &angle);
    if ((id != client_id) && (obj = map_find_object (map, id)))
	object_set_number (obj, "aim_angle", angle);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_particles_create)
{
    char type;
    float x;
    float y;
    long nparticles;
    float spread;
    void (*spawner)(particles_t *, float, float, long, float) = NULL;

    buf += packet_decode (buf, "cfflf", &type, &x, &y, &nparticles, &spread);
    switch (type) {
	case 'b': spawner = particles_spawn_blood; break;
	case 's': spawner = particles_spawn_spark; break;
	case 'r': spawner = particles_spawn_respawn_particles; break;
    }

    if (!spawner)
	error ("error: unknown particle type in gameinfo packet (client)\n");
    else
	(*spawner) (map_particles (map), x, y, nparticles, spread);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_blod_create)
{
    float x;
    float y;
    long nparticles;
		
    buf += packet_decode (buf, "ffl", &x, &y, &nparticles);
    blod_spawn (map, x, y, nparticles);

    return buf;
}


SC_GAMEINFO_HANDLER (sc_explosion_create)
{
    char name[NETWORK_MAX_PACKET_SIZE];
    short len;
    float x;
    float y;
    
    buf += packet_decode (buf, "sff", &len, name, &x, &y);
    map_explosion_create (map, name, x, y);

    return buf;
}


static void process_sc_gameinfo_packet (const uchar_t *buf, size_t size)
{
    const void *end = buf + size;

    dbg ("process gameinfo packet");
    
    while (buf != end) {

	switch (*buf++) {

	    case MSG_SC_GAMEINFO_MAPLOAD:
		buf = sc_mapload (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_CREATE:
		buf = sc_object_create (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_DESTROY:
		buf = sc_object_destroy (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_UPDATE:
		buf = sc_object_update (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_HIDDEN:
		buf = sc_object_hidden (buf);
		break;

	    case MSG_SC_GAMEINFO_OBJECT_CALL:
		buf = sc_object_call (buf);
		break;

	    case MSG_SC_GAMEINFO_CLIENT_AIM_ANGLE:
		buf = sc_client_aim_angle (buf);
		break;

	    case MSG_SC_GAMEINFO_PARTICLES_CREATE:
		buf = sc_particles_create (buf);
		break;

	    case MSG_SC_GAMEINFO_BLOD_CREATE:
		buf = sc_blod_create (buf);
		break;

	    case MSG_SC_GAMEINFO_EXPLOSION_CREATE:
		buf = sc_explosion_create (buf);
		break;

	    default:
		error ("error: unknown code in gameinfo packet (client)\n");
	}
    }

    dbg ("done process gameinfo packet");
}



/*
 *----------------------------------------------------------------------
 *	Send text message
 *----------------------------------------------------------------------
 */


void client_send_text_message (const char *text)
{
    net_send_rdm_encode (conn, "cs", MSG_CS_TEXT, text);
}



/*
 *----------------------------------------------------------------------
 *	Camera stuff
 *----------------------------------------------------------------------
 */


/* (lua binding) */
void client_set_camera (int pushable, int max_dist)
{
    camera_set (cam, pushable, max_dist);
}


static int update_camera (void)
{
    int oldx, oldy;

    if (backgrounded)
	return 0;

    if (!tracked_object)
	return 0;
    
    oldx = camera_x (cam);
    oldy = camera_y (cam);

    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y);

    return (oldx != camera_x (cam)) || (oldy != camera_y (cam));
}



/*
 *----------------------------------------------------------------------
 *	Draw stuff to screen
 *----------------------------------------------------------------------
 */


static void trans_textprintf (BITMAP *bmp, FONT *font, int x, int y,
			      int color, const char *fmt, ...)
{
    va_list ap;
    BITMAP *tmp;
    char buf[1024];

    va_start (ap, fmt);
    uvszprintf (buf, sizeof buf, fmt, ap);
    va_end (ap);
    
    tmp = create_magic_bitmap (text_length (font, buf), text_height (font));
    clear_bitmap (tmp);
    textout (tmp, font, buf, 0, 0, color);
    draw_trans_magic_sprite (bmp, tmp, x, y);
    destroy_bitmap (tmp);
}


static void update_screen (void)
{
    if (backgrounded)
	return;
    
    clear_bitmap (bmp);

    if (bkgd) {
	int x = -(camera_x (cam) / (3*parallax_x));
	int y = -(camera_y (cam) / parallax_y);
	int w = bkgd->w;
	int h = bkgd->h;
	
	blit (bkgd, bmp, 0, 0, x, y, w, h);
	blit (bkgd, bmp, 0, 0, x, y+h, w, h);
	blit (bkgd, bmp, 0, 0, x+w, y, w, h);
	blit (bkgd, bmp, 0, 0, x+w, y+h, w, h);
    }

    render (bmp, map, cam);

    if (local_object) {
	int x = object_x (local_object) - camera_x (cam);
	int y = object_y (local_object) - camera_y (cam);
	
	aim_angle = atan2 (mouse_y - y, mouse_x - x);

 	pivot_trans_magic_sprite (bmp, store_dat ("/basic/player/torch"),
 				  x, y, 0, 115/2,
 				  fatan2 (mouse_y - y, mouse_x - x));
    }

    if (crosshair) {
	draw_lit_magic_sprite (bmp, crosshair, mouse_x-2, mouse_y-2,
			       makecol24 (0xff, 0xff, 0xff));
    }

    messages_render (bmp);

    text_mode (-1);
    trans_textprintf (bmp, font, 0, 0, makecol24 (0x88, 0x88, 0xf8),
		      "%d FPS", fps);
    scare_mouse ();
    acquire_screen ();
    blit_magic_format (bmp, screen, SCREEN_W, SCREEN_H);
    release_screen ();
    unscare_mouse ();

    frames++;
}



/*
 *----------------------------------------------------------------------
 *	The game client outer loop (XXX too big)
 *----------------------------------------------------------------------
 */


void client_run (void)
{
    dbg ("connecting (state 1)");
    {
	int status;

	do {
	    if (key[KEY_Q])
		return;
	    sync_client_lock ();
	    status = net_poll_connect (conn);
	    sync_client_unlock ();
	} while (!status);

	if (status < 1)
	    return;
    }

    dbg ("connecting (stage 2)");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];

	while (1) {
	    sync_client_lock ();

	    if (net_receive_rdm (conn, buf, sizeof buf) <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_JOININFO:
		    packet_decode (buf+1, "l", &client_id);
		    net_send_rdm_encode (conn, "ccs", MSG_CS_JOININFO,
					 NETWORK_PROTOCOL_VERSION, client_name);
		    sync_client_unlock ();
		    goto lobby;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }
    
  lobby:
    
    dbg ("lobby");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_Q]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    if (net_receive_rdm (conn, buf, sizeof buf) <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMESTATEFEED_REQ:
		    sync_client_unlock ();
		    goto receive_game_state;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  receive_game_state:

    dbg ("receive game state");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];
	size_t size;

	sync_client_lock ();
	net_send_rdm_byte (conn, MSG_CS_GAMESTATEFEED_ACK);
	sync_client_unlock ();

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_Q]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    size = net_receive_rdm (conn, buf, sizeof buf);
	    if (size <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMEINFO:
		    process_sc_gameinfo_packet (buf+1, size-1);
		    break;

		case MSG_SC_GAMESTATEFEED_DONE:
		    dbg ("game state feed done");
		    sync_client_unlock ();
		    goto pause;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }
	
  pause:
        
    dbg ("pause");
    {
	uchar_t buf[NETWORK_MAX_PACKET_SIZE];
	size_t size;

	while (1) {
	    sync_client_lock ();
	    
	    if (key[KEY_Q]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    size = net_receive_rdm (conn, buf, sizeof buf);
	    if (size <= 0) {
		sync_client_unlock ();
		continue;
	    }

	    switch (buf[0]) {
		case MSG_SC_GAMESTATEFEED_REQ:
		    sync_client_unlock ();
		    goto receive_game_state;

		case MSG_SC_GAMEINFO:
		    process_sc_gameinfo_packet (buf+1, size-1);
		    break;

		case MSG_SC_RESUME:
		    sync_client_unlock ();
		    goto game;

		case MSG_SC_DISCONNECTED:
		    sync_client_unlock ();
		    goto end;
	    }

	    sync_client_unlock ();
	}
    }

  game:
    
    dbg ("game");
    {
	ulong_t last_ticks, t;

	ticks_init ();
	last_ticks = ticks;

	pinging = 0;
	last_ping_time = 0;

	while (1) {
	    sync_client_lock ();

	    if (key[KEY_Q]) {
		sync_client_unlock ();
		goto disconnect;
	    }

	    dbg ("process network input");
	    {
		uchar_t buf[NETWORK_MAX_PACKET_SIZE];
		size_t size;
		int receive_game_state_later = 0;
		int pause_later = 0;
		int lobby_later = 0;
		int end_later = 0;

		while ((size = net_receive_rdm (conn, buf, sizeof buf)) > 0) {
		    switch (buf[0]) {
			case MSG_SC_GAMESTATEFEED_REQ:
			    receive_game_state_later = 1;
			    break;

			case MSG_SC_PAUSE:
			    pause_later = 1;
			    break;

			case MSG_SC_RESUME:
			    pause_later = 0;
			    break;

			case MSG_SC_GAMEINFO:
			    process_sc_gameinfo_packet (buf+1, size-1);
			    break;

			case MSG_SC_LOBBY:
			    lobby_later = 1;
			    break;

			case MSG_SC_TEXT: {
			    char string[NETWORK_MAX_PACKET_SIZE];
			    short len;
			    
			    packet_decode (buf+1, "s", &len, string);
			    messages_add ("%s", string);
			    break;
			}

			case MSG_SC_PONG:
			    pinging = 0;
			    lag = (ticks - last_ping_time) / 2;
			    net_send_rdm_byte (conn, MSG_CS_BOING);
			    break;

			case MSG_SC_DISCONNECTED:
			    end_later = 1;
			    break;
		    }
		}

		if (receive_game_state_later) { sync_client_unlock (); goto receive_game_state; }
		if (pause_later) { sync_client_unlock (); goto pause; }
		if (lobby_later) { sync_client_unlock (); goto lobby; }
		if (end_later) { sync_client_unlock (); goto end; }
	    }
	    
	    t = ticks;
	    if (last_ticks != t) {
		dbg ("send gameinfo");
		send_gameinfo_controls ();
		send_gameinfo_weapon_switch ();

		dbg ("do physics");
		perform_simple_physics (t, t - last_ticks);

		dbg ("poll update hooks");
		poll_update_hooks ((t - last_ticks) * MSECS_PER_TICK);

		map_destroy_stale_objects (map);

		messages_poll_input ();

		dbg ("update camera");
		{
		    int n = t - last_ticks;
		    while ((n--) && update_camera ());
		}

		dbg ("update screen");
		update_screen ();

		last_ticks = t;
	    }
	    
	    dbg ("handling pinging");
	    if ((!pinging) && (ticks > last_ping_time + (2 * TICKS_PER_SECOND))) {
		pinging = 1;
		last_ping_time = ticks;
		net_send_rdm_byte (conn, MSG_CS_PING);
	    }

	    sync_client_unlock ();
	}

	ticks_shutdown ();
    }
    
  disconnect:

    dbg ("disconnect");
    {
	timeout_t timeout;
	uchar_t c;

	sync_client_lock ();
	net_send_rdm_byte (conn, MSG_CS_DISCONNECT_ASK);
	sync_client_unlock ();

	timeout_set (&timeout, 2000);

	while (!timeout_test (&timeout)) {
	    sync_client_lock ();
	    if (net_receive_rdm (conn, &c, 1) > 0) 
		if (c == MSG_SC_DISCONNECTED) {
		    dbg ("server confirmed disconnect");
		    sync_client_unlock ();
		    break;
		}
	    sync_client_unlock ();
	}

	goto end;
    }

  end:

    dbg ("end");
}



/*
 *----------------------------------------------------------------------
 *	Initialisation and shutdown
 *----------------------------------------------------------------------
 */


int client_init (const char *name, int net_driver, const char *addr)
{
    if (!(conn = net_openconn (net_driver, NULL)))
	return -1;
    net_connect (conn, addr);
    
    if (messages_init () < 0) {
	net_closeconn (conn);
	return -1;
    }
    
    client_name = ustrdup (name);

    bmp = create_magic_bitmap (SCREEN_W, SCREEN_H);
    cam = camera_create (SCREEN_W, SCREEN_H);

    /* XXX */ {
	PALETTE pal;
	BITMAP *tmp;

	bkgd = load_bitmap ("data/basic/basic-bkgd/fluorescence.jpg", pal);
	if (bkgd) {
	    tmp = get_magic_bitmap_format (bkgd, pal);
	    destroy_bitmap (bkgd);
	    bkgd = tmp;
	}
    }

    crosshair = store_dat ("/basic/crosshair/000");

    map = NULL;
    local_object = NULL;
    tracked_object = NULL;

    fps_init ();

    display_switch_init ();

    last_controls = 0;

    return 0;
}


void client_shutdown (void)
{
    display_switch_shutdown ();
    fps_shutdown ();
    if (map) {
	map_destroy (map);
	map = NULL;
    }
    destroy_bitmap (crosshair);
    destroy_bitmap (bkgd);
    camera_destroy (cam);
    destroy_bitmap (bmp);
    free (client_name);
    messages_shutdown ();
    net_closeconn (conn);
}
@


1.24
log
@Added support for explosion graphics.
@
text
@d313 1
a313 1
    long len;
d330 1
a330 1
    long len;
d372 1
a372 1
	long len;
d457 1
a457 1
    long method_len;
d459 1
a459 1
    long arg_len;
d528 1
a528 1
    size_t len;
d953 1
a953 1
			    long len;
@


1.23
log
@Added client sending text messages.
@
text
@d190 1
a190 1
    for (i = 0; i < delta_ticks; i++)
d192 2
d525 14
d583 4
@


1.22
log
@Cleaned up the client source (and renamed the file).
@
text
@d231 8
a238 5
    if (key[KEY_A]) controls |= CONTROL_LEFT;
    if (key[KEY_D]) controls |= CONTROL_RIGHT;
    if (key[KEY_W]) controls |= CONTROL_UP;
    if (key[KEY_S]) controls |= CONTROL_DOWN;
    if (key[KEY_SPACE]) controls |= CONTROL_RESPAWN;
d270 3
d575 14
@


1.21
log
@Added particles for respawning ball.
@
text
@d1 1
a1 1
/* gameclt.c
d9 1
a9 1
#include <libnet.h>
d12 1
a14 1
#include "gameclt.h"
d20 1
d75 9
a83 1
/* misc */
d87 33
a119 1
/*----------------------------------------------------------------------*/
d122 1
a122 1
/* keep in sync with gamesrv.c */
d130 1
a130 1
static void ticker ()
d138 1
a138 1
static void ticks_init ()
d147 1
a147 1
static void ticks_shutdown ()
a152 1
/*----------------------------------------------------------------------*/
d154 5
a158 21

static int net_send_rdm_byte (NET_CONN *conn, uchar_t c)
{
    return net_send_rdm (conn, &c, 1);
}


static int net_send_rdm_encode (NET_CONN *conn, const char *fmt, ...)
{
    va_list ap;
    uchar_t buf[NETWORK_MAX_PACKET_SIZE];
    size_t size;

    va_start (ap, fmt);
    size = packet_encode_v (buf, fmt, ap);
    va_end (ap);
    return net_send_rdm (conn, buf, size);
}


/*----------------------------------------------------------------------*/
d195 6
a200 1
/*----------------------------------------------------------------------*/
d218 6
a223 1
/*----------------------------------------------------------------------*/
d226 1
a226 1
static void send_gameinfo_controls ()
d260 2
a261 1
static void send_gameinfo_weapon_switch () /* XXX stuff in the same packet as _CONTROLS? */
d290 225
a514 1
/*----------------------------------------------------------------------*/
d528 1
a528 8
	    {
		char filename[NETWORK_MAX_PACKET_SIZE];
		long len;
		
		buf += packet_decode (buf, "s", &len, filename);
		if (map)
		    map_destroy (map);
		map = map_load (filename, 1, NULL);
a529 1
	    }
d532 1
a532 70
	    {
		lua_State *L = lua_state;
		int top = lua_gettop (L);
		char type[NETWORK_MAX_PACKET_SIZE];
		long len;
		objid_t id;
		char hidden;
		float x, y;
		float xv, yv;
		int ctag;
		object_t *obj;
		const char *realtype;

		/* decode the start of the packet */
		buf += packet_decode (buf, "slcffffc", &len, type, &id, &hidden,
				      &x, &y, &xv, &yv, &ctag);

		/* look up the object type alias */
		lua_getglobal (L, "reverse_object_alias");
		lua_pushstring (L, type);
		lua_rawget (L, -2);
		if (lua_isstring (L, -1))
		    realtype = lua_tostring (L, -1);
		else
		    realtype = type;

		/* create proxy object */
		obj = object_create_proxy (realtype, id);
		if (!obj)
		    error ("error: unable to create a proxy object (unknown type?)");
		if (hidden)
		    object_hide (obj);
		else
		    object_show (obj);
		object_set_auth_info (obj, ticks - lag, x, y, xv, yv, 0, 0);
		object_set_xy (obj, x, y);
		object_set_collision_tag (obj, ctag);
		if (id == client_id) {
		    tracked_object = local_object = obj;
		    object_set_number (obj, "is_local", 1);
		}

		/* decode optional extra fields */
		{
		    char type;
		    char name[NETWORK_MAX_PACKET_SIZE];
		    long len;
		    float f;
		    
		    do {
			buf += packet_decode (buf, "c", &type);
			if (type == 'f') {
			    buf += packet_decode (buf, "sf", &len, name, &f);
			    object_set_number (obj, name, f);
			}
			else if (type) {
			    error ("error: unknown field type in object creation packet (client)\n");
			}
		    } while (type);
		}

		/* link and init */
		map_link_object (map, obj);
		object_run_init_func (obj);

		/* hack to get the camera to track a player's corpse */
		if (object_get_number (obj, "_internal_stalk_me") == client_id)
		    tracked_object = obj;

		lua_settop (L, top);
a533 1
	    }
d536 1
a536 12
	    {
		objid_t id;
		object_t *obj;

		buf += packet_decode (buf, "l", &id);
		if ((obj = map_find_object (map, id))) {
		    object_set_stale (obj);
		    if (obj == local_object)
			local_object = NULL;
		    if (obj == tracked_object)
			tracked_object = NULL;
		}
a537 1
	    }
d540 1
a540 10
	    {
		objid_t id;
		float x, y;
		float xv, yv;
		float xa, ya;
		object_t *obj;

		buf += packet_decode (buf, "lffffff", &id, &x, &y, &xv, &yv, &xa, &ya);
		if ((obj = map_find_object (map, id)))
		    object_set_auth_info (obj, ticks - lag, x, y, xv, yv, xa, ya);
a541 1
	    }
d544 1
a544 12
	    {
		objid_t id;
		char hidden;
		object_t *obj;

		buf += packet_decode (buf, "lc", &id, &hidden);
		if ((obj = map_find_object (map, id))) {
		    if (hidden)
			object_hide (obj);
		    else
			object_show (obj);
		}
a545 1
	    }
d548 1
a548 13
	    {
		long id;
		long method_len;
		char method[NETWORK_MAX_PACKET_SIZE];
		long arg_len;
		char arg[NETWORK_MAX_PACKET_SIZE];
		object_t *obj;
		
		buf += packet_decode (buf, "lss", &id, &method_len, method, &arg_len, arg);
		if ((obj = map_find_object (map, id))) {
		    lua_pushstring (lua_state, arg);
		    object_call (obj, method, 1);
		}
a549 1
	    }
d552 1
a552 8
	    {
		long id;
		float angle;
		object_t *obj;

		buf += packet_decode (buf, "lf", &id, &angle);
		if ((id != client_id) && (obj = map_find_object (map, id)))
		    object_set_number (obj, "aim_angle", angle);
a553 1
	    }
d556 1
a556 21
	    {
		char type;
		float x;
		float y;
		long nparticles;
		float spread;

		buf += packet_decode (buf, "cfflf", &type, &x, &y, &nparticles, &spread);
		switch (type) {
		    case 'b':
			particles_spawn_blood (map_particles (map), x, y, nparticles, spread);
			break;
		    case 's':
			particles_spawn_spark (map_particles (map), x, y, nparticles, spread);
			break;
		    case 'r':
			particles_spawn_respawn_particles (map_particles (map), x, y, nparticles, spread);
			break;
		    default:
			error ("error: unknown particle type in gameinfo packet (client)\n");
		}
a557 1
	    }
d560 1
a560 7
	    {
		float x;
		float y;
		long nparticles;
		
		buf += packet_decode (buf, "ffl", &x, &y, &nparticles);
		blod_spawn (map, x, y, nparticles);
a561 1
	    }
d572 6
a577 1
/*----------------------------------------------------------------------*/
d580 2
a581 1
void game_client_set_camera (int pushable, int max_dist)
d587 27
d633 1
a633 20
static int update_camera ()
{
    int oldx, oldy;

    if (backgrounded)
	return 0;

    if (!tracked_object)
	return 0;
    
    oldx = camera_x (cam);
    oldy = camera_y (cam);

    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y);

    return (oldx != camera_x (cam)) || (oldy != camera_y (cam));
}


static void update_screen ()
a684 1
/*----------------------------------------------------------------------*/
d686 5
a690 5

static void switch_in_callback ()
{
    backgrounded = 0;
}
d693 1
a693 10
static void switch_out_callback ()
{
    backgrounded = 1;
}


/*----------------------------------------------------------------------*/


void game_client_run ()
d1012 6
a1017 1
/*----------------------------------------------------------------------*/
d1020 1
a1020 1
int game_client_init (const char *name, int net_driver, const char *addr)
d1056 1
a1056 3
    set_display_switch_callback (SWITCH_IN, switch_in_callback);
    set_display_switch_callback (SWITCH_OUT, switch_out_callback);
    backgrounded = 0;
d1064 1
a1064 1
void game_client_shutdown ()
d1066 1
a1066 2
    remove_display_switch_callback (switch_out_callback);
    remove_display_switch_callback (switch_in_callback);
@


1.20
log
@Link objects _before_ calling their init hooks.  This is so that
objects created later in the init hook will appear on top, as
expected.
@
text
@d445 3
@


1.19
log
@Added spark particles.
@
text
@d342 2
a343 1
		/* init and link */
a344 1
		map_link_object (map, obj);
@


1.18
log
@Added object type aliases.
@
text
@a10 1
#include "blood.h"
d23 1
d166 2
a167 2
    for (i = 0; i < delta_ticks; i++) 
	blood_particles_update (map_blood_particles (map), map);
d429 1
a429 1
	    case MSG_SC_GAMEINFO_BLOOD_CREATE:
d431 1
d437 11
a447 2
		buf += packet_decode (buf, "fflf", &x, &y, &nparticles, &spread);
		blood_particles_spawn (map_blood_particles (map), x, y, nparticles, spread);
@


1.17
log
@Added weapon switching with keyboard.
@
text
@d125 1
a125 1
    int size;
d258 1
a258 1
static void process_sc_gameinfo_packet (const uchar_t *buf, int size)
d282 2
d292 1
d294 1
d297 12
a308 1
		obj = object_create_proxy (type, id);
d342 1
d346 1
d350 1
d663 1
a663 1
	int size;
d707 1
a707 1
	int size;
d768 1
a768 1
		int size;
@


1.16
log
@Made switching to the sniper rifle increase the max distance the
camera can see.
@
text
@d226 29
d809 1
@


1.15
log
@Added mechanism for server scripts to tell clients to execute object
methods (i.e. remote calls).
@
text
@a53 1
static int cam_allow_push;
d417 6
d455 1
a455 2
    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y,
				    cam_allow_push ? 300 : 96, cam_allow_push);
@


1.14
log
@Added ability to "push" the camera, i.e. for the sniper rifle so you
can see further that your mouse would normally allow on the screen.
This isn't actually enabled when you pick up a sniper rifle, yet.
@
text
@d354 17
@


1.13
log
@Added tracking corpses after death.
@
text
@d54 1
d433 2
a434 1
    camera_track_object_with_mouse (cam, tracked_object, mouse_x, mouse_y, 96);
@


1.12
log
@Added blods.
@
text
@d64 1
d275 1
a275 1
		    local_object = obj;
d300 4
d317 2
d426 1
a426 1
    if (!local_object)
d432 1
a432 1
    camera_track_object_with_mouse (cam, local_object, mouse_x, mouse_y, 96);
d861 1
@


1.11
log
@Added DOWN as a possible input.
@
text
@d10 1
d136 1
a136 1
static void perform_simple_physics ()
d140 1
a140 1
    ulong_t t = ticks;
d143 21
a163 2
    list_for_each (obj, object_list)
	object_do_simulation (obj, t);
d165 2
a166 3
    blood_particles_update (map_blood_particles (map), map);
    /* XXX no good because blood particles can only be updated at a
       regular rate */
d370 11
d752 1
a752 1
		perform_simple_physics ();
@


1.10
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@d180 1
@


1.9
log
@Added ``hidden'' attribute to objects.
@
text
@d343 1
a343 1
		long spread;
d345 1
a345 1
		buf += packet_decode (buf, "ffll", &x, &y, &nparticles, &spread);
@


1.8
log
@Centred mouse sprite on mouse_x, mouse_y properly.
@
text
@d235 1
d241 2
a242 1
		buf += packet_decode (buf, "slffffc", &len, type, &id, &x, &y, &xv, &yv, &ctag);
d246 4
d307 16
@


1.7
log
@Receive remote player's aim angles.  Also, update camera at consistent
rate on different machines.
@
text
@d411 1
a411 2
	draw_lit_magic_sprite (bmp, crosshair, mouse_x, 
			       mouse_y, 
@


1.6
log
@On slower machines `ticks' can change while we are using it, so cache
the value and use that fixed value instead.
@
text
@d190 1
a190 1
		      : (ABS (aim_angle - last_aim_angle) > (M_PI/8)));
d304 12
d709 6
a715 1
		update_camera ();
@


1.5
log
@Added player respawning.
@
text
@d608 1
a608 1
	ulong_t last_ticks;
d682 2
a683 1
	    if (last_ticks != ticks) {
d691 1
a691 1
		poll_update_hooks ((ticks - last_ticks) * MSECS_PER_TICK);
d701 1
a701 1
		last_ticks = ticks;
@


1.4
log
@Poll objects' update hooks.  Also limited the update rate
@
text
@d180 1
@


1.3
log
@Initial creation field stuff.
NET_MAX_PACKET_SIZE -> NETWORK_MAX_PACKET_SIZE.
@
text
@d81 1
d154 18
d607 2
d610 1
d681 3
a683 2
	    dbg ("send gameinfo");
	    send_gameinfo_controls ();
d685 2
a686 2
	    dbg ("do physics");
	    perform_simple_physics ();
d688 2
a689 2
	    if (local_object)
		object_call (local_object, "_client_update_hook");
d691 1
a691 1
	    map_destroy_stale_objects (map);
d693 1
a693 1
	    messages_poll_input ();
d695 6
a700 3
	    dbg ("update screen");
	    update_camera ();
	    update_screen ();
@


1.2
log
@Handle the fact that clients may lose their objects
@
text
@d121 1
a121 1
    uchar_t buf[NET_MAX_PACKET_SIZE];
d200 1
a200 1
		char filename[NET_MAX_PACKET_SIZE];
d212 1
a212 1
		char type[NET_MAX_PACKET_SIZE];
d222 2
d231 20
d437 1
a437 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d468 1
a468 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d501 1
a501 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d545 1
a545 1
	uchar_t buf[NET_MAX_PACKET_SIZE];
d603 1
a603 1
		uchar_t buf[NET_MAX_PACKET_SIZE];
d633 1
a633 1
			    char string[NET_MAX_PACKET_SIZE];
@


1.1
log
@Initial revision
@
text
@d171 2
a172 1
	object_set_number (local_object, "aim_angle", aim_angle);
@

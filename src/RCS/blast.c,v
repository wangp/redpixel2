head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2002.07.16.12.30.05;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.16.08.08.57;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.15.11.43.06;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.13.12.59.36;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.12.06.27.38;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.11.12.25.38;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.11.06.18.22;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.11.05.23.35;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.09.14.27.14;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.11.04.27.23;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.28.13.41.22;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.28.13.41.14;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.27.14.05.02;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.13
log
@receive_damage now takes four arguments.  The final two arguments
(new) provide an idea of where the collision occurred, which is where
blood should be spawned, etc.
@
text
@/* blast.c
 * 
 * Peter Wang <tjaden@@users.sourceforge.net>
 */


#include <math.h>
#include <stdlib.h>
#include <allegro.h>
#include "alloc.h"
#include "blast.h"
#include "error.h"
#include "fastsqrt.h"
#include "list.h"
#include "mylua.h"
#include "object.h"


#define Lsrv  server_lua_namespace


/* forward declaractions for helpers */
typedef struct vector vector_t;
static vector_t *create_vector (int nslots);
static void free_vector (vector_t *vec);
static void add_to_vector (vector_t *vec, void *p);
static int in_vector_p (vector_t *vec, void *p);



#define SPREAD_SPEED  4.8


struct blast {
    blast_t *next;
    blast_t *prev;
    float x;
    float y;
    float max_radius;
    int max_damage;
    float r;
    client_id_t owner;
    vector_t *already_hit;
};


/* The client should pass OBJID_CLIENT_PROCESSED as the owner.  */
blast_t *blast_create (float x, float y, float radius, int damage, client_id_t owner)
{
    blast_t *b = alloc (sizeof *b);

    b->x = x;
    b->y = y;
    b->max_radius = radius;
    b->max_damage = damage;
    b->owner = owner;
    if (b->owner != OBJID_CLIENT_PROCESSED)
	b->already_hit = create_vector (10);

    return b;
}


void blast_destroy (blast_t *blast)
{
    if (blast->already_hit)
	free_vector (blast->already_hit);
    free (blast);
}


static inline void do_blast_check (blast_t *blast, list_head_t *object_list)
{
    object_t *obj;
    float dx, dy;
    float manhattan_dist;
    int dmg;

    list_for_each (obj, object_list) {
	if (object_stale (obj) || object_hidden (obj))
	    continue;

	dx = object_x (obj) - blast->x;
	dy = object_y (obj) - blast->y;
	manhattan_dist = (dx * dx) + (dy * dy);
	
	if ((manhattan_dist < blast->r * blast->r) &&
	    (!in_vector_p (blast->already_hit, obj))) {

	    dmg = (blast->max_damage *
		   (1.5 - (fast_fsqrt (manhattan_dist) / blast->max_radius)));
	    dmg = MIN (dmg, blast->max_damage);
	    if (dmg > 0) {
		float angle = atan2 (dy, dx);
		float r = blast->r - SPREAD_SPEED;
		lua_pushnumber (Lsrv, dmg);
		lua_pushnumber (Lsrv, blast->owner);
		lua_pushnumber (Lsrv, blast->x + r * cos (angle));
		lua_pushnumber (Lsrv, blast->y + r * sin (angle));
		object_call (Lsrv, obj, "receive_damage", 4);

		if (object_is_client (obj)) {
		    double angle = atan2 (dy, dx);
		    /* XXX: need different bounce factors for different damage */
		    object_add_extrinsic_xaya (obj, 2.3 * cos (angle), 18 * sin (angle));
		}
	    }

	    add_to_vector (blast->already_hit, obj);
	}
    }
}


/* This is for servers.  Keep in sync with below.  */
int blast_update_with_collisions (blast_t *blast, list_head_t *object_list)
{
    blast->r += SPREAD_SPEED;
    do_blast_check (blast, object_list);
    return (blast->r >= blast->max_radius) ? -1 : 0;
}


/* This is for clients.  Keep in sync with above.  */
int blast_update_visually_only (blast_t *blast)
{
    blast->r += SPREAD_SPEED;
    return (blast->r >= blast->max_radius) ? -1 : 0;
}


void blast_draw (BITMAP *dest, blast_t *blast, int offset_x, int offset_y)
{
    /* XXX this whole function is trash */

    set_add_blender (0, 0, 0, 5);
    drawing_mode (DRAW_MODE_TRANS,0,0,0);

    {
	int br = (int) (7 + 8 * (1. - blast->r/blast->max_radius)) << 4;
	br |= 0xf;

	dest->cl /= 3;
	dest->cr /= 3;
    
	circlefill (dest, blast->x - offset_x, blast->y - offset_y, blast->r,
		   makecol24 (br, br, br));

	circle (dest, blast->x - offset_x, blast->y - offset_y, blast->r,
	       makecol24 (br, br/2, 0));

	dest->cl *= 3;
	dest->cr *= 3;
    }
    
    drawing_mode (DRAW_MODE_SOLID,0,0,0);
}



/*
 *----------------------------------------------------------------------
 *	Helpers
 *----------------------------------------------------------------------
 */


struct vector {
    int num_slots;
    int used_slots;
    void **slots;
};


static vector_t *create_vector (int nslots)
{
    vector_t *vec = alloc (sizeof *vec);
    vec->slots = alloc (nslots * sizeof (void *));
    vec->num_slots = nslots;
    vec->used_slots = 0;
    return vec;
}


static void free_vector (vector_t *vec)
{
    free (vec->slots);
    free (vec);
}


static void add_to_vector (vector_t *vec, void *p)
{
    if (vec->used_slots == vec->num_slots) {
	void *q = realloc (vec->slots, sizeof (void *) * (vec->num_slots + 5));
	if (!q)
	    error ("Out of memory in blast.c\n");
	vec->slots = q;
	vec->num_slots += 5;
    }

    vec->slots[vec->used_slots] = p;
    vec->used_slots++;
}


static int in_vector_p (vector_t *vec, void *p)
{
    int i;
    
    for (i = 0; i < vec->used_slots; i++)
	if (vec->slots[i] == p)
	    return 1;

    return 0;
}
@


1.12
log
@Made blasts push players.
@
text
@d19 3
d94 7
a100 3
		lua_pushnumber (server_lua_namespace, dmg);
		lua_pushnumber (server_lua_namespace, blast->owner);
		object_call (server_lua_namespace, obj, "receive_damage", 2);
@


1.11
log
@Moved id types to their own file and gave client id a type of its own.
@
text
@d94 6
@


1.10
log
@Now you should not be able to accidentally escape a blast by running
towards its centre.  Some minor speed up too, I think.
@
text
@d39 1
a39 1
    int owner;
d45 1
a45 1
blast_t *blast_create (float x, float y, float radius, int damage, int owner)
@


1.9
log
@Made blasts slightly brighter.
@
text
@d73 1
a73 1
    float dist;
a79 3
	if (in_vector_p (blast->already_hit, obj))
	    continue;

d82 1
a82 1
	dist = fast_fsqrt ((dx * dx) + (dy * dy));
d84 5
a88 2
	if ((dist < blast->r) && (dist >= blast->r - SPREAD_SPEED)) {
	    dmg = blast->max_damage * (1.5 - dist/blast->max_radius);
@


1.8
log
@Separated the one Lua state into two namespaces: server and client, so
that scripts run on the server don't have access to client-only
functions, and vice versa.  This makes things much less murky.
@
text
@d123 1
a123 1
    set_add_blender (0xf,0,0,5);
d127 1
a127 1
	int br = (int) (15 * (1. - blast->r/blast->max_radius)) << 4;
@


1.7
log
@Slow blast spreading looks cool, but they are too easy to escape.
So we try faster spreading but larger radii.
@
text
@a39 1
    int visual_only;
d44 2
a45 2
blast_t *blast_create (float x, float y, float radius, int damage,
		       int owner, int visual_only)
d54 1
a54 2
    b->visual_only = visual_only;
    if (!visual_only)
d63 1
a63 1
    if (!blast->visual_only)
d91 3
a93 3
		lua_pushnumber (lua_state, dmg);
		lua_pushnumber (lua_state, blast->owner);
		object_call (obj, "receive_damage", 2);
d102 2
a103 1
int blast_update (blast_t *blast, list_head_t *object_list)
d106 3
a109 2
    if (!blast->visual_only)
	do_blast_check (blast, object_list);
d111 4
@


1.6
log
@Added blast accreditation.
@
text
@d28 1
a28 1
#define SPREAD_SPEED  2.2
@


1.5
log
@Slowed down the blast spreading speed.
@
text
@d39 1
d46 1
a46 1
		       int visual_only)
d54 1
d94 2
a95 1
		object_call (obj, "receive_damage", 1);
@


1.4
log
@No need to set the vtable in this file anymore.
@
text
@d28 1
a28 1
#define SPREAD_SPEED  4
@


1.3
log
@Made it so that objects can only be hit by a single blast once, even
if it moves while the blast is expanding.
@
text
@a9 1
#include <allegro/internal/aintern.h>
a115 2
    dest->vtable->hfill = _linear_hline24;
    dest->vtable->putpixel = _linear_putpixel24;
@


1.2
log
@Changed the blast collision detection so that a distance of zero will
register as a hit.
@
text
@d8 1
d13 1
d20 9
d41 1
d55 2
d64 2
d81 3
d95 2
d140 59
@


1.1
log
@Initial revision
@
text
@a41 1
    b->r = 0;
d69 1
a69 1
	if ((dist <= blast->r) && (dist > blast->r - SPREAD_SPEED)) {
@

head	1.17;
access;
symbols;
locks; strict;
comment	@# @;


1.17
date	2002.07.12.17.30.36;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.12.08.58.59;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.12.08.55.46;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.12.05.20.19;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.11.07.02.51;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.11.06.18.10;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.11.05.24.31;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.11.04.27.47;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.06.12.08.29;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.29.15.04.47;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.27.14.06.48;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.26.12.13.47;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.23.15.01.34;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.22.04.05.10;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.20.06.58.54;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.17.13.31.23;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.13.22;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Players, crates, barrels now highlight for a short time after getting
hurt.
@
text
@-- basic-tilelike.lua

store_load ("basic/basic-tilelike.dat", "/basic/tilelike/")


----------------------------------------------------------------------
--  Crates
----------------------------------------------------------------------

local Crate = function (t)
    return Objtype (t, {
	category = "objtile",

	nonproxy_init = function (self)
	    self.health = t.health

	    function self:receive_damage (amount)
		self.health = self.health - amount
		if self.health <= 0 then
		    spawn_explosion_on_clients ("basic-explo42", self.x, self.y)
		    spawn_sparks_on_clients (self.x, self.y, 30, 3)
		    self:hide ()
		    self:hibernate (t.respawn_secs * 1000)
		else
		    call_method_on_clients (self, "highlight_temporarily")
		end
	    end

	    function self:hibernate (msecs)
		function the_hook (self)
		    local ball = spawn_object ("basic-respawning-ball",
					       self.x, self.y)
		    ball.item = self
		    self:remove_update_hook()
		end
		self:set_update_hook (msecs, the_hook)
	    end

	    self.super_show = self.show
	    function self:show ()
		if _internal_would_collide_with_objects (self) then
		    -- try again later
		    self:hibernate (700)
		else
		    self:super_show ()
		    self:remove_update_hook ()
		end
	    end
	end,

	proxy_init = function (self)
	    -- (called from server in receive damage function)
	    function self:highlight_temporarily ()
		self:set_highlighted (true)
		self:set_update_hook (
		    90,
		    function (self)
			self:set_highlighted (false)
		    end
		)
	    end
	end
    })
end

Crate {
    name = "basic-crate-000",
    icon = "/basic/tilelike/crate-normal000",
    health = 15,
    respawn_secs = 20
}

Crate {
    name = "basic-crate-001",
    icon = "/basic/tilelike/crate-normal001",
    health = 15,
    respawn_secs = 20
}

Crate {
    name = "basic-crate-large-000",
    icon = "/basic/tilelike/crate-large000",
    health = 30,
    respawn_secs = 20
}


----------------------------------------------------------------------
--  Barrels
----------------------------------------------------------------------

local Barrel = function (t)
    return Objtype (t, {
	category = "objtile",

	nonproxy_init = function (self)
	    self.health = t.health

	    function self:receive_damage (amount, killer_id)
		self.health = self.health - amount
		if self.health <= 0 then
		    spawn_explosion_on_clients ("basic-explo42", self.x, self.y)
		    spawn_sparks_on_clients (self.x, self.y, 30, 3)
		    spawn_blast (self.x, self.y, 68, 50, killer_id)

		    if t.chunks then
			for i = 1, random (10) do
			    spawn_object (t.chunks,
					  self.x + random (17) - 8,
					  self.y + random (17) - 8)
			end
		    end

		    self:hide ()
		    self:hibernate (t.respawn_secs * 1000)
		else
		    call_method_on_clients (self, "highlight_temporarily")
		end
	    end

	    function self:hibernate (msecs)
		function the_hook (self)
		    local ball = spawn_object ("basic-respawning-ball",
					       self.x, self.y)
		    ball.item = self
		    self:remove_update_hook()
		end
		self:set_update_hook (msecs, the_hook)
	    end

	    self.super_show = self.show
	    function self:show ()
		if _internal_would_collide_with_objects (self) then
		    -- try again later
		    self:hibernate (700)
		else
		    self:super_show ()
		    self:remove_update_hook ()
		end
	    end
	end,

	proxy_init = function (self)
	    -- (called from server in receive damage function)
	    function self:highlight_temporarily ()
		self:set_highlighted (true)
		self:set_update_hook (
		    90,
		    function (self)
			self:set_highlighted (false)
		    end
		)
	    end
	end
    })
end

local BarrelChunks = function (t)
    return Objtype (t, {
	icon = t.images[1],
	nonproxy_init = function (self)
	    self.mass = 0.001
	    self:set_collision_flags ("t")
	    self:set_update_hook (1000 + random (3000), object_set_stale)
	end,
	proxy_init = function (self)
	    self:replace_layer (0, t.images[random (getn (t.images))], 2, 2)
	end
    })
end

Barrel {
    name = "basic-barrel-red",
    icon = "/basic/tilelike/barrel-red/main",
    health = 30,
    respawn_secs = 20,
    chunks = "basic-barrel-red-chunks"
}

Barrel {
    name = "basic-barrel-grey",
    icon = "/basic/tilelike/barrel-gray/main",
    health = 30,
    respawn_secs = 20,
    chunks = "basic-barrel-gray-chunks"
}

BarrelChunks {
    name = "basic-barrel-red-chunks",
    images = {
	"/basic/tilelike/barrel-red/chunk0",
	"/basic/tilelike/barrel-red/chunk1",
	"/basic/tilelike/barrel-red/chunk2"
    }
}

BarrelChunks {
    name = "basic-barrel-gray-chunks",
    images = {
	"/basic/tilelike/barrel-gray/chunk0",
	"/basic/tilelike/barrel-gray/chunk1",
	"/basic/tilelike/barrel-gray/chunk2"
    }
}


----------------------------------------------------------------------
--  Ladders
----------------------------------------------------------------------

local Ladder = function (t)
    return Objtype (t, {
	category = "basic-ladder",
	nonproxy_init = function (self)
	    object_set_collision_is_ladder (self)
	    self:set_mask (mask_main, t.mask, t.cx, t.cy)
	end
    })
end

Ladder {
    name = "basic-ladder-gray1",
    icon = "/basic/tilelike/ladder-gray1",
    mask = "/basic/tilelike/ladder-gray1-mask",
    cx = 8, cy = 8
}

Ladder {
    name = "basic-ladder-gray3",
    icon = "/basic/tilelike/ladder-gray3",
    mask = "/basic/tilelike/ladder-gray3-mask",
    cx = 8, cy = 24
}

Ladder {
    name = "basic-ladder-gray5",
    icon = "/basic/tilelike/ladder-gray5",
    mask = "/basic/tilelike/ladder-gray5-mask",
    cx = 8, cy = 40
}
@


1.16
log
@tpyo
@
text
@d13 1
d24 2
d49 13
d95 1
d116 2
d140 13
@


1.15
log
@Made barrels and crates have a respawn ball before respawning.
@
text
@d98 1
a98 1
		    self:hiberate (t.respawn_secs * 1000)
@


1.14
log
@Made all spawn-and-forget server functions be named *_on_clients,
e.g. spawn_blod_on_clients.
@
text
@d15 1
d22 22
a43 10
		    function the_hook (self)
			if _internal_would_collide_with_objects (self) then
			    -- try again later
			    self:set_update_hook (700, the_hook)
			else
			    self:show ()
			    self:remove_update_hook ()
			end
		    end
		    self:set_update_hook (t.respawn_secs * 1000, the_hook)
d81 1
d98 22
a119 10
		    function the_hook (self)
			if _internal_would_collide_with_objects (self) then
			    -- try again later
			    self:set_update_hook (700, the_hook)
			else
			    self:show ()
			    self:remove_update_hook ()
			end
		    end
		    self:set_update_hook (t.respawn_secs * 1000, the_hook)
@


1.13
log
@Renamed Lua's "object_destroy" to "object_set_stale", as that's what
it is called in C (I confused myself).
@
text
@d18 2
a19 2
		    spawn_explosion ("basic-explo42", self.x, self.y)
		    spawn_sparks (self.x, self.y, 30, 3)
d71 2
a72 2
		    spawn_explosion ("basic-explo42", self.x, self.y)
		    spawn_sparks (self.x, self.y, 30, 3)
@


1.12
log
@Slow blast spreading looks cool, but they are too easy to escape.
So we try faster spreading but larger radii.
@
text
@d106 1
a106 1
	    self:set_update_hook (1000 + random (3000), object_destroy)
@


1.11
log
@Added blast accreditation.
@
text
@d73 1
a73 1
		    spawn_blast (self.x, self.y, 45, 50, killer_id)
@


1.10
log
@Centre of barrel chunks is closer to 2,2 than 0,0.
@
text
@d68 1
a68 1
	    function self:receive_damage (amount)
d73 1
a73 1
		    spawn_blast (self.x, self.y, 45, 50)
@


1.9
log
@Added barrel chunks (but they still need inertia).
@
text
@d109 1
a109 1
	    self:replace_layer (0, t.images[random (getn (t.images))], 0, 0)
@


1.8
log
@Renamed the "basic-simple42" explosion to "basic-explo42".
@
text
@d74 9
d100 14
d118 2
a119 1
    respawn_secs = 20
d126 20
a145 1
    respawn_secs = 20
@


1.7
log
@Added blasts.
@
text
@d18 1
a18 1
		    spawn_explosion ("basic-simple42", self.x, self.y)
d71 1
a71 1
		    spawn_explosion ("basic-simple42", self.x, self.y)
@


1.6
log
@Made crates spawn explosion and sparks when destroyed.  Also made
barrels shootable.
@
text
@d63 27
a89 1
local Barrel = Crate	-- temporary
@


1.5
log
@Delay respawning of crates if they would collide with another object.
@
text
@a4 4
objtype_register ("objtile", "basic-barrel-red", "/basic/tilelike/barrel-red/main")
objtype_register ("objtile", "basic-barrel-grey", "/basic/tilelike/barrel-gray/main")


d10 19
a28 14
local make_crate_nonproxy_init = function (health, respawn_secs)
    return function (self)
	self.health = health
	function self:receive_damage (amount)
	    self.health = self.health - amount
	    if self.health <= 0 then
		self:hide ()
		function the_hook (self)
		    if _internal_would_collide_with_objects (self) then
			-- try again later
			self:set_update_hook (700, the_hook)
		    else
			self:show ()
			self:remove_update_hook ()
d30 1
a31 1
		self:set_update_hook (respawn_secs * 1000, the_hook)
d34 1
a34 1
    end
d37 1
a37 2
Objtype {
    category = "objtile",
d40 2
a41 1
    nonproxy_init = make_crate_nonproxy_init (15, 20)
d44 1
a44 2
Objtype {
    category = "objtile",
d47 2
a48 1
    nonproxy_init = make_crate_nonproxy_init (15, 20)
d51 1
a51 2
Objtype {
    category = "objtile",
d54 23
a76 1
    nonproxy_init = make_crate_nonproxy_init (30, 20)
@


1.4
log
@Updated for changes to datafiles.
@
text
@d14 1
a14 2
local make_crate_nonproxy_init
function make_crate_nonproxy_init (health, respawn_secs)
d20 11
a30 1
		self:hide_and_respawn_later (respawn_secs * 1000)
@


1.3
log
@Some initial code to make crates destructible.
@
text
@d5 2
a6 2
objtype_register ("objtile", "basic-barrel-red", "/basic/tilelike/barrel000")
objtype_register ("objtile", "basic-barrel-grey", "/basic/tilelike/barrel001")
d53 29
a81 7
Objtype {
    category = "basic-ladder",
    name = "basic-ladder-main",
    icon = "/basic/tilelike/ladder/000",
    nonproxy_init = function (self)
	object_set_collision_is_ladder (self)
    end
@


1.2
log
@Added support for ladders.
@
text
@d7 40
a46 3
objtype_register ("objtile", "basic-crate-000", "/basic/tilelike/crate-normal000")
objtype_register ("objtile", "basic-crate-001", "/basic/tilelike/crate-normal001")
objtype_register ("objtile", "basic-crate-large-000", "/basic/tilelike/crate-large000")
@


1.1
log
@Initial revision
@
text
@d10 14
@

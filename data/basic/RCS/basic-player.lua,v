head	1.57;
access;
symbols;
locks; strict;
comment	@# @;


1.57
date	2002.07.16.13.03.52;	author tjaden;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.16.12.29.42;	author tjaden;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.16.12.02.31;	author tjaden;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.16.00.02.44;	author tjaden;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.15.08.47.12;	author tjaden;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.15.05.54.12;	author tjaden;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.14.08.37.44;	author tjaden;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.14.04.38.03;	author tjaden;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.14.04.26.04;	author tjaden;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.14.01.48.16;	author tjaden;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.14.01.32.17;	author tjaden;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.13.13.03.30;	author tjaden;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.13.06.20.57;	author tjaden;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.13.05.52.12;	author tjaden;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.13.03.52.25;	author tjaden;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.12.17.30.29;	author tjaden;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.12.16.32.38;	author tjaden;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.12.05.20.11;	author tjaden;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.11.07.02.44;	author tjaden;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.10.10.34.24;	author tjaden;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.05.04.09.22;	author tjaden;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.29.14.57.16;	author tjaden;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.28.14.05.52;	author tjaden;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.28.13.33.59;	author tjaden;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.28.13.01.44;	author tjaden;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.27.14.07.20;	author tjaden;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.26.13.03.30;	author tjaden;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.23.14.07.59;	author tjaden;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.23.10.02.03;	author tjaden;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.22.15.47.29;	author tjaden;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.22.13.02.04;	author tjaden;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.22.11.59.14;	author tjaden;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.22.11.15.32;	author tjaden;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.22.10.03.38;	author tjaden;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.22.04.06.44;	author tjaden;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.21.17.36.11;	author tjaden;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.21.16.11.40;	author tjaden;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.21.15.26.01;	author tjaden;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.21.14.19.41;	author tjaden;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.21.07.59.19;	author tjaden;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.21.04.16.00;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.21.00.26.28;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.19.12.35.06;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.19.08.22.51;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.01.37.55;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.16.14.51;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.18.14.32.14;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.17.14.27.52;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.15.13.29.12;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.15.13.26.31;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.15.10.17.01;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.15.06.07.30;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.13.55.02;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.08.41.02;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.14.03.51.57;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.14.02.25.02;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.13.22;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Gave backpack a bottom mask.
@
text
@-- basic-player.lua
--	Player, corpse, backpack stuff.
--	Some weapon and powerup specific stuff too.


store_load ("basic/basic-player.dat", "/basic/player/")


-- holds the various types of corpses
local corpses = {}



----------------------------------------------------------------------
--  Helpers for complicated update hooks
--  (move out of here if other files need it too one day)
----------------------------------------------------------------------

function install_multiple_update_hook_system (obj, speed)
    obj._update_hooks = {}

    -- Add a new hook PROC to be called every NTICS.
    -- These "tics" are NOT the same as game time ticks, but are
    -- related to the update hook's speed.
    -- Returns a new hook structure (don't touch it!)
    function obj:add_update_hook (ntics, enabled, proc)
	local t = {
	    tics = ntics,
	    ntics = ntics,
	    enabled = enabled,
	    proc = proc
	}
	tinsert (self._update_hooks, t)
	return t
    end

    -- Make a registered hook be called every NTICS.  The current
    -- counter is reset.
    function obj:adjust_update_hook_speed (t, ntics)
	t.ntics = ntics
	t.tics = ntics
    end

    -- Enable a previously disabled hook.
    function obj:enable_update_hook (t)
	t.enabled = true
    end

    -- This is the raw update hook that does the work of dispatching
    -- registered hooks.  When a registered hook is called, it may
    -- return `false' to disable itself.
    obj:set_update_hook (
	speed,
	function (self)
	    for i, t in self._update_hooks do
		if i ~= "n" and t.enabled then
		    t.tics = t.tics - 1
		    if t.tics < 1 then
			t.tics = t.ntics
			if t.proc (self) == false then
			    t.enabled = false
			end
		    end
		end
	    end
	end
    )

    -- After this, the set_update_hook method no longer makes sense.
    obj.set_update_hook = nil
end



----------------------------------------------------------------------
--  Players
----------------------------------------------------------------------


local xv_decay, yv_decay = 0.7, 0.45

-- centre of the player sprites (really?)
local cx, cy = 5, 5

local player_update_hook_speed = msecs_per_tick

function secs_to_ticks (secs)
    return (secs * 1000) / player_update_hook_speed
end



------------------------------------------------------------
--  Non-proxy player object
------------------------------------------------------------


local player_nonproxy_init = function (self)

    install_multiple_update_hook_system (self, player_update_hook_speed)


    --------------------------------------------------
    --  Some properties
    --------------------------------------------------

    self.xv_decay = xv_decay
    self.yv_decay = yv_decay
    self.mass = 0.9
    self._internal_ramp = 6
    self.is_player = true


    --------------------------------------------------
    --  Collision stuff
    --------------------------------------------------

    object_set_collision_is_player (self)
    self:set_collision_flags ("tn")
    self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
    self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
    self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
    self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
    self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)


    --------------------------------------------------
    --  Weapon stuff
    --------------------------------------------------

    self.have_weapon = {}

    function self:receive_weapon (name)
	if weapons[name] and not self.have_weapon[name] then
	    self.have_weapon[name] = true

	    -- check the new weapon is auto-switchable
	    if not contains (weapon_auto_switch_order, name) then
		return
	    end

	    -- don't switch if our current weapon is not auto-switchable
	    if not contains (weapon_auto_switch_order, self.current_weapon.name) then
		return
	    end

	    -- if our current weapon is out of ammo, switch
	    -- if the new weapon is better than the current weapon, switch
	    if not self:has_ammo_for (self.current_weapon) or
	       (index_of (weapon_auto_switch_order, name) < 
		index_of (weapon_auto_switch_order, self.current_weapon.name))
	    then
		self:switch_weapon (name)
	    end
	end
    end

    function self:post_weapon_switch_hook ()
	local w = self.current_weapon
	call_method_on_clients (self, "switch_weapon_hook", w.name)
	_internal_tell_ammo (self, self._ammo[w.ammo_type] or 0)
    end

    function self:switch_weapon (name)
	-- handle up/down switching instead of direct switching
	if name == "_internal_next" then
	    self:switch_weapon_up_down_helper (1)
	elseif name == "_internal_prev" then
	    self:switch_weapon_up_down_helper (-1)

	-- otherwise name is really the name of a weapon
	elseif weapons[name] and self.have_weapon[name] then
	    self.current_weapon = weapons[name]
	    self.desired_weapon = weapons[name]
	    self:post_weapon_switch_hook ()
	end
    end

    function self:switch_weapon_up_down_helper (direction)
	local i = index_of (weapon_order, self.current_weapon.name)
	if i then
	    while true do
		i = i + direction
		local name = weapon_order[i]
		if name == nil then
		    break
		end
		if self.have_weapon[name] and self:has_ammo_for (name) then
		    self:switch_weapon (name)
		    break
		end
	    end
	end
    end

    function self:auto_switch_weapon ()
	for _, name in weapon_auto_switch_order do
	    if (weapons[name] and self.have_weapon[name] and
		self:has_ammo_for (name))
	    then
		self.current_weapon = weapons[name]
		self:post_weapon_switch_hook ()
		break
	    end
	end
    end


    --------------------------------------------------
    --  Ammo stuff
    --------------------------------------------------

    self._ammo = {}

    function self:receive_ammo (ammo_type, amount)
	self._ammo[ammo_type] = (self._ammo[ammo_type] or 0) + amount

	if self.desired_weapon ~= self.current_weapon and
	    self:has_ammo_for (self.desired_weapon) and
	    contains (weapon_auto_switch_order, self.desired_weapon.name)
	then
	    self.current_weapon = self.desired_weapon
	    self:post_weapon_switch_hook ()
	elseif ammo_type == self.current_weapon.ammo_type then
	    _internal_tell_ammo (self, self._ammo[ammo_type])
	end
    end

    function self:deduct_ammo (ammo_type, amount)
	local v = max (0, (self._ammo[ammo_type] or 0) - (amount or 1))
	self._ammo[ammo_type] = v
	_internal_tell_ammo (self, v)
    end

    function self:has_ammo_for (weapon)
	local ammo_type
	if type (weapon) == "string" then
	    ammo_type = weapons[weapon].ammo_type
	else
	    ammo_type = weapon.ammo_type
	end
	if ammo_type == nil then
	    return true
	end
	local ammo = self._ammo[ammo_type]
	return ammo ~= nil and ammo > 0
    end


    --------------------------------------------------
    --  Firing stuff
    --------------------------------------------------

    -- fire delay stuff

    self.can_fire = true

    local reenable_firing_hook = self:add_update_hook (
	0,			-- dummy speed
	false,			-- initially disabled
	function (self)
	    self.can_fire = true
	    return false
	end
    )

    function self:set_fire_delay (secs)
	self.can_fire = false
	self:adjust_update_hook_speed (reenable_firing_hook, secs_to_ticks (secs))
	self:enable_update_hook (reenable_firing_hook)
    end

    -- damage factor stuff

    self.damage_factor = 1

    self.revert_damage_factor_hook = self:add_update_hook (
	secs_to_ticks (30),
	false,
	function (self)
	    self.damage_factor = 1
	    return false
	end
    )

    function self:get_bloodlust_hook ()
	self.damage_factor = 2
	self:enable_update_hook (self.revert_damage_factor_hook)
    end

    -- fire hook

    function self:_internal_fire_hook ()
	if self.can_fire == false then
	    return
	elseif not self:has_ammo_for (self.current_weapon) then
	    self:auto_switch_weapon ()
	    return
	end

	-- have ammo, will fire
	local proj = self.current_weapon.fire (self)

	if self.damage_factor ~= 1 then
	    if type (proj) == "table" then
		for _, p in proj do
		    p.damage = p.damage * self.damage_factor
		end
	    else
		proj.damage = proj.damage * self.damage_factor
	    end
	end

	call_method_on_clients (self, "start_firing_anim")
    end


    --------------------------------------------------
    --  Mines stuff
    --------------------------------------------------

    -- don't use the _ammo variable so that mines are not counted in
    -- backpacks
    self.num_mines = 0		

    function self:_internal_drop_mine_hook ()
	if self.num_mines > 0 then
	    self.num_mines = self.num_mines - 1
	    local obj = spawn_object ("basic-mine-dropped", self.x, self.y)
	    obj.owner = self.id
	end
    end

    function self:receive_mines (amount)
	self.num_mines = self.num_mines + 1
    end


    --------------------------------------------------
    --  Health (and armour) stuff
    --------------------------------------------------

    self.health = 100
    _internal_tell_health (self, self.health)

    self.armour = 0
    _internal_tell_armour (self, self.armour)

    function self:receive_damage (damage, attacker, collision_x, collision_y)
	if self.health <= 0 then
	    -- This is to prevent a bug that we only saw once.
	    -- A player managed to die three times at once.
	    return
	end

	spawn_blood_on_clients (collision_x, collision_y, 200, 2)
	if damage/3 >= 1 then
	    spawn_blod_on_clients (self.x, self.y, damage/3)
	end

	local dmg = damage/2	-- armour absorbs half damage
	self.armour = self.armour - dmg
	if self.armour < 0 then
	    dmg = dmg + -self.armour
	    self.armour = 0
	end
	self.health = self.health - dmg

	_internal_tell_health (self, self.health)
	_internal_tell_armour (self, self.armour)

	if self.health <= 0 then

	    -- We're dead

	    -- give the attacker points, or whatever
	    if attacker then
		_internal_player_died_hook (self.id, attacker)
	    end

	    -- spawn a corpse
	    local corpse = spawn_object (corpses[random (getn (corpses))],
					 self.x, self.y)
	    if corpse then
		-- this makes the client track the corpse
		corpse._internal_stalk_me = self.id
		corpse:add_creation_field ("_internal_stalk_me")

		-- drop a backpack after the corpse finishes animation
		local x, y = self.x, self.y	     -- must do this
		local ammo, id = self._ammo, self.id
		corpse.drop_backpack = function ()
		    local backpack = spawn_object ("basic-backpack", x, y)
		    backpack.ammo = ammo
		    backpack.original_owner = id
		end
	    end

	    -- destroy the object
	    self:set_stale ()

	else

	    -- not dead: make some pretty graphics
	    call_method_on_clients (self, "get_hurt_hook")

	end
    end

    function self:receive_health (amount)
	local h = min (100, self.health + amount)
	if h ~= self.health then
	    self.health = h
	    _internal_tell_health (self, self.health)
	    return true
	else
	    return false
	end
    end

    function self:receive_armour (amount)
	local a = min (50, self.armour + amount)
	if a ~= self.armour then
	    self.armour = a
	    _internal_tell_armour (self, self.armour)
	    return true
	else
	    return false
	end
    end


    --------------------------------------------------
    --  Blood trails
    --------------------------------------------------

    self:add_update_hook (
	secs_to_ticks (1),
	true,
	function (self)
	    if self.health <= 20 then
		spawn_blood_on_clients (self.x, self.y, 40, 2)
	    end
	end
    )


    --------------------------------------------------
    --  Dunno stuff
    --------------------------------------------------

    -- initial weapon
    self.have_weapon["basic-blaster"] = true
    self:switch_weapon ("basic-blaster")

    -- create a respawning ball where the player is
    spawn_object ("basic-respawning-ball", self.x, self.y)

end



------------------------------------------------------------
--  Proxy player object
------------------------------------------------------------


local walk_anim = {
    "/basic/player/walk/000",
    "/basic/player/walk/001",
    "/basic/player/walk/002",
    "/basic/player/walk/003",
    "/basic/player/walk/004",
    "/basic/player/walk/005",
    "/basic/player/walk/006",
    "/basic/player/walk/007"
}


local player_proxy_init = function (self)

    install_multiple_update_hook_system (self, player_update_hook_speed)


    --------------------------------------------------
    -- Some properties
    --------------------------------------------------

    self.xv_decay = xv_decay
    self.yv_decay = yv_decay


    --------------------------------------------------
    --  Layers
    --------------------------------------------------

    self:move_layer (0, cx, cy)
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
    self.arm_frame = 1


    --------------------------------------------------
    --  Lighting stuff
    --------------------------------------------------

    self:add_light (self.is_local and "/basic/light/white-64" or "/basic/light/white-32", 0, 0)

    self.current_light_priority = 0

    self.restore_lighting_hook = self:add_update_hook (
	0,			-- dummy
	false,			-- initially off
	function (self)
	    self:replace_light (0, "/basic/light/white-64", 0, 0)
	end
    )

    function self:change_light (light, timeout, priority)
	if self.is_local then
	    if priority >= self.current_light_priority then
		self:replace_light (0, light, 0, 0)
		self.current_light_priority = priority
		self:adjust_update_hook_speed (self.restore_lighting_hook, timeout)
		self:enable_update_hook (self.restore_lighting_hook)
	    end
	end
    end


    --------------------------------------------------
    --  Highlighting stuff
    --------------------------------------------------

    self.restore_unhighlighting_hook = self:add_update_hook (
	10,
	false,			-- initially off
	function (self)
	    self:set_highlighted (false)
	end
    )

    function self:go_highlighted () -- XXX rename
	self:set_highlighted (true)
	self:enable_update_hook (self.restore_unhighlighting_hook)
    end

    
    --------------------------------------------------
    --  Walking and aiming animation hooks
    --------------------------------------------------

    self.walk_frame = 1

    self:add_update_hook (
	2,
	true,

	function (self)

	    -- walking
	    if _internal_object_moving_horizontally (self) then
		self.walk_frame = self.walk_frame + 1
		if self.walk_frame > getn (walk_anim) then
		    self.walk_frame = 1
		end
		self:replace_layer (0, walk_anim[self.walk_frame], cx, cy)
	    end

	    -- aiming
	    if self.last_aim_angle ~= self.aim_angle then
		self.last_aim_angle = self.aim_angle

		local angle = radian_to_bangle (self.aim_angle)
		local hflip = (angle < -63 or angle > 63)
		self:hflip_layer (0, hflip)
		self:hflip_layer (self.arm_layer, hflip)
		self:rotate_layer (self.arm_layer, angle - (hflip and 128 or 0))
	    end

	end
    )


    --------------------------------------------------
    --  Firing animation hook
    --------------------------------------------------

    self.arm_animation_hook = self:add_update_hook (
	0,			-- dummy
	false,			-- initially off
	function (self)
	    -- this situation can arise due to network conditions
	    if not self.current_weapon then return end

	    local anim = self.current_weapon.arm_anim
	    self.arm_frame = self.arm_frame + 1
	    if self.arm_frame > getn (self.current_weapon.arm_anim) then
		self.arm_frame = 1
		self:replace_layer (self.arm_layer, anim[self.arm_frame], anim.cx, anim.cy)
		return false  -- end of animation
	    else
		self:replace_layer (self.arm_layer, anim[self.arm_frame], anim.cx, anim.cy)
	    end
	end
    )    


    --------------------------------------------------
    --  Hooks
    --------------------------------------------------

    -- (called by nonproxy fire hook)
    function self:start_firing_anim ()
	if self.current_weapon then
	    self:adjust_update_hook_speed (self.arm_animation_hook,
					   self.current_weapon.arm_anim.tics or 5)
	    self:enable_update_hook (self.arm_animation_hook)
	    if self.current_weapon.sound then
		play_sound (self, self.current_weapon.sound)
	    end
	end
    end

    -- (called by nonproxy switch_weapon)
    function self:switch_weapon_hook (weapon_name)
	local w = weapons[weapon_name]
	self.current_weapon = w
	self:replace_layer (self.arm_layer, w.arm_anim[1], w.arm_anim.cx, w.arm_anim.cy)
	if self.is_local then
	    _internal_set_camera (false, 96)
	    if w.client_switch_to_hook then
		w.client_switch_to_hook ()
	    end
	end
    end

    -- (called by nonproxy receive damage function)
    function self:get_hurt_hook ()
	if self.is_local then
	    self:change_light ("/basic/light/red-64", 38, 10)
	else
	    self:go_highlighted ()
	end
    end

    -- (called by server when player gets lightamp)
    function self:get_lightamp_hook ()
	if self.is_local then
	    self:change_light ('/basic/powerup/lightamp/light', 3000, 20)
	end
    end
end


Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
    nonproxy_init = player_nonproxy_init,
    proxy_init = player_proxy_init
}



----------------------------------------------------------------------
--  Corpses
----------------------------------------------------------------------

local Corpse = function (t)

    local anim = {}
    for i = 0, t.frames do
	anim[i] = format (t.fmt, i)
    end

    -- Note: both proxy and nonproxy have to update self.frames.

    local nonproxy_update = function (self)
	self.frame = self.frame + 1
	if self.frame > t.frames then
	    self.frame = t.frames
	    if self.drop_backpack then
		-- drop the backpack after a little while
		self:set_update_hook (
		    1000/3,
		    function (self)
			self.drop_backpack ()
			self:remove_update_hook ()
		    end
		)
	    else
		self:remove_update_hook ()
	    end
	end
    end

    local proxy_update = function (self)
	self:replace_layer (0, anim[self.frame], t.cx, t.cy)
	self.frame = self.frame + 1
	if self.frame > t.frames then
	    self.frame = t.frames
	    -- let the light remain for half a second more
	    self:set_update_hook (
		1000/2,
		function (self)
		    self:remove_all_lights ()
		    self:remove_update_hook ()
		end
	    )
	end
    end

    if not t.speed then
	t.speed = 1000/8
    end

    tinsert (corpses, t.name)

    return Objtype (t, {
    
	icon = anim[0],
	
	nonproxy_init = function (self)
	    if t.mask then
		self:set_mask (mask_main, t.mask, t.cx, t.cy)
		self:set_mask (mask_bottom, t.mask, t.cx, t.cy)
	    end
	    self:set_masks_centre (t.cx, t.cy)
	    self:set_collision_flags ("tn")
	    self.mass = 0.005
	    self.frame = 0
	    self:add_creation_field ("frame")
	    self:set_update_hook (t.speed, nonproxy_update)

	    function self:collide_hook (other)
		-- assume we are getting shot, and spew a bit of blood
		spawn_blood_on_clients (self.x, self.y+5, 4, 1.5)
		return false
	    end
	end,
	
	proxy_init = function (self)
	    -- self.frame is given by server
	    self:add_light ("/basic/light/red-32", 0, 0)
	    self:set_update_hook (t.speed, proxy_update)
	    proxy_update (self) -- set the initial layer
	end
    })
end

Corpse {
    name = "basic-player-death-arm",
    alias = "~da",
    fmt = "/basic/player/death-arm/%03d",
    mask = "/basic/player/death-arm/mask",
    frames = 16,
    cx = 26,
    cy = 8
}

Corpse {
    name = "basic-player-death-eye",
    alias = "~de",
    fmt = "/basic/player/death-eye/%03d",
    mask = "/basic/player/death-eye/mask",
    frames = 20,
    cx = 26,
    cy = 9
}

Corpse {
    name = "basic-player-death-fountain",
    alias = "~df",
    fmt = "/basic/player/death-fountain/%03d",
    mask = "/basic/player/death-fountain/mask",
    frames = 30,
    speed = 1000/10,
    cx = 44,
    cy = 16
}

Corpse {
    name = "basic-player-death-leg",
    alias = "~dl",
    fmt = "/basic/player/death-leg/%03d",
    mask = "/basic/player/death-leg/mask",
    frames = 15,
    speed = 1000/7,
    cx = 26,
    cy = 8
}

Corpse {
    name = "basic-player-death-leg2",
    alias = "~dL",
    fmt = "/basic/player/death-leg2/%03d",
    mask = "/basic/player/death-leg2/mask",
    frames = 17,
    speed = 1000/6,
    cx = 21,
    cy = 8
}

Corpse {
    name = "basic-player-death-stomach",
    alias = "~ds",
    fmt = "/basic/player/death-stomach/%03d",
    mask = "/basic/player/death-stomach/mask",
    frames = 16,
    cx = 13,
    cy = 8
}



----------------------------------------------------------------------
--  Backpack
----------------------------------------------------------------------

Objtype {
    name = "basic-backpack",
    icon = "/basic/player/backpack",
    nonproxy_init = function (self)
	self.mass = 0.01
	self:set_collision_flags ("pt")
	self:set_mask (mask_bottom, "/basic/player/backpack-mask", 6, 8)
	function self:collide_hook (player)
	    -- give goodies
	    if self.ammo then
		for type, amount in self.ammo do
		    player:receive_ammo (type, amount/2)
		end
		if player.id == self.original_owner then
		    send_text_message (player.id, "You got your backpack back")
		else
		    send_text_message (player.id, "You stole a backpack")
		end
	    else
		send_text_message (player.id, "internal error in backpack collide_hook")
	    end
	    self:set_stale ()
	end
    end
}
@


1.56
log
@receive_damage now takes four arguments.  The final two arguments
(new) provide an idea of where the collision occurred, which is where
blood should be spawned, etc.
@
text
@d826 1
@


1.55
log
@Made corpses spew blood when shot.
@
text
@d349 1
a349 1
    function self:receive_damage (damage, attacker)
d356 1
a356 1
	spawn_blood_on_clients (self.x + cx, self.y + cy, 200, 2)
@


1.54
log
@Expose TICKS_PER_SECOND and MSECS_PER_TICK to the Lua state.
@
text
@d683 1
a683 1
		-- drop the backpack after a little whil
d729 1
a729 1
	    self:set_collision_flags ("t")
d734 6
@


1.53
log
@Made mines work.
@
text
@d23 2
d85 1
a85 3
local player_update_hook_speed = 1000/50
  -- try not to change this, a lot of things are currently
  -- determined from this and not from "real-time" time
d87 1
a87 1
function secs_to_tics (secs)
d269 1
a269 1
	self:adjust_update_hook_speed (reenable_firing_hook, secs_to_tics (secs))
d278 1
a278 1
	secs_to_tics (30),
d438 1
a438 1
	secs_to_tics (1),
@


1.52
log
@Added bloodlust/damage_factor support.  Introduced multiple hook
system and cleaned up code.  Also changed blaster and AK damages.
@
text
@d111 1
d315 21
@


1.51
log
@(oops)
@
text
@d2 3
d9 1
d13 60
d80 1
a80 1
-- centre of the player sprites
d83 3
d87 2
a88 9
--
-- Non-proxy
--

local index_of = function (t, v)
    for i, x in t do
	if x == v then return i end
    end
    return false
d91 7
d99 8
a106 1
    -- some properties
d112 5
a116 1
    -- collision stuff
d125 5
a129 1
    -- weapon stuff
d159 1
a159 1
	call_method_on_clients (self, "switch_weapon", w.name)
d207 5
a211 1
    -- ammo stuff
a247 3
    -- initial weapon
    self.have_weapon["basic-blaster"] = true
    self:switch_weapon ("basic-blaster")
d249 42
a290 2
    -- firing stuff
    self.fire_delay = 0
d293 15
a307 4
	if self.fire_delay <= 0 then
	    if self:has_ammo_for (self.current_weapon) then
		self.current_weapon.fire (self)
		call_method_on_clients (self, "start_firing_anim")
d309 1
a309 1
		self:auto_switch_weapon ()
d312 2
d316 5
a320 1
    -- health (and armour) stuff
d410 8
a417 4
    -- update hook (fire delay and blood trails)
    self.trail_tics = 0
    self:set_update_hook (
	1000/50,
a418 4
	    if self.fire_delay > 0 then
		self.fire_delay = self.fire_delay - 1
	    end

d420 1
a420 6
		if self.trail_tics > 0 then
		    self.trail_tics = self.trail_tics - 1
		else
		    self.trail_tics = 50
		    spawn_blood_on_clients (self.x + cx, self.y + cx, 40, 2)
		end
d425 9
d436 1
a439 8
--
-- Proxy
--

local walk_anim = {}
for i = 0,7 do
    walk_anim[i] = format ("/basic/player/walk/%03d", i)
end
d441 15
a455 20
local animate_player_proxy_firing = function (self)
    -- this situation can arise due to network conditions
    if not self.current_weapon then
	return
    end
    if self.animate_arm then
	if self.arm_tics > 0 then
	    self.arm_tics = self.arm_tics - 1
	else
	    local anim = self.current_weapon.arm_anim
	    self.arm_tics = anim.tics or 5
	    self.arm_frame = self.arm_frame + 1
	    if self.arm_frame > getn (self.current_weapon.arm_anim) then
		self.arm_frame = 1
		self.animate_arm = false
	    end
	    self:replace_layer (self.arm_layer, anim[self.arm_frame], anim.cx, anim.cy)
	end
    end
end
a456 17
local animate_player_proxy_walking = function (self)
    if not _internal_object_moving_horizontally (self) then
	return
    end
    
    if self.walk_frame_tics > 0 then
	self.walk_frame_tics = self.walk_frame_tics - 1
    else
	self.walk_frame_tics = 2

	self.walk_frame = self.walk_frame + 1
	if self.walk_frame >= getn (walk_anim) then
	    self.walk_frame = 0
	end
	self:replace_layer (0, walk_anim[self.walk_frame], cx, cy)
    end
end
d458 1
a458 7
local animate_player_proxy_lighting = function (self)
    if self.restore_lighting_tics > 0 then
	self.restore_lighting_tics = self.restore_lighting_tics - 1
	if self.restore_lighting_tics == 0 then
	    self:replace_light (0, "/basic/light/white-64", 0, 0)
	end
    end
d460 1
a460 7
    if self.restore_unhighlighting_tics > 0 then
	self.restore_unhighlighting_tics = self.restore_unhighlighting_tics - 1
	if self.restore_unhighlighting_tics == 0 then
	    self:set_highlighted (false)
	end
    end
end
a461 4
local rotate_and_flip_player_proxy_based_on_aim_angle = function (self)
    if self.last_aim_angle == self.aim_angle then
	return
    end
d463 3
a465 8
    self.last_aim_angle = self.aim_angle

    local angle = radian_to_bangle (self.aim_angle)
    local hflip = (angle < -63 or angle > 63)
    self:hflip_layer (0, hflip)
    self:hflip_layer (self.arm_layer, hflip)
    self:rotate_layer (self.arm_layer, angle - (hflip and 128 or 0))
end
a466 2
local player_proxy_init = function (self)
    -- some properties
d470 5
a474 1
    -- layers
d476 7
a483 1
    -- light
d486 1
a486 3
    -- arm stuff
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
    self.arm_frame = 1
d488 5
a492 4
    -- (called by nonproxy fire hook)
    function self:start_firing_anim ()
	if not self.current_weapon then
	    return
d494 10
a503 3
	if not self.animate_arm then
	    self.animate_arm = true
	    self.arm_tics = 0
d505 12
a516 2
	if self.current_weapon.sound then
	    play_sound (self, self.current_weapon.sound)
d518 5
d525 11
a535 5
    -- animation and update hook
    self.walk_frame = 0
    self.walk_frame_tics = 0
    self:set_update_hook (
	1000/50,
d537 21
a557 4
	    animate_player_proxy_firing (self)
	    animate_player_proxy_walking (self)
	    animate_player_proxy_lighting (self)
	    rotate_and_flip_player_proxy_based_on_aim_angle (self)
d561 43
a603 2
    -- switch weapon (called by nonproxy switch_weapon)
    function self:switch_weapon (weapon_name)
a614 16
    -- lighting (and highlighting) stuff
    self.restore_lighting_tics = 0
    self.current_light_priority = 0

    self.restore_unhighlighting_tics = 0

    function self:change_light (light, timeout, priority)
	if self.is_local then
	    if priority >= self.current_light_priority then
		self:replace_light (0, light, 0, 0)
		self.current_light_priority = priority
		self.restore_lighting_tics = timeout
	    end
	end
    end

d620 1
a620 2
	    self:set_highlighted (true)
	    self.restore_unhighlighting_tics = 10
d642 1
d785 1
@


1.50
log
@Try to prevent a bug that we only saw once.
@
text
@d228 2
a229 1
		local ammo, id = self._ammo, self.id -- must do this
d231 1
a231 1
		    local backpack = spawn_object ("basic-backpack", self.x, self.y)
@


1.49
log
@Made backpacks give half ammo of its original owner.
@
text
@d188 6
@


1.48
log
@Increased the amount/duration of blood and blods.
@
text
@d222 1
a222 1
		local x, y = self.x, self.y
d224 3
a226 1
		    spawn_object ("basic-backpack", x, y)
d621 12
@


1.47
log
@Initial armour support.
@
text
@d188 3
a190 3
	spawn_blood_on_clients (self.x + cx, self.y + cy, 100, 2)
	if damage/5 >= 1 then
	    spawn_blod_on_clients (self.x, self.y, damage/5)
@


1.46
log
@Added up/down weapon switching (aka. Q/E or mouse wheel weapon
switching).
@
text
@d180 1
a180 1
    -- health stuff
d184 3
d193 8
a200 1
	self.health = self.health - damage
d202 1
d240 19
a258 2
	self.health = min (100, self.health + amount)
	_internal_tell_health (self, self.health)
@


1.45
log
@Small comment change.
@
text
@d82 8
a89 1
	if weapons[name] and self.have_weapon[name] then
d93 17
@


1.44
log
@Changed slightly how game types work and fixed the scoring after
changes of maps.
@
text
@d198 1
a198 1
	    -- not dead: blink a red light over the hurt player
@


1.43
log
@Fixed lightamp support.
@
text
@d174 2
a175 2
	    if attacker and _internal_game_type.player_died then
		_internal_game_type.player_died (self.id, attacker)
@


1.42
log
@Players, crates, barrels now highlight for a short time after getting
hurt.
@
text
@d287 6
d367 16
a383 1
    self.restore_lighting_tics = 0
d386 1
a386 2
	    self:replace_light (0, "/basic/light/red-64", 0, 0)
	    self.restore_lighting_tics = 38
d389 8
a396 1
	    self.restore_lighting_tics = 10
@


1.41
log
@Fixed a race condition.
@
text
@d199 1
a199 2
	    call_method_on_clients (self, "start_alt_light",
		"return '/basic/light/red-64', 38, 10")
d282 4
a285 4
local animate_player_proxy_alt_lighting = function (self)
    if self.alt_light_tics > 0 then
	self.alt_light_tics = self.alt_light_tics - 1
	if self.alt_light_tics == 0 then
d287 1
a287 1
	    self.alt_light_priority = 0
d301 2
a302 2
    self:hflip_layer (0, hflip and 1 or 0)
    self:hflip_layer (self.arm_layer, hflip and 1 or 0)
a316 12
    self.alt_light_tics = 0
    self.alt_light_priority = 0

    function self:start_alt_light (this_is_dodgy)
	local the_light, timeout, priority = dostring (this_is_dodgy) -- XXX not good for security
	if (priority > self.alt_light_priority) and self.is_local then
	    self:replace_light (0, the_light, 0, 0)
	    self.alt_light_tics = timeout
	    self.alt_light_priority = priority
	end
    end

d343 1
a343 1
	    animate_player_proxy_alt_lighting (self)
d354 1
a354 1
	    _internal_set_camera (0, 96)
d358 12
@


1.40
log
@Made all spawn-and-forget server functions be named *_on_clients,
e.g. spawn_blod_on_clients.
@
text
@d256 1
a256 1
	    if self.arm_frame > self.last_arm_frame then
a341 1
	    self.last_arm_frame = getn (self.current_weapon.arm_anim)
@


1.39
log
@Renamed Lua's "object_destroy" to "object_set_stale", as that's what
it is called in C (I confused myself).
@
text
@d161 1
a161 1
	spawn_blood (self.x + cx, self.y + cy, 100, 2)
d163 1
a163 1
	    spawn_blod (self.x, self.y, damage/5)
d224 1
a224 1
		    spawn_blood (self.x + cx, self.y + cx, 40, 2)
@


1.38
log
@Lots of intermingled changes for:
- initial game types support
- notifying clients about new and quitting clients
- scoring
- allowing the server to play a sound on clients in a simple way
@
text
@d194 1
a194 1
	    self:destroy ()
d542 1
a542 1
	    self:destroy ()
@


1.37
log
@Minor quirk.
@
text
@d160 1
a160 1
    function self:receive_damage (damage)
d165 1
d168 1
d170 9
d192 2
d195 1
d197 2
d201 1
@


1.36
log
@Added initial (very incomplete) sound support for weapons.
@
text
@d319 3
@


1.35
log
@Fixed an oversight.
@
text
@d324 3
@


1.34
log
@Changes for health and ammo displays.
@
text
@d228 4
@


1.33
log
@Changes for health and ammo displays.
@
text
@a58 6
	    -- if we're not holding a weapon currently, use the new one
	    if not self.current_weapon then
		self:switch_weapon (name)
		return
	    end

d108 1
a108 1
	    self:has_ammo_for (self, self.desired_weapon) and
d139 2
a140 1
    self:receive_weapon ("basic-blaster")
d147 2
a148 3
	    local w = self.current_weapon
	    if self.current_weapon and self:has_ammo_for (self.current_weapon) then
		w.fire (self)
d231 1
a231 1
	elseif self.current_weapon then
d315 1
a315 1
	if not self.animate_arm and self.current_weapon then
@


1.32
log
@Don't auto-switch to a new weapon if our current weapon is not an
auto-switchable one.
@
text
@d72 1
a72 1
	    if not self.current_weapon.can_fire (self) or
d81 6
d91 1
a91 1
	    call_method_on_clients (self, "switch_weapon", name)
d98 1
a98 1
		weapons[name].can_fire (self))
d101 1
a101 1
		call_method_on_clients (self, "switch_weapon", name)
a106 2
    self:receive_weapon ("basic-blaster")

d114 1
a114 1
	    self.desired_weapon.can_fire (self) and
d118 3
a120 1
	    call_method_on_clients (self, "switch_weapon", self.current_weapon.name)
d125 3
a127 1
	self._ammo[ammo_type] = max (0, (self._ammo[ammo_type] or 0) - (amount or 1))
d130 12
a141 2
    function self:ammo (ammo_type)
	return self._ammo[ammo_type] or 0
d144 3
d153 1
a153 1
	    if w and w.can_fire (self) then
d164 1
d172 1
d196 1
@


1.31
log
@When picking up a new weapon, don't switch to it unless it is better
than the current weapon, or the current weapon is out of ammo.
@
text
@d53 24
a76 8
	    if contains (weapon_auto_switch_order, name) then
		if ((not self.current_weapon) or
		    (not self.current_weapon.can_fire (self)) or
		    (index_of (weapon_auto_switch_order, name) < 
		     index_of (weapon_auto_switch_order, self.current_weapon.name)))
		then
		    self:switch_weapon (name)
		end
@


1.30
log
@Added auto weapon switching.
@
text
@d24 7
d54 7
a60 1
		self:switch_weapon (name)
@


1.29
log
@Create a new respawn ball when a player is spawned.
@
text
@d43 14
a56 4
    function self:receive_weapon (weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
	    self:switch_weapon (weapon_name)
d60 9
a68 4
    function self:switch_weapon (weapon_name)
	if weapons[weapon_name] and self.have_weapon[weapon_name] then
	    self.current_weapon = weapons[weapon_name]
	    call_method_on_clients (self, "switch_weapon", weapon_name)
d79 8
d99 1
d103 1
a103 1
	    if w and (not w.can_fire or w.can_fire (self)) then
d106 2
d269 1
a269 1
	    self.animate_arm = 1
@


1.28
log
@Made player walking animation code zero-based again to match datafile
item names.
@
text
@d139 3
a331 4
    end

    if t.alias then
	add_alias (t.name, t.alias)
@


1.27
log
@Added rest of death animations and cleaned up the code around that.
@
text
@d148 1
a148 1
    tinsert (walk_anim, format ("/basic/player/walk/%03d", i))
d179 2
a180 2
	if self.walk_frame > getn (walk_anim) then
	    self.walk_frame = 1
d247 1
a247 1
    self.walk_frame = 1
@


1.26
log
@Made lightamp powerup give player a big blue light.
@
text
@d6 3
d91 3
a93 1
	spawn_blod (self.x, self.y, 10)
d96 1
a96 1
	    local corpse = spawn_object ("basic-player-death-fountain",
d287 13
a299 7
local death_fountain_update_hook = function (self)
    self:replace_layer (0,format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
    self.frame = self.frame + 1
    if self.frame > 30 then
	self.frame = 30
	if not self.is_proxy then
	    self:remove_update_hook ()
d301 10
a310 1
		self.drop_backpack ()
d312 9
a320 2
	else
	    -- proxy: let the light remain for half a second more
d330 35
d367 21
a387 1
Objtype {
d389 19
a407 1
    icon = "/basic/player/death-fountain/000",
d409 19
a427 14
    nonproxy_init = function (self)
	self:set_masks_centre (44, 16)
	self:set_collision_flags ("t")
	self.mass = 0.005
	self.frame = 0
	self:add_creation_field ("frame")
	self:set_update_hook (1000/10, death_fountain_update_hook)
    end,

    proxy_init = function (self)
	self:add_light ("/basic/light/red-32", 0, 0)
	self:set_update_hook (1000/10, death_fountain_update_hook)
	death_fountain_update_hook (self) -- set the initial layer
    end
@


1.25
log
@Made local player's light turn red if gotten shot, and made corpses
use the red light.
@
text
@d106 2
a107 1
	    call_method_on_clients (self, "start_hurt_light")
d146 1
a146 2
local animate_player_proxy = function (self)
    -- firing
d161 1
d163 1
a163 9
    -- hurt light
    if self.hurt_light_tics > 0 then
	self.hurt_light_tics = self.hurt_light_tics - 1
	if self.hurt_light_tics == 0 then
	    self:reset_default_light ()
	end
    end

    -- walking
d181 10
d216 2
a217 1
    self.hurt_light_tics = 0
d219 6
a224 5
    -- (called by nonproxy receive_damage)
    function self:start_hurt_light ()
	if self.is_local then
	    self:replace_light (0, "/basic/light/red-64", 0, 0)
	    self.hurt_light_tics = 38
a227 5
    -- (called by update hook)
    function self:reset_default_light ()
	self:replace_light (0, "/basic/light/white-64", 0, 0)
    end

d247 3
a249 1
	    animate_player_proxy (self)
@


1.24
log
@Some small fixes.
@
text
@d105 2
d162 8
d213 15
d317 1
a317 1
	self:add_light ("/basic/light/white-32", 0, 0)
@


1.23
log
@Added start of backpacks.  Also minor clean up for walking anim.
@
text
@d148 1
a148 1
	else
d209 1
a209 1
	if not self.animate_arm then
d231 6
a236 5
	self:replace_layer (self.arm_layer, w.arm_anim[1],
			    w.arm_anim.cx, w.arm_anim.cy)
	_internal_set_camera (0, 96)
	if self.is_local and w.client_switch_to_hook then
	    w.client_switch_to_hook ()
a312 3
    end,
    proxy_init = function (self)
	self:add_light ("/basic/light/white-16", 0, 0)
@


1.22
log
@Made health items give health.
@
text
@d97 6
d138 5
d165 3
a167 2
    self.walk_frame_tics = self.walk_frame_tics - 1
    if self.walk_frame_tics <= 0 then
d171 2
a172 2
	if self.walk_frame > 7 then
	    self.walk_frame = 0
d174 1
a174 1
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), cx, cy)
d217 1
a217 1
    self.walk_frame = 0
d261 3
d294 21
@


1.21
log
@Animated weapon firing.
@
text
@d85 1
d100 4
@


1.20
log
@Added weapon switching with keyboard.
@
text
@d78 1
d128 17
a181 1
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
d186 13
d213 6
a218 7
	if w then
	    self:replace_layer (self.arm_layer, w.arm_anim[1],
				w.arm_anim.cx, w.arm_anim.cy)
	    _internal_set_camera (0, 96)
	    if self.is_local and w.client_switch_to_hook then
		w.client_switch_to_hook ()
	    end
@


1.19
log
@Added ammo limits.
@
text
@d48 1
a48 1
	if weapons[weapon_name] then
@


1.18
log
@Made player bleed when on low health.
@
text
@d56 15
@


1.17
log
@Made switching to the sniper rifle increase the max distance the
camera can see.
@
text
@a66 10
    -- update hook
    self:set_update_hook (
	1000/50,
	function (self)
	    if self.fire_delay > 0 then
		self.fire_delay = self.fire_delay - 1
	    end
	end
    )

d84 20
@


1.16
log
@Use the right image for the weapon we are holding (not animated yet).
@
text
@d161 4
@


1.15
log
@Added tracking corpses after death.
@
text
@d39 1
d43 8
a50 3
--	    if not self.current_weapon then
		self.current_weapon = weapons[weapon_name]
--	    end
d53 1
d154 9
@


1.14
log
@Some changes for multiple weapons testing.
@
text
@d77 7
a83 1
	    spawn_object ("basic-player-death-fountain", self.x, self.y)
@


1.13
log
@Made test corpse not show up in map editor.
@
text
@d38 1
a38 1
    self.current_weapon = weapons["basic-blaster"] -- XXX temp
d40 1
a40 1
	if not weapons[weapon_name] then
d42 3
a44 3
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
d47 1
d54 1
a54 1
	    if w and w.can_fire (self) then
@


1.12
log
@Decreased player xv_decay, yv_decay to slow down movement a little.
@
text
@a176 1
    category = "player",
@


1.11
log
@Added blods.
@
text
@d11 1
a11 1
local xv_decay, yv_decay = 0.75, 0.5
@


1.10
log
@Prefixed internal functions/variables that are somehow accessible from
Lua with "_internal".
@
text
@d73 1
@


1.9
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@a24 1
    self._ramp = 6
d26 1
d50 1
a50 1
    function self:_fire_hook ()
d87 1
a87 1
    if not _object_moving_horizontally (self) then
@


1.8
log
@Added a light for the test corpse, which disappears after its
animation finishes.
@
text
@d72 1
a72 1
	spawn_blood (self.x + cx, self.y + cy, 100, 2000) -- XXX spread should be float
@


1.7
log
@Updated to Lua 4.1-work3.
@
text
@d156 1
a156 1
    self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
d160 12
a171 1
	self:remove_update_hook ()
d190 1
@


1.6
log
@Small changes for death fountain test corpse.
@
text
@d21 4
a24 5
function player_nonproxy_init (self)
    local cx, cy = %cx, %cy

    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d28 1
d37 10
a46 1
    self.health = 100
d48 1
d50 1
a50 4

    self.current_weapon = weapons["basic-blaster"] -- XXX temp
    
    function self._fire_hook (self)
d59 1
d63 3
a65 1
	    self.fire_delay = self.fire_delay - 1
d69 4
a72 10
    function self.receive_weapon (self, weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
	end
    end

    function self.receive_damage (self, damage)
a77 2
	spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	-- XXX spread should be float
d86 1
a86 1
function animate_player_proxy (self)
d99 1
a99 1
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), %cx, %cy)
d103 1
a103 1
function rotate_and_flip_player_proxy_based_on_aim_angle (self)
d110 5
a114 10
    local a = radian_to_bangle (self.aim_angle)
    local hflipped = (a < -63 or a > 63) or 0
    
    self:hflip_layer (0, hflipped)
    self:hflip_layer (self.arm_layer, hflipped)
    
    if hflipped ~= 0
    then self:rotate_layer (self.arm_layer, a-128)
    else self:rotate_layer (self.arm_layer, a)
    end
d117 4
a120 3
function player_proxy_init (self)
    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d122 2
a123 1
    self:move_layer (0, %cx, %cy)
d126 4
a131 7
    
    if not self.is_local then
	self:add_light ("/basic/light/white-32", 0, 0)
    else
	self:add_light ("/basic/light/white-64", 0, 0)
    end

d155 1
a155 1
function death_fountain_update_hook (self)
d173 1
a173 1
	self.frame = 1
@


1.5
log
@Flip and rotate remote clients' arms depending on the aim angle.
@
text
@d174 3
a176 1
	self:set_collision_flags ("")
@


1.4
log
@Put in playing walking animation.
@
text
@d101 19
a131 1
	self:set_update_hook (1000/50, animate_player_proxy)
a133 21
	self:set_update_hook (
	    1000/50,
	    function (self)
		animate_player_proxy (self)
		-- aiming and rotating the arm
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0
		    then self:rotate_layer (self.arm_layer, a-128)
		    else self:rotate_layer (self.arm_layer, a)
		    end

		    self.last_aim_angle = self.aim_angle
		end
	    end
	)
d135 8
@


1.3
log
@Fixed a problem with the test corpse where the corpse object would be
replicated to new clients, but the new client would think the corpse
was starting at animation frame 0.  The solution was to use the
creation field feature.
@
text
@d10 1
d13 2
a14 4
Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
d17 31
a47 32
    --
    -- Non-proxy
    --
    nonproxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay
	self._ramp = 6
	self.mass = 0.9

	object_set_collision_is_player (self)
	self:set_collision_flags ("tn")
	self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
	self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
	self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
	self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
	self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)

	self.health = 100

	self.fire_delay = 0

	-- XXX: temp
	self.current_weapon = weapons["basic-blaster"]
	
	function self._fire_hook (self)
	    if self.fire_delay <= 0 then
		local w = self.current_weapon
		if w and w.can_fire (self) then
		    w.fire (self)
		end
d50 1
d52 6
a57 6
	self:set_update_hook (
	    1000/50,
	    function (self)
		self.fire_delay = self.fire_delay - 1
	    end
	)
d59 5
a63 6
	function self.receive_weapon (self, weapon_name)
	    if weapons[weapon_name] then
		self.have_weapon[weapon_name] = 1
		if not self.current_weapon then
		    self.current_weapon = weapon[weapon_name]
		end
d66 1
d68 5
a72 8
	function self.receive_damage (self, damage)
	    self.health = self.health - damage
	    if self.health <= 0 then
		spawn_object ("basic-player-death-fountain", self.x, self.y)
		self:destroy ()
	    end
	    spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	    -- XXX spread should be float
d74 4
a77 1
    end,
d80 3
a82 31
    --
    -- Proxy
    --
    proxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay

	self:move_layer (0, cx, cy)
	self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
	
	if not self.is_local then
	    self:add_light ("/basic/light/white-32", 0, 0)
	else
	    self:add_light ("/basic/light/white-64", 0, 0)

	    self:set_update_hook (
		1000/50,
		function (self)
		    if self.last_aim_angle ~= self.aim_angle then
			local a = radian_to_bangle (self.aim_angle)
			local hflipped = (a < -63 or a > 63) or 0
			
			self:hflip_layer (0, hflipped)
			self:hflip_layer (self.arm_layer, hflipped)
			
			if hflipped ~= 0
			then self:rotate_layer (self.arm_layer, a-128)
			else self:rotate_layer (self.arm_layer, a)
			end
d84 47
a130 1
			self.last_aim_angle = self.aim_angle
d132 2
d135 2
a136 2
	    )
	end
d138 9
@


1.2
log
@Update hook changes.  Also the beginnings of corpses
@
text
@d126 9
d142 3
d148 2
a149 12
	self:replace_layer (0, "/basic/player/death-fountain/000", 44, 16)
	self.frame = 1
	self:set_update_hook (
	    1000/10, 
	    function (self)
		self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
		self.frame = self.frame + 1
		if self.frame > 30 then
		    self:remove_update_hook ()
		end
	    end
	)
@


1.1
log
@Initial revision
@
text
@d5 5
d37 2
d53 6
a58 3
	function self._client_update_hook (self)
	    self.fire_delay = self.fire_delay - 1
	end
d70 5
d98 16
a113 13
	    function self._client_update_hook (self)
		function radian_to_bangle (rads) return rads * 128 / 3.1415 end
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0 then
			self:rotate_layer (self.arm_layer, a-128)
		    else
			self:rotate_layer (self.arm_layer, a)
d115 5
d121 24
a144 1
		    self.last_aim_angle = self.aim_angle
d147 1
a147 1
	end
@

head	1.15;
access;
symbols;
locks; strict;
comment	@# @;


1.15
date	2002.01.19.12.35.06;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.19.08.22.51;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.01.37.55;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.16.14.51;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.18.14.32.14;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.17.14.27.52;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.15.13.29.12;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.15.13.26.31;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.15.10.17.01;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.15.06.07.30;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.13.55.02;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.08.41.02;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.14.03.51.57;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.14.02.25.02;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.13.22;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Added tracking corpses after death.
@
text
@-- basic-player.lua

store_load ("basic/basic-player.dat", "/basic/player/")


----------------------------------------------------------------------
--  Players
----------------------------------------------------------------------


local xv_decay, yv_decay = 0.7, 0.45

-- centre of the player sprites
local cx, cy = 5, 5


--
-- Non-proxy
--

local player_nonproxy_init = function (self)
    -- some properties
    self.xv_decay = xv_decay
    self.yv_decay = yv_decay
    self.mass = 0.9
    self._internal_ramp = 6

    -- collision stuff
    object_set_collision_is_player (self)
    self:set_collision_flags ("tn")
    self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
    self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
    self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
    self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
    self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)

    -- weapon stuff
    self.have_weapon = {}
    function self:receive_weapon (weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
--	    if not self.current_weapon then
		self.current_weapon = weapons[weapon_name]
--	    end
	end
    end
    self:receive_weapon ("basic-blaster")

    -- firing stuff
    self.fire_delay = 0
    function self:_internal_fire_hook ()
	if self.fire_delay <= 0 then
	    local w = self.current_weapon
	    if w and (not w.can_fire or w.can_fire (self)) then
		w.fire (self)
	    end
	end
    end

    -- update hook
    self:set_update_hook (
	1000/50,
	function (self)
	    if self.fire_delay > 0 then
		self.fire_delay = self.fire_delay - 1
	    end
	end
    )

    -- health stuff
    self.health = 100
    function self:receive_damage (damage)
	spawn_blood (self.x + cx, self.y + cy, 100, 2)
	spawn_blod (self.x, self.y, 10)
	self.health = self.health - damage
	if self.health <= 0 then
	    local corpse = spawn_object ("basic-player-death-fountain",
					 self.x, self.y)
	    if corpse then
		-- this makes the client track the corpse
		corpse._internal_stalk_me = self.id
		corpse:add_creation_field ("_internal_stalk_me")
	    end
	    self:destroy ()
	end
    end
end


--
-- Proxy
--

local animate_player_proxy = function (self)
    if not _internal_object_moving_horizontally (self) then
	return
    end
    
    self.walk_frame_tics = self.walk_frame_tics - 1
    if self.walk_frame_tics <= 0 then
	self.walk_frame_tics = 2

	self.walk_frame = self.walk_frame + 1
	if self.walk_frame > 7 then
	    self.walk_frame = 0
	end
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), cx, cy)
    end
end

local rotate_and_flip_player_proxy_based_on_aim_angle = function (self)
    if self.last_aim_angle == self.aim_angle then
	return
    end

    self.last_aim_angle = self.aim_angle

    local angle = radian_to_bangle (self.aim_angle)
    local hflip = (angle < -63 or angle > 63)
    self:hflip_layer (0, hflip and 1 or 0)
    self:hflip_layer (self.arm_layer, hflip and 1 or 0)
    self:rotate_layer (self.arm_layer, angle - (hflip and 128 or 0))
end

local player_proxy_init = function (self)
    -- some properties
    self.xv_decay = xv_decay
    self.yv_decay = yv_decay

    -- layers
    self:move_layer (0, cx, cy)
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)

    -- light
    self:add_light (self.is_local and "/basic/light/white-64" or "/basic/light/white-32", 0, 0)

    -- animation and update hook
    self.walk_frame = 0
    self.walk_frame_tics = 0
    self:set_update_hook (
	1000/50,
	function (self)
	    animate_player_proxy (self)
	    rotate_and_flip_player_proxy_based_on_aim_angle (self)
	end
    )
end


Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
    nonproxy_init = player_nonproxy_init,
    proxy_init = player_proxy_init
}


----------------------------------------------------------------------
--  Corpses
----------------------------------------------------------------------

local death_fountain_update_hook = function (self)
    self:replace_layer (0,format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
    self.frame = self.frame + 1
    if self.frame > 30 then
	self.frame = 30
	if not self.is_proxy then
	    self:remove_update_hook ()
	else
	    -- proxy: let the light remain for half a second more
	    self:set_update_hook (
		1000/2,
		function (self)
		    self:remove_all_lights ()
		    self:remove_update_hook ()
		end
	    )
	end
    end
end

Objtype {
    name = "basic-player-death-fountain",
    icon = "/basic/player/death-fountain/000",

    nonproxy_init = function (self)
	self:set_masks_centre (44, 16)
	self:set_collision_flags ("t")
	self.mass = 0.005
	self.frame = 0
	self:add_creation_field ("frame")
	self:set_update_hook (1000/10, death_fountain_update_hook)
    end,

    proxy_init = function (self)
	self:add_light ("/basic/light/white-32", 0, 0)
	self:set_update_hook (1000/10, death_fountain_update_hook)
	death_fountain_update_hook (self) -- set the initial layer
    end
}
@


1.14
log
@Some changes for multiple weapons testing.
@
text
@d77 7
a83 1
	    spawn_object ("basic-player-death-fountain", self.x, self.y)
@


1.13
log
@Made test corpse not show up in map editor.
@
text
@d38 1
a38 1
    self.current_weapon = weapons["basic-blaster"] -- XXX temp
d40 1
a40 1
	if not weapons[weapon_name] then
d42 3
a44 3
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
d47 1
d54 1
a54 1
	    if w and w.can_fire (self) then
@


1.12
log
@Decreased player xv_decay, yv_decay to slow down movement a little.
@
text
@a176 1
    category = "player",
@


1.11
log
@Added blods.
@
text
@d11 1
a11 1
local xv_decay, yv_decay = 0.75, 0.5
@


1.10
log
@Prefixed internal functions/variables that are somehow accessible from
Lua with "_internal".
@
text
@d73 1
@


1.9
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@a24 1
    self._ramp = 6
d26 1
d50 1
a50 1
    function self:_fire_hook ()
d87 1
a87 1
    if not _object_moving_horizontally (self) then
@


1.8
log
@Added a light for the test corpse, which disappears after its
animation finishes.
@
text
@d72 1
a72 1
	spawn_blood (self.x + cx, self.y + cy, 100, 2000) -- XXX spread should be float
@


1.7
log
@Updated to Lua 4.1-work3.
@
text
@d156 1
a156 1
    self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
d160 12
a171 1
	self:remove_update_hook ()
d190 1
@


1.6
log
@Small changes for death fountain test corpse.
@
text
@d21 4
a24 5
function player_nonproxy_init (self)
    local cx, cy = %cx, %cy

    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d28 1
d37 10
a46 1
    self.health = 100
d48 1
d50 1
a50 4

    self.current_weapon = weapons["basic-blaster"] -- XXX temp
    
    function self._fire_hook (self)
d59 1
d63 3
a65 1
	    self.fire_delay = self.fire_delay - 1
d69 4
a72 10
    function self.receive_weapon (self, weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
	end
    end

    function self.receive_damage (self, damage)
a77 2
	spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	-- XXX spread should be float
d86 1
a86 1
function animate_player_proxy (self)
d99 1
a99 1
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), %cx, %cy)
d103 1
a103 1
function rotate_and_flip_player_proxy_based_on_aim_angle (self)
d110 5
a114 10
    local a = radian_to_bangle (self.aim_angle)
    local hflipped = (a < -63 or a > 63) or 0
    
    self:hflip_layer (0, hflipped)
    self:hflip_layer (self.arm_layer, hflipped)
    
    if hflipped ~= 0
    then self:rotate_layer (self.arm_layer, a-128)
    else self:rotate_layer (self.arm_layer, a)
    end
d117 4
a120 3
function player_proxy_init (self)
    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d122 2
a123 1
    self:move_layer (0, %cx, %cy)
d126 4
a131 7
    
    if not self.is_local then
	self:add_light ("/basic/light/white-32", 0, 0)
    else
	self:add_light ("/basic/light/white-64", 0, 0)
    end

d155 1
a155 1
function death_fountain_update_hook (self)
d173 1
a173 1
	self.frame = 1
@


1.5
log
@Flip and rotate remote clients' arms depending on the aim angle.
@
text
@d174 3
a176 1
	self:set_collision_flags ("")
@


1.4
log
@Put in playing walking animation.
@
text
@d101 19
a131 1
	self:set_update_hook (1000/50, animate_player_proxy)
a133 21
	self:set_update_hook (
	    1000/50,
	    function (self)
		animate_player_proxy (self)
		-- aiming and rotating the arm
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0
		    then self:rotate_layer (self.arm_layer, a-128)
		    else self:rotate_layer (self.arm_layer, a)
		    end

		    self.last_aim_angle = self.aim_angle
		end
	    end
	)
d135 8
@


1.3
log
@Fixed a problem with the test corpse where the corpse object would be
replicated to new clients, but the new client would think the corpse
was starting at animation frame 0.  The solution was to use the
creation field feature.
@
text
@d10 1
d13 2
a14 4
Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
d17 31
a47 32
    --
    -- Non-proxy
    --
    nonproxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay
	self._ramp = 6
	self.mass = 0.9

	object_set_collision_is_player (self)
	self:set_collision_flags ("tn")
	self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
	self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
	self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
	self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
	self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)

	self.health = 100

	self.fire_delay = 0

	-- XXX: temp
	self.current_weapon = weapons["basic-blaster"]
	
	function self._fire_hook (self)
	    if self.fire_delay <= 0 then
		local w = self.current_weapon
		if w and w.can_fire (self) then
		    w.fire (self)
		end
d50 1
d52 6
a57 6
	self:set_update_hook (
	    1000/50,
	    function (self)
		self.fire_delay = self.fire_delay - 1
	    end
	)
d59 5
a63 6
	function self.receive_weapon (self, weapon_name)
	    if weapons[weapon_name] then
		self.have_weapon[weapon_name] = 1
		if not self.current_weapon then
		    self.current_weapon = weapon[weapon_name]
		end
d66 1
d68 5
a72 8
	function self.receive_damage (self, damage)
	    self.health = self.health - damage
	    if self.health <= 0 then
		spawn_object ("basic-player-death-fountain", self.x, self.y)
		self:destroy ()
	    end
	    spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	    -- XXX spread should be float
d74 4
a77 1
    end,
d80 3
a82 31
    --
    -- Proxy
    --
    proxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay

	self:move_layer (0, cx, cy)
	self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
	
	if not self.is_local then
	    self:add_light ("/basic/light/white-32", 0, 0)
	else
	    self:add_light ("/basic/light/white-64", 0, 0)

	    self:set_update_hook (
		1000/50,
		function (self)
		    if self.last_aim_angle ~= self.aim_angle then
			local a = radian_to_bangle (self.aim_angle)
			local hflipped = (a < -63 or a > 63) or 0
			
			self:hflip_layer (0, hflipped)
			self:hflip_layer (self.arm_layer, hflipped)
			
			if hflipped ~= 0
			then self:rotate_layer (self.arm_layer, a-128)
			else self:rotate_layer (self.arm_layer, a)
			end
d84 47
a130 1
			self.last_aim_angle = self.aim_angle
d132 2
d135 2
a136 2
	    )
	end
d138 9
@


1.2
log
@Update hook changes.  Also the beginnings of corpses
@
text
@d126 9
d142 3
d148 2
a149 12
	self:replace_layer (0, "/basic/player/death-fountain/000", 44, 16)
	self.frame = 1
	self:set_update_hook (
	    1000/10, 
	    function (self)
		self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
		self.frame = self.frame + 1
		if self.frame > 30 then
		    self:remove_update_hook ()
		end
	    end
	)
@


1.1
log
@Initial revision
@
text
@d5 5
d37 2
d53 6
a58 3
	function self._client_update_hook (self)
	    self.fire_delay = self.fire_delay - 1
	end
d70 5
d98 16
a113 13
	    function self._client_update_hook (self)
		function radian_to_bangle (rads) return rads * 128 / 3.1415 end
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0 then
			self:rotate_layer (self.arm_layer, a-128)
		    else
			self:rotate_layer (self.arm_layer, a)
d115 5
d121 24
a144 1
		    self.last_aim_angle = self.aim_angle
d147 1
a147 1
	end
@

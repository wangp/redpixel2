head	1.30;
access;
symbols;
locks; strict;
comment	@# @;


1.30
date	2002.01.23.14.07.59;	author tjaden;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.23.10.02.03;	author tjaden;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.22.15.47.29;	author tjaden;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.22.13.02.04;	author tjaden;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.22.11.59.14;	author tjaden;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.22.11.15.32;	author tjaden;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.22.10.03.38;	author tjaden;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.22.04.06.44;	author tjaden;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.21.17.36.11;	author tjaden;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.21.16.11.40;	author tjaden;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.21.15.26.01;	author tjaden;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.21.14.19.41;	author tjaden;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.21.07.59.19;	author tjaden;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.21.04.16.00;	author tjaden;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.21.00.26.28;	author tjaden;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.19.12.35.06;	author tjaden;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.19.08.22.51;	author tjaden;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.19.01.37.55;	author tjaden;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.18.16.14.51;	author tjaden;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.18.14.32.14;	author tjaden;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.17.14.27.52;	author tjaden;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.15.13.29.12;	author tjaden;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.15.13.26.31;	author tjaden;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.15.10.17.01;	author tjaden;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.15.06.07.30;	author tjaden;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.13.55.02;	author tjaden;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.08.41.02;	author tjaden;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.14.03.51.57;	author tjaden;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.14.02.25.02;	author tjaden;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.13.22;	author tjaden;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Added auto weapon switching.
@
text
@-- basic-player.lua

store_load ("basic/basic-player.dat", "/basic/player/")


local corpses = {}


----------------------------------------------------------------------
--  Players
----------------------------------------------------------------------


local xv_decay, yv_decay = 0.7, 0.45

-- centre of the player sprites
local cx, cy = 5, 5


--
-- Non-proxy
--

local player_nonproxy_init = function (self)
    -- some properties
    self.xv_decay = xv_decay
    self.yv_decay = yv_decay
    self.mass = 0.9
    self._internal_ramp = 6

    -- collision stuff
    object_set_collision_is_player (self)
    self:set_collision_flags ("tn")
    self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
    self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
    self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
    self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
    self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)

    -- weapon stuff
    self.have_weapon = {}

    function self:receive_weapon (name)
	if weapons[name] and not self.have_weapon[name] then
	    self.have_weapon[name] = true
	    if contains (weapon_auto_switch_order, name) then
		self:switch_weapon (name)
	    end
	end
    end

    function self:switch_weapon (name)
	if weapons[name] and self.have_weapon[name] then
	    self.current_weapon = weapons[name]
	    self.desired_weapon = weapons[name]
	    call_method_on_clients (self, "switch_weapon", name)
	end
    end

    function self:auto_switch_weapon ()
	for _, name in weapon_auto_switch_order do
	    if (weapons[name] and self.have_weapon[name] and
		weapons[name].can_fire (self))
	    then
		self.current_weapon = weapons[name]
		call_method_on_clients (self, "switch_weapon", name)
		break
	    end
	end
    end

    self:receive_weapon ("basic-blaster")

    -- ammo stuff
    self._ammo = {}

    function self:receive_ammo (ammo_type, amount)
	self._ammo[ammo_type] = (self._ammo[ammo_type] or 0) + amount

	if self.desired_weapon ~= self.current_weapon and
	    self.desired_weapon.can_fire (self) and
	    contains (weapon_auto_switch_order, self.desired_weapon.name)
	then
	    self.current_weapon = self.desired_weapon
	    call_method_on_clients (self, "switch_weapon", self.current_weapon.name)
	end
    end

    function self:deduct_ammo (ammo_type, amount)
	self._ammo[ammo_type] = max (0, (self._ammo[ammo_type] or 0) - (amount or 1))
    end

    function self:ammo (ammo_type)
	return self._ammo[ammo_type] or 0
    end

    -- firing stuff
    self.fire_delay = 0

    function self:_internal_fire_hook ()
	if self.fire_delay <= 0 then
	    local w = self.current_weapon
	    if w and w.can_fire (self) then
		w.fire (self)
		call_method_on_clients (self, "start_firing_anim")
	    else
		self:auto_switch_weapon ()
	    end
	end
    end

    -- health stuff
    self.health = 100

    function self:receive_damage (damage)
	spawn_blood (self.x + cx, self.y + cy, 100, 2)
	if damage/5 >= 1 then
	    spawn_blod (self.x, self.y, damage/5)
	end
	self.health = self.health - damage
	if self.health <= 0 then
	    local corpse = spawn_object (corpses[random (getn (corpses))],
					 self.x, self.y)
	    if corpse then
		-- this makes the client track the corpse
		corpse._internal_stalk_me = self.id
		corpse:add_creation_field ("_internal_stalk_me")

		-- drop a backpack after the corpse finishes animation
		local x, y = self.x, self.y
		corpse.drop_backpack = function ()
		    spawn_object ("basic-backpack", x, y)
		end
	    end
	    self:destroy ()
	else
	    call_method_on_clients (self, "start_alt_light",
		"return '/basic/light/red-64', 38, 10")
	end
    end

    function self:receive_health (amount)
	self.health = min (100, self.health + amount)
    end

    -- update hook (fire delay and blood trails)
    self.trail_tics = 0
    self:set_update_hook (
	1000/50,
	function (self)
	    if self.fire_delay > 0 then
		self.fire_delay = self.fire_delay - 1
	    end

	    if self.health <= 20 then
		if self.trail_tics > 0 then
		    self.trail_tics = self.trail_tics - 1
		else
		    self.trail_tics = 50
		    spawn_blood (self.x + cx, self.y + cx, 40, 2)
		end
	    end
	end
    )

    -- create a respawning ball where the player is
    spawn_object ("basic-respawning-ball", self.x, self.y)
end


--
-- Proxy
--

local walk_anim = {}
for i = 0,7 do
    walk_anim[i] = format ("/basic/player/walk/%03d", i)
end

local animate_player_proxy_firing = function (self)
    if self.animate_arm then
	if self.arm_tics > 0 then
	    self.arm_tics = self.arm_tics - 1
	elseif self.current_weapon then
	    local anim = self.current_weapon.arm_anim
	    self.arm_tics = anim.tics or 5
	    self.arm_frame = self.arm_frame + 1
	    if self.arm_frame > self.last_arm_frame then
		self.arm_frame = 1
		self.animate_arm = false
	    end
	    self:replace_layer (self.arm_layer, anim[self.arm_frame], anim.cx, anim.cy)
	end
    end
end

local animate_player_proxy_walking = function (self)
    if not _internal_object_moving_horizontally (self) then
	return
    end
    
    if self.walk_frame_tics > 0 then
	self.walk_frame_tics = self.walk_frame_tics - 1
    else
	self.walk_frame_tics = 2

	self.walk_frame = self.walk_frame + 1
	if self.walk_frame >= getn (walk_anim) then
	    self.walk_frame = 0
	end
	self:replace_layer (0, walk_anim[self.walk_frame], cx, cy)
    end
end

local animate_player_proxy_alt_lighting = function (self)
    if self.alt_light_tics > 0 then
	self.alt_light_tics = self.alt_light_tics - 1
	if self.alt_light_tics == 0 then
	    self:replace_light (0, "/basic/light/white-64", 0, 0)
	    self.alt_light_priority = 0
	end
    end
end

local rotate_and_flip_player_proxy_based_on_aim_angle = function (self)
    if self.last_aim_angle == self.aim_angle then
	return
    end

    self.last_aim_angle = self.aim_angle

    local angle = radian_to_bangle (self.aim_angle)
    local hflip = (angle < -63 or angle > 63)
    self:hflip_layer (0, hflip and 1 or 0)
    self:hflip_layer (self.arm_layer, hflip and 1 or 0)
    self:rotate_layer (self.arm_layer, angle - (hflip and 128 or 0))
end

local player_proxy_init = function (self)
    -- some properties
    self.xv_decay = xv_decay
    self.yv_decay = yv_decay

    -- layers
    self:move_layer (0, cx, cy)

    -- light
    self:add_light (self.is_local and "/basic/light/white-64" or "/basic/light/white-32", 0, 0)

    self.alt_light_tics = 0
    self.alt_light_priority = 0

    function self:start_alt_light (this_is_dodgy)
	local the_light, timeout, priority = dostring (this_is_dodgy) -- XXX not good for security
	if (priority > self.alt_light_priority) and self.is_local then
	    self:replace_light (0, the_light, 0, 0)
	    self.alt_light_tics = timeout
	    self.alt_light_priority = priority
	end
    end

    -- arm stuff
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
    self.arm_frame = 1

    -- (called by nonproxy fire hook)
    function self:start_firing_anim ()
	if not self.animate_arm and self.current_weapon then
	    self.animate_arm = true
	    self.arm_tics = 0
	    self.last_arm_frame = getn (self.current_weapon.arm_anim)
	end
    end

    -- animation and update hook
    self.walk_frame = 0
    self.walk_frame_tics = 0
    self:set_update_hook (
	1000/50,
	function (self)
	    animate_player_proxy_firing (self)
	    animate_player_proxy_walking (self)
	    animate_player_proxy_alt_lighting (self)
	    rotate_and_flip_player_proxy_based_on_aim_angle (self)
	end
    )

    -- switch weapon (called by nonproxy switch_weapon)
    function self:switch_weapon (weapon_name)
	local w = weapons[weapon_name]
	self.current_weapon = w
	self:replace_layer (self.arm_layer, w.arm_anim[1], w.arm_anim.cx, w.arm_anim.cy)
	if self.is_local then
	    _internal_set_camera (0, 96)
	    if w.client_switch_to_hook then
		w.client_switch_to_hook ()
	    end
	end
    end
end


Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
    nonproxy_init = player_nonproxy_init,
    proxy_init = player_proxy_init
}


----------------------------------------------------------------------
--  Corpses
----------------------------------------------------------------------

local Corpse = function (t)

    local anim = {}
    for i = 0, t.frames do
	anim[i] = format (t.fmt, i)
    end

    -- Note: both proxy and nonproxy have to update self.frames.

    local nonproxy_update = function (self)
	self.frame = self.frame + 1
	if self.frame > t.frames then
	    self.frame = t.frames
	    if self.drop_backpack then
		-- drop the backpack after a little whil
		self:set_update_hook (
		    1000/3,
		    function (self)
			self.drop_backpack ()
			self:remove_update_hook ()
		    end
		)
	    else
		self:remove_update_hook ()
	    end
	end
    end

    local proxy_update = function (self)
	self:replace_layer (0, anim[self.frame], t.cx, t.cy)
	self.frame = self.frame + 1
	if self.frame > t.frames then
	    self.frame = t.frames
	    -- let the light remain for half a second more
	    self:set_update_hook (
		1000/2,
		function (self)
		    self:remove_all_lights ()
		    self:remove_update_hook ()
		end
	    )
	end
    end

    if not t.speed then
	t.speed = 1000/8
    end

    tinsert (corpses, t.name)

    return Objtype (t, {
    
	icon = anim[0],
	
	nonproxy_init = function (self)
	    if t.mask then
		self:set_mask (mask_main, t.mask, t.cx, t.cy)
		self:set_mask (mask_bottom, t.mask, t.cx, t.cy)
	    end
	    self:set_masks_centre (t.cx, t.cy)
	    self:set_collision_flags ("t")
	    self.mass = 0.005
	    self.frame = 0
	    self:add_creation_field ("frame")
	    self:set_update_hook (t.speed, nonproxy_update)
	end,
	
	proxy_init = function (self)
	    -- self.frame is given by server
	    self:add_light ("/basic/light/red-32", 0, 0)
	    self:set_update_hook (t.speed, proxy_update)
	    proxy_update (self) -- set the initial layer
	end
    })
end

Corpse {
    name = "basic-player-death-arm",
    alias = "~da",
    fmt = "/basic/player/death-arm/%03d",
    mask = "/basic/player/death-arm/mask",
    frames = 16,
    cx = 26,
    cy = 8
}

Corpse {
    name = "basic-player-death-eye",
    alias = "~de",
    fmt = "/basic/player/death-eye/%03d",
    mask = "/basic/player/death-eye/mask",
    frames = 20,
    cx = 26,
    cy = 9
}

Corpse {
    name = "basic-player-death-fountain",
    alias = "~df",
    fmt = "/basic/player/death-fountain/%03d",
    mask = "/basic/player/death-fountain/mask",
    frames = 30,
    speed = 1000/10,
    cx = 44,
    cy = 16
}

Corpse {
    name = "basic-player-death-leg",
    alias = "~dl",
    fmt = "/basic/player/death-leg/%03d",
    mask = "/basic/player/death-leg/mask",
    frames = 15,
    speed = 1000/7,
    cx = 26,
    cy = 8
}

Corpse {
    name = "basic-player-death-leg2",
    alias = "~dL",
    fmt = "/basic/player/death-leg2/%03d",
    mask = "/basic/player/death-leg2/mask",
    frames = 17,
    speed = 1000/6,
    cx = 21,
    cy = 8
}

Corpse {
    name = "basic-player-death-stomach",
    alias = "~ds",
    fmt = "/basic/player/death-stomach/%03d",
    mask = "/basic/player/death-stomach/mask",
    frames = 16,
    cx = 13,
    cy = 8
}


----------------------------------------------------------------------
--  Backpack
----------------------------------------------------------------------

Objtype {
    name = "basic-backpack",
    icon = "/basic/player/backpack",
    nonproxy_init = function (self)
	self.mass = 0.01
	self:set_collision_flags ("pt")
	function self:collide_hook (player)
	    -- give goodies
	    self:destroy ()
	end
    end
}
@


1.29
log
@Create a new respawn ball when a player is spawned.
@
text
@d43 14
a56 4
    function self:receive_weapon (weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
	    self:switch_weapon (weapon_name)
d60 9
a68 4
    function self:switch_weapon (weapon_name)
	if weapons[weapon_name] and self.have_weapon[weapon_name] then
	    self.current_weapon = weapons[weapon_name]
	    call_method_on_clients (self, "switch_weapon", weapon_name)
d79 8
d99 1
d103 1
a103 1
	    if w and (not w.can_fire or w.can_fire (self)) then
d106 2
d269 1
a269 1
	    self.animate_arm = 1
@


1.28
log
@Made player walking animation code zero-based again to match datafile
item names.
@
text
@d139 3
a331 4
    end

    if t.alias then
	add_alias (t.name, t.alias)
@


1.27
log
@Added rest of death animations and cleaned up the code around that.
@
text
@d148 1
a148 1
    tinsert (walk_anim, format ("/basic/player/walk/%03d", i))
d179 2
a180 2
	if self.walk_frame > getn (walk_anim) then
	    self.walk_frame = 1
d247 1
a247 1
    self.walk_frame = 1
@


1.26
log
@Made lightamp powerup give player a big blue light.
@
text
@d6 3
d91 3
a93 1
	spawn_blod (self.x, self.y, 10)
d96 1
a96 1
	    local corpse = spawn_object ("basic-player-death-fountain",
d287 13
a299 7
local death_fountain_update_hook = function (self)
    self:replace_layer (0,format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
    self.frame = self.frame + 1
    if self.frame > 30 then
	self.frame = 30
	if not self.is_proxy then
	    self:remove_update_hook ()
d301 10
a310 1
		self.drop_backpack ()
d312 9
a320 2
	else
	    -- proxy: let the light remain for half a second more
d330 35
d367 21
a387 1
Objtype {
d389 19
a407 1
    icon = "/basic/player/death-fountain/000",
d409 19
a427 14
    nonproxy_init = function (self)
	self:set_masks_centre (44, 16)
	self:set_collision_flags ("t")
	self.mass = 0.005
	self.frame = 0
	self:add_creation_field ("frame")
	self:set_update_hook (1000/10, death_fountain_update_hook)
    end,

    proxy_init = function (self)
	self:add_light ("/basic/light/red-32", 0, 0)
	self:set_update_hook (1000/10, death_fountain_update_hook)
	death_fountain_update_hook (self) -- set the initial layer
    end
@


1.25
log
@Made local player's light turn red if gotten shot, and made corpses
use the red light.
@
text
@d106 2
a107 1
	    call_method_on_clients (self, "start_hurt_light")
d146 1
a146 2
local animate_player_proxy = function (self)
    -- firing
d161 1
d163 1
a163 9
    -- hurt light
    if self.hurt_light_tics > 0 then
	self.hurt_light_tics = self.hurt_light_tics - 1
	if self.hurt_light_tics == 0 then
	    self:reset_default_light ()
	end
    end

    -- walking
d181 10
d216 2
a217 1
    self.hurt_light_tics = 0
d219 6
a224 5
    -- (called by nonproxy receive_damage)
    function self:start_hurt_light ()
	if self.is_local then
	    self:replace_light (0, "/basic/light/red-64", 0, 0)
	    self.hurt_light_tics = 38
a227 5
    -- (called by update hook)
    function self:reset_default_light ()
	self:replace_light (0, "/basic/light/white-64", 0, 0)
    end

d247 3
a249 1
	    animate_player_proxy (self)
@


1.24
log
@Some small fixes.
@
text
@d105 2
d162 8
d213 15
d317 1
a317 1
	self:add_light ("/basic/light/white-32", 0, 0)
@


1.23
log
@Added start of backpacks.  Also minor clean up for walking anim.
@
text
@d148 1
a148 1
	else
d209 1
a209 1
	if not self.animate_arm then
d231 6
a236 5
	self:replace_layer (self.arm_layer, w.arm_anim[1],
			    w.arm_anim.cx, w.arm_anim.cy)
	_internal_set_camera (0, 96)
	if self.is_local and w.client_switch_to_hook then
	    w.client_switch_to_hook ()
a312 3
    end,
    proxy_init = function (self)
	self:add_light ("/basic/light/white-16", 0, 0)
@


1.22
log
@Made health items give health.
@
text
@d97 6
d138 5
d165 3
a167 2
    self.walk_frame_tics = self.walk_frame_tics - 1
    if self.walk_frame_tics <= 0 then
d171 2
a172 2
	if self.walk_frame > 7 then
	    self.walk_frame = 0
d174 1
a174 1
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), cx, cy)
d217 1
a217 1
    self.walk_frame = 0
d261 3
d294 21
@


1.21
log
@Animated weapon firing.
@
text
@d85 1
d100 4
@


1.20
log
@Added weapon switching with keyboard.
@
text
@d78 1
d128 17
a181 1
    self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
d186 13
d213 6
a218 7
	if w then
	    self:replace_layer (self.arm_layer, w.arm_anim[1],
				w.arm_anim.cx, w.arm_anim.cy)
	    _internal_set_camera (0, 96)
	    if self.is_local and w.client_switch_to_hook then
		w.client_switch_to_hook ()
	    end
@


1.19
log
@Added ammo limits.
@
text
@d48 1
a48 1
	if weapons[weapon_name] then
@


1.18
log
@Made player bleed when on low health.
@
text
@d56 15
@


1.17
log
@Made switching to the sniper rifle increase the max distance the
camera can see.
@
text
@a66 10
    -- update hook
    self:set_update_hook (
	1000/50,
	function (self)
	    if self.fire_delay > 0 then
		self.fire_delay = self.fire_delay - 1
	    end
	end
    )

d84 20
@


1.16
log
@Use the right image for the weapon we are holding (not animated yet).
@
text
@d161 4
@


1.15
log
@Added tracking corpses after death.
@
text
@d39 1
d43 8
a50 3
--	    if not self.current_weapon then
		self.current_weapon = weapons[weapon_name]
--	    end
d53 1
d154 9
@


1.14
log
@Some changes for multiple weapons testing.
@
text
@d77 7
a83 1
	    spawn_object ("basic-player-death-fountain", self.x, self.y)
@


1.13
log
@Made test corpse not show up in map editor.
@
text
@d38 1
a38 1
    self.current_weapon = weapons["basic-blaster"] -- XXX temp
d40 1
a40 1
	if not weapons[weapon_name] then
d42 3
a44 3
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
d47 1
d54 1
a54 1
	    if w and w.can_fire (self) then
@


1.12
log
@Decreased player xv_decay, yv_decay to slow down movement a little.
@
text
@a176 1
    category = "player",
@


1.11
log
@Added blods.
@
text
@d11 1
a11 1
local xv_decay, yv_decay = 0.75, 0.5
@


1.10
log
@Prefixed internal functions/variables that are somehow accessible from
Lua with "_internal".
@
text
@d73 1
@


1.9
log
@Made the spread parameter to spawn blood a float (instead of int).
@
text
@a24 1
    self._ramp = 6
d26 1
d50 1
a50 1
    function self:_fire_hook ()
d87 1
a87 1
    if not _object_moving_horizontally (self) then
@


1.8
log
@Added a light for the test corpse, which disappears after its
animation finishes.
@
text
@d72 1
a72 1
	spawn_blood (self.x + cx, self.y + cy, 100, 2000) -- XXX spread should be float
@


1.7
log
@Updated to Lua 4.1-work3.
@
text
@d156 1
a156 1
    self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
d160 12
a171 1
	self:remove_update_hook ()
d190 1
@


1.6
log
@Small changes for death fountain test corpse.
@
text
@d21 4
a24 5
function player_nonproxy_init (self)
    local cx, cy = %cx, %cy

    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d28 1
d37 10
a46 1
    self.health = 100
d48 1
d50 1
a50 4

    self.current_weapon = weapons["basic-blaster"] -- XXX temp
    
    function self._fire_hook (self)
d59 1
d63 3
a65 1
	    self.fire_delay = self.fire_delay - 1
d69 4
a72 10
    function self.receive_weapon (self, weapon_name)
	if weapons[weapon_name] then
	    self.have_weapon[weapon_name] = 1
	    if not self.current_weapon then
		self.current_weapon = weapon[weapon_name]
	    end
	end
    end

    function self.receive_damage (self, damage)
a77 2
	spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	-- XXX spread should be float
d86 1
a86 1
function animate_player_proxy (self)
d99 1
a99 1
	self:replace_layer (0, format ("/basic/player/walk/%03d", self.walk_frame), %cx, %cy)
d103 1
a103 1
function rotate_and_flip_player_proxy_based_on_aim_angle (self)
d110 5
a114 10
    local a = radian_to_bangle (self.aim_angle)
    local hflipped = (a < -63 or a > 63) or 0
    
    self:hflip_layer (0, hflipped)
    self:hflip_layer (self.arm_layer, hflipped)
    
    if hflipped ~= 0
    then self:rotate_layer (self.arm_layer, a-128)
    else self:rotate_layer (self.arm_layer, a)
    end
d117 4
a120 3
function player_proxy_init (self)
    self.xv_decay = %xv_decay
    self.yv_decay = %yv_decay
d122 2
a123 1
    self:move_layer (0, %cx, %cy)
d126 4
a131 7
    
    if not self.is_local then
	self:add_light ("/basic/light/white-32", 0, 0)
    else
	self:add_light ("/basic/light/white-64", 0, 0)
    end

d155 1
a155 1
function death_fountain_update_hook (self)
d173 1
a173 1
	self.frame = 1
@


1.5
log
@Flip and rotate remote clients' arms depending on the aim angle.
@
text
@d174 3
a176 1
	self:set_collision_flags ("")
@


1.4
log
@Put in playing walking animation.
@
text
@d101 19
a131 1
	self:set_update_hook (1000/50, animate_player_proxy)
a133 21
	self:set_update_hook (
	    1000/50,
	    function (self)
		animate_player_proxy (self)
		-- aiming and rotating the arm
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0
		    then self:rotate_layer (self.arm_layer, a-128)
		    else self:rotate_layer (self.arm_layer, a)
		    end

		    self.last_aim_angle = self.aim_angle
		end
	    end
	)
d135 8
@


1.3
log
@Fixed a problem with the test corpse where the corpse object would be
replicated to new clients, but the new client would think the corpse
was starting at animation frame 0.  The solution was to use the
creation field feature.
@
text
@d10 1
d13 2
a14 4
Objtype {
    category = "player",    -- XXX: should be nil in future; the map editor should not allow it to be placed
    name = "player",	    -- not basic-player
    icon = "/basic/player/walk/000",
d17 31
a47 32
    --
    -- Non-proxy
    --
    nonproxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay
	self._ramp = 6
	self.mass = 0.9

	object_set_collision_is_player (self)
	self:set_collision_flags ("tn")
	self:set_mask (mask_main, "/basic/player/mask/whole", cx, cy)
	self:set_mask (mask_top, "/basic/player/mask/top", cx, cy)
	self:set_mask (mask_bottom, "/basic/player/mask/bottom", cx, cy)
	self:set_mask (mask_left, "/basic/player/mask/left", cx, cy)
	self:set_mask (mask_right, "/basic/player/mask/right", cx, cy)

	self.health = 100

	self.fire_delay = 0

	-- XXX: temp
	self.current_weapon = weapons["basic-blaster"]
	
	function self._fire_hook (self)
	    if self.fire_delay <= 0 then
		local w = self.current_weapon
		if w and w.can_fire (self) then
		    w.fire (self)
		end
d50 1
d52 6
a57 6
	self:set_update_hook (
	    1000/50,
	    function (self)
		self.fire_delay = self.fire_delay - 1
	    end
	)
d59 5
a63 6
	function self.receive_weapon (self, weapon_name)
	    if weapons[weapon_name] then
		self.have_weapon[weapon_name] = 1
		if not self.current_weapon then
		    self.current_weapon = weapon[weapon_name]
		end
d66 1
d68 5
a72 8
	function self.receive_damage (self, damage)
	    self.health = self.health - damage
	    if self.health <= 0 then
		spawn_object ("basic-player-death-fountain", self.x, self.y)
		self:destroy ()
	    end
	    spawn_blood (self.x + %cx, self.y + %cy, 100, 2000)
	    -- XXX spread should be float
d74 4
a77 1
    end,
d80 3
a82 31
    --
    -- Proxy
    --
    proxy_init = function (self)
	local cx, cy = 5, 5

	self.xv_decay = %xv_decay
	self.yv_decay = %yv_decay

	self:move_layer (0, cx, cy)
	self.arm_layer = self:add_layer ("/basic/weapon/blaster/1arm000", 0, 3)
	
	if not self.is_local then
	    self:add_light ("/basic/light/white-32", 0, 0)
	else
	    self:add_light ("/basic/light/white-64", 0, 0)

	    self:set_update_hook (
		1000/50,
		function (self)
		    if self.last_aim_angle ~= self.aim_angle then
			local a = radian_to_bangle (self.aim_angle)
			local hflipped = (a < -63 or a > 63) or 0
			
			self:hflip_layer (0, hflipped)
			self:hflip_layer (self.arm_layer, hflipped)
			
			if hflipped ~= 0
			then self:rotate_layer (self.arm_layer, a-128)
			else self:rotate_layer (self.arm_layer, a)
			end
d84 47
a130 1
			self.last_aim_angle = self.aim_angle
d132 2
d135 2
a136 2
	    )
	end
d138 9
@


1.2
log
@Update hook changes.  Also the beginnings of corpses
@
text
@d126 9
d142 3
d148 2
a149 12
	self:replace_layer (0, "/basic/player/death-fountain/000", 44, 16)
	self.frame = 1
	self:set_update_hook (
	    1000/10, 
	    function (self)
		self:replace_layer (0, format ("/basic/player/death-fountain/%03d", self.frame), 44, 16)
		self.frame = self.frame + 1
		if self.frame > 30 then
		    self:remove_update_hook ()
		end
	    end
	)
@


1.1
log
@Initial revision
@
text
@d5 5
d37 2
d53 6
a58 3
	function self._client_update_hook (self)
	    self.fire_delay = self.fire_delay - 1
	end
d70 5
d98 16
a113 13
	    function self._client_update_hook (self)
		function radian_to_bangle (rads) return rads * 128 / 3.1415 end
		if self.last_aim_angle ~= self.aim_angle then
		    local a = radian_to_bangle (self.aim_angle)
		    local hflipped = (a < -63 or a > 63) or 0
		    
		    self:hflip_layer (0, hflipped)
		    self:hflip_layer (self.arm_layer, hflipped)
		    
		    if hflipped ~= 0 then
			self:rotate_layer (self.arm_layer, a-128)
		    else
			self:rotate_layer (self.arm_layer, a)
d115 5
d121 24
a144 1
		    self.last_aim_angle = self.aim_angle
d147 1
a147 1
	end
@

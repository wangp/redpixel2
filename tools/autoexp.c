/* autoexp (990425)	** blink blink hack blink blink **
 * 
 *  Scan through input files (.h) looking for $-tags
 *  writing output files for SeeR headers and C source code.
 * 
 * Current tags are: 
 * 	$-export		export current line
 * 	$-don't-export		DO NOT export current line
 * 					(overrides blocks)
 * 	$-start-export-block	start of export block
 * 	$-end-export-block	end of export block
 * 	$-start-struct <id>	begin a SeeR struct
 * 	$-end-struct		close the struct
 * 
 * Limitations and special notes:
 * 	Block CANNOT be nested.   
 * 	$-tags must appear inside comments (of either type).
 * 	Multi-line comments will NOT work (yet).
 */


#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>



/* $-tags */

#define TAG_EXPORT_LINE		"$-export"
#define TAG_DONT_EXPORT_LINE	"$-don't-export"
#define TAG_BLOCK_START		"$-start-export-block"
#define TAG_BLOCK_END		"$-end-export-block"
#define TAG_STRUCT_START	"$-start-struct"
#define TAG_STRUCT_END		"$-end-struct"



/* options */

#define OPT_OUTPUT_SEER_HDR	"--output-seer-hdr="
#define OPT_OUTPUT_C_SRC	"--output-c-src="



/* outputs */

#define MAX_OUTPUTS	10	/* probably only ever use two */


enum {
    none = 0,
    seer, 
    csrc
};


void export_seer_line(FILE *fp, char *line);
void export_csrc_line(FILE *fp, char *line);


void (*table[])(FILE *fp, char *line) = {
    NULL,			       /* none */
    export_seer_line,		       /* seer */
    export_csrc_line		       /* csrc */
};


struct output_file 
{
    int type;    
    FILE *fp;    
} output_files[MAX_OUTPUTS];


int num_outputs = 0;


int open_output(int type, char *filename)
{
    int i;
    FILE *fp;
    time_t curtime;
    struct tm *local;
    char *p, *q;
    
    for (i=0; i<MAX_OUTPUTS; i++) {
	if (output_files[i].type == none)
	  break;
    }
    
    if (i == MAX_OUTPUTS) {
	printf("Too many output files!\n");
	return -1;
    }
    
    fp = fopen(filename, "w");
    if (!fp) {
	printf("Error opening %s for output!\n", filename);
	return -1;
    } 
    
    curtime = time(NULL);
    local = localtime(&curtime);
    p = strchr((q = asctime(local)), '\n');
    *p = '\0';
    fprintf(fp, "/* %s: automatically generated by \t\t-*- mode: C -*- */\n", filename);
    fprintf(fp, "/* autoexp on %s */\n", q);
    fprintf(fp, "/* Do not edit ! */\n");
    
    output_files[i].type = type;
    output_files[i].fp = fp;
    num_outputs++;    
    return 0;
}


void close_outputs()
{
    int i;
    for (i=0; i<MAX_OUTPUTS; i++)
      if (output_files[i].type != none) {
	  output_files[i].type = none;
	  fclose(output_files[i].fp);
      }
}



/* inputs */

char *writeout_filename = NULL;
int inside_block = 0;
int inside_struct = 0;


char *find_comment(char *line)
{
    int quote = 0;
    char *p = line;
       
    while (*p)
    {
	if (*p == '"')
	  quote = (quote ? 0 : 1);
	else if (*p == '/' && (p[1] == '*' || p[1] == '/'))
	  return p;
	
	p++;
    }
    
    return NULL;
}


void insert_seer_line(char *fmt, ...)
{
    char buf[1024];
    va_list va;
    int i;
        
    va_start(va, fmt);
    vsprintf(buf, fmt, va);
    va_end(va);
    
    for (i=0; i < MAX_OUTPUTS; i++)
    {
	if (output_files[i].type == seer)
	{
	    if (writeout_filename)
	      fprintf(output_files[i].fp, "\n/* %s */\n", writeout_filename);
	    
	    fprintf(output_files[i].fp, buf);
	}
    }
    
    writeout_filename = NULL;
}


int scan_line(char *line)
{
    char *comment, *p;
    int ret = 0;
        
    comment = find_comment(line);
    if (!comment) 
      return inside_block | inside_struct;
    
    if (strstr(comment, TAG_EXPORT_LINE)) 
      ret = 1;
    if (strstr(comment, TAG_DONT_EXPORT_LINE))
      ret = 0;
    if (strstr(comment, TAG_BLOCK_START))
      inside_block = 1;
    if (strstr(comment, TAG_BLOCK_END))
      inside_block = 0;
    if ((p = strstr(comment, TAG_STRUCT_START))) {
	char *name;
	p += strlen(TAG_STRUCT_START) + 1;
	name = strtok(p, " \t");
	if (name) {
	    insert_seer_line("\nstruct %s {\n", name);
	    inside_struct = 1;
	}
    }
    if (strstr(comment, TAG_STRUCT_END)) {
	inside_struct = 0;
	insert_seer_line("};\n");
	return 0;
    }
    
    *comment = '\0';
    return ret;
}


char *strip(char *buf)
{
    char *start =  buf, *end;
    
    while (*start && isspace(*start))
      start++;
    
    if (*start == '\0')
      return start;
    
    end = buf + strlen(buf);
    while (end > start && isspace(*end))
      *end-- = '\0';
    
    return start;
}



char *seer_dont_like[] = {
    "extern",
    NULL
};

#define TYPE_KEYWORDS	"unsigned", "signed", "long", "short", "int", \
			"char", "void", "float", "double"

#define C_KEYWORDS	"extern", "static", "auto"
			/* there are more, but doubtful to be in header */

char *type_keywords[] = { TYPE_KEYWORDS, NULL };

char *keywords[] = { TYPE_KEYWORDS, C_KEYWORDS, NULL };

char *c_separators = "`~!@#$%^&*()-=+\\|[{]};:',<.>/? \t\"";



void for_each_token(char *buf, void (*callback)(char *tok, int len))
{
    char *copy = strdup(buf);
    char *tok = strtok(copy, c_separators);

    while (tok) {
	callback(buf+(tok-copy), strlen(tok));
	tok = strtok(NULL, c_separators);
    }
    
    free(copy);
}


void whiteout(char *tok, int len)
{
    char **list = seer_dont_like;
    int i = 0;
    while (list[i]) {
	
	if (strlen(list[i]) == len && (strncmp(tok, list[i], len) == 0)) {
	    memset(tok, ' ', len);
	    return;
	}
	
	i++;
    }
}


void export_seer_line(FILE *fp, char *line)
{
    char *copy = strdup(line);    

    for_each_token(copy, whiteout);
    
    if (inside_struct || strstr(copy, "typedef "))
      fprintf(fp, "%s\n", copy);
    else
      fprintf(fp, "import %s\n", copy);
    
    free(copy);
}


int inlist(char *tok, char **list)
{
    int i = 0;
    while (list[i]) {
	if (strcmp(tok, list[i]) == 0)
	  return 1;
	i++;
    }
    return 0;
}


char *get_symbol(char *buf)
{
    int found_type = 0;
    char *tok = strtok(buf, c_separators);

    while (tok) {
	if (inlist(tok, keywords)) {
	    if (inlist(tok, type_keywords))
	      found_type = 1;
	}
	else {
	    if (found_type)
	      return tok;
	    else
	      found_type = 1;
	}
	
	tok = strtok(NULL, c_separators);
    }
    
    return NULL;
}


void export_csrc_line(FILE *fp, char *line)   
{
    char *copy = strdup(line), *symbol;
    symbol = get_symbol(copy);
    if (symbol) {
	if (!strstr(line, "typedef ") && !inside_struct)
	  fprintf(fp, "scAddExtSym(%s);\n", symbol);
    }
    free(copy);
}


void export_line(char *line)
{
    int i;
    char *l;
    
    l = strip(line);
    if (*l == '\0')
      return;
    
    for (i=0; i < MAX_OUTPUTS; i++)
    {
	if (output_files[i].type != none)
	{
	    if (writeout_filename)
	      fprintf(output_files[i].fp, "\n/* %s */\n", writeout_filename);
	    
	    table[output_files[i].type](output_files[i].fp, l);
	}
    }
    
    writeout_filename = NULL;
}


void scan_input(char *filename) 
{
    FILE *fp;
    char buf[1024], *p;
    
    fp = fopen(filename, "r");
    if (!fp) {
	printf("Error opening `%s' for input!\n", filename);
	return;
    }
     
    writeout_filename = filename;
    
    while (!feof(fp)) {
	
	fgets(buf, 1024, fp);
	p =  strchr(buf, '\n');
	if (p)
	  *p = '\0';
	
	if (scan_line(buf)) {
	    export_line(buf);
	}
    }
}



/* main */

int main(int argc, char **argv)
{
    int i;
    char *arg, *p, *filename;
    
    if (argc < 2) {
	printf("usage: %s [ outputs ] input-files\n\n", argv[0]);
	printf("\t--output-seer-hdr=filename.sh\n");
	printf("\t--output-c-src=filename.c\n\n");
	return 1;
    }
    
    for (i=1; i<argc; i++)
    {
	arg = argv[i];
	p = strstr(arg, "--");
	if (p == arg) {
	    
	    if (strncmp(arg, OPT_OUTPUT_SEER_HDR, strlen(OPT_OUTPUT_SEER_HDR)) == 0)
	    {
		filename = strchr(arg, '=') + 1;
		open_output(seer, filename);
	    } 
	    else if (strncmp(arg, OPT_OUTPUT_C_SRC, strlen(OPT_OUTPUT_C_SRC)) == 0)
	    {	   
		filename = strchr(arg, '=') + 1;
		open_output(csrc, filename);
	    }
	    else
	      printf("Unrecognised option `%s'\n", arg);
	    
	    *argv[i] = '\0';	    
	}	 
    }
    
    for (i=1; i<argc; i++)
    {
	if (*argv[i])
	  scan_input(argv[i]);
    }
            
    close_outputs();
    
    return 0;
}


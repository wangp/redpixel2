@# If you want to put everything in one big HTML file rather than splitting
@# it into sections, remove this 'multiplefiles' statement:
@#
@multiplefiles
@#
@h=<html><head><title>#</title><body>
@f=<p><hr><p><a href="ppcol.html">Back to Contents</a><p>
@$\input texinfo
@$@setfilename ppcol.inf
@$@settitle PPCol Manual
@$@setchapternewpage odd
@$@paragraphindent 0
@$
@$@ifinfo
@$This is the Info version of the PPCol manual
@$
@$By Ivan Baldo
@$@end ifinfo
@$
@$@node Top, , (dir), (dir)
@<html>
@<head>
@<title>PPCol - a pixel perfect collision detection library for Allegro</title>
@<body>
@<pre>
@!indent
       ______  ______  ______           ___
      /\  _  \/\  _  \/\  ___\         /\_ \
      \ \ \L\ \ \ \L\ \ \ \__/     ____\//\ \
       \ \  ___\ \  ___\ \ \      / __ \ \ \ \
        \ \ \__/\ \ \__/\ \ \____/\ \L\ \ \_\ \_
         \ \_\   \ \_\   \ \_____\ \____/ /\____\
          \/_/    \/_/    \/_____/\/___/  \/____/


  A pixel perfect collision detection library for Allegro

By Ivan baldo - lubaldo@adinet.com.uy

This library contains slightly modified code borrowed from:
Original bitmasked routines by Neil Chinnery - neich@geocities.com
Bitmasked routines enhanced by Michael de la Pena (Vox) - vox@bellsouth.net
@indent
@</pre>


#include &ltallegro_std_disclaimer_slightly_modified.h&gt
<i>
   "We do not accept responsibility for any bad effects, that this code may
    have on you, your users, your computer, your sanity, specially your DOG,
    and anything else that you can think of. Use it at your own risk. But if
    this code produces something good, that is totally due to us!"
</i>


@!text
@heading
Contents

@contents



@text
@heading
How to compile and link your programs using the PPCol library
<pre>
   All the PPCol library functions, structures and definitions are defined
in ppcol.h. You should #include this in your modules using the PPCol
functions. Also, you have to link your programs with liballeg.a and AFTER
it link with libppcol.a.

   To acomplish this you have to:

      - Put the following line in the beginning of all C or C++ files that
        use PPCol:

           #include &ltppcol.h&gt

      - When you compile, add the '-lalleg -lppcol' at the end of the gcc
        command, eg:

           gcc foo.c -o foo.exe -lalleg -lppcol

      - If you are using Rhide, go to the Options/Libraries menu, type
        'alleg' into the first empty space, and make sure the box next to it
        is checked. Then, go to the next empty space and type 'ppcol', and
        make sure the box next to it is checked.

      - If you are using Rhide, it is also recommended to tell it to search
        in the PPCol help file when you press CTRL+F1, so it will display
        help about the requested function if it is a PPCol function. To do
        so, you have to go to the Help menu, then, go to the Syntax Help
        submenu, then chose the Files to Search option. Add "ppcol" at the end
        of the list separated with a space from the other entries.
</pre>

@heading
Pixel perfect collision detection routine

This function works using the bitmap data directly looking if one of the
solid colors (not transparent) overlaps (or collides).

It is well suited for constantly changing sprites, otherwise use the masked
collision detection routines.

@\int @check_pp_collision(BITMAP *spr1, BITMAP *spr2,
@@                        int x1, int y1, int x2, int y2)
   Given 2 bitmaps and their respective positions, this function returns
   true (different of 0) if there is a collision and false (0) if theres not
   a collision.

   This function supports only memory bitmaps of any color depth and the
   bitmaps must be of the same color depth. It doesn't support Mode-X too.

   This function does a bounding box collision detection first, so you don't
   have to check for bounding box collision before this function.

@heading
Masked pixel perfect collision detection routines

This routines are for a masked pixel perfect collision detection method.
This method uses a bitmask array representing with a 1 a pixel on the sprite
and with a 0 a non existant or transparent sprite space.

To use this method, first you have to declare a pointer to a PPCOL_MASK
structure for each of the sprites you would use, then you have to initialize
that PPCOL_MASK structures with a mask creation routine, and then you pass 2
PPCOL_MASK structures to a masked pixel perfect collision detection routine
together with the respective X, Y positions of the sprites to see if there
is a collision or not. When you finish using this functions, you release the
memory used by the masks with a routine.

This method is very fast (faster than the normal collision detection
routine) but not suitable for sprites that change very much (ie. sprites
that rotates or shrinks or expands) or memory tight programs since they need
a little memory. Keep in mind that the mask creation is SLOW.

<pre>
   The PPCOL_MASK structure is as follows:

      typedef struct PPCOL_MASK
      {
         int h;                          //Bounding box height.
         int w;                          //Bounding box width.
         int max_chunk;                  //Used internally.
         void *dat;                      //The mask data pointer.
         unsigned long int *sp_mask[0];  //Pointers to the begining of
                                         //each row of chunks.
      } PPCOL_MASK;

   You will not modify this structure manually.
</pre>
@@PPCOL_MASK *@create_ppcol_mask(BITMAP *sprite)
   Pass it any type (with the exception of RLE and COMPILED sprites) of
   Allegro bitmap and it returns a pointer to a PPCOL_MASK structure created
   for that sprite. Whenever that sprite changes, you have to destroy the
   old mask and then create a new one with this function.

   If theres not enough memory available to allocate the mask or if there
   was an error, this function returns NULL.

   Keep in mind that this routine is SLOW, so don't use it on speed critical
   loops.

@@void @destroy_ppcol_mask(PPCOL_MASK *mask)
   Pass it a PPCOL_MASK and this function will release the memory used by
   the mask, making it unuseable.

@\int @check_ppmask_collision(PPCOL_MASK *mask1, PPCOL_MASK *mask2,
@@                            int x1, int y1, int x2, int y2)
   Given 2 masks and their respective coordinates, this function returns
   true (diferent of 0) if there is a collision between the 2 masks, and
   false (0) if theres not a collision.

   This function does a bounding box collision detection first, so you don't
   have to check for bounding box collision before this function.

   Note that if there is a collision between the masks, this means that
   there is a collision between the sprites that this masks represents. Also
   note that you can pass to this function the same mask for both masks
   parameters.


@heading
Bounding box collision detection

   Bounding box collision detection is a system to detect collisions (or
   overlapping) between 2 rectangles. It is a very fast method.

@\int @check_bb_collision_general(int x1, int y1, int w1, int h1,
@@                                int x2, int y2, int w2, int h2)
   This macro is for a general purpose bounding box collision detection.
   Pass it 2 coordinates and the respective widths and heights of the
   rectangles pertaining to those coordinates. It returns true if there is a
   collision between the rectangles and false if theres not.

@@int @check_bb_collision(*param1, *param2, int x1, int y1, int x2, int y2)
   This macro is for a bounding box collision detection. For param1 and
   param2 you can pass a pointer to an Allegro BITMAP or a pointer to a
   PPCOL_MASK structure. x1, y1, x2, y2 are the respective coordinates of
   the sprites or mask. Returns true (diferent of 0) if theres a bounding
   box collision or false (0) if theres not collision.

      This macro actually calls to
      check_bb_collision_general(x1,y1,param1->w,param1->h,
                                 x2,y2,param2->w,param2->h).

@heading
Knowing or showing the version of the library

This macros can be used to do conditional preprocessor compilings and
reporting the version number of PPCol in your programs.

@@char @PPCOL_VERSION_STR[]
   This will contain the current version string of the library. For example,
   for version 1.1 of the library, this string will be "1.1".

@@char @PPCOL_DATE_STR[]
   This will contain the year of the current version of the library. For
   example, for version 1.1 of the library, this string will be "1998".

@@#define @PPCOL_VERSION
   This macro has the major version number of the library. For example, for
   version 1.2 of the library, this macro will be 1.

@@#define @PPCOL_SUB_VERSION
   This macro has the minor version number of the library. For example, for
   version 1.2 of the library, this macro will be 2.

@heading
Measuring the amount of collision between sprites

The following are functions that given 2 sprites, their respective
coordinates and a direction, return the amount that you have to move the
first sprite in that requested direction to avoid the collision.

To specify the directions you have to use this macros (the names are self
explanatory of the direction):
<pre>
   PPCAMOUNT_UP
   PPCAMOUNT_UP_RIGHT
   PPCAMOUNT_RIGHT
   PPCAMOUNT_DOWN_RIGHT
   PPCAMOUNT_DOWN
   PPCAMOUNT_DOWN_LEFT
   PPCAMOUNT_LEFT
   PPCAMOUNT_UP_LEFT
</pre>

This macros are of the type x,x where "x" are the appropiate numbers for the
last 2 parameters of the amount detection routines.

@\int @check_pp_collision_amount(BITMAP *spr1, BITMAP *spr2,
@\                               int x1, int y1, int x2, int y2,
@@                               int dirx, int diry)
   This function is to detect the amount that you have to move in a specified
   direction the first sprite passed as parameter to avoid the collision.

   This function supports only memory bitmaps of any color depth and the
   bitmaps must be of the same color depth. It doesn't support Mode-X too.

@\int @check_ppmask_collision_amount(PPCOL_MASK *mask1, PPCOL_MASK *mask2,
@\                                   int x1, int y1, int x2, int y2,
@@                                   int dirx, int diry)
   This function is to detect the amount that you have to move in a specified
   direction the first mask passed as parameter to avoid the collision.

@heading
Debugging your programs

To debug better your programs, define PPCOL_DEBUG before including the PPCol
header in your module and compile your program without optimization and with
debugging information.

<pre>
      Example:
         #include &ltallegro.h&gt
         #define PPCOL_DEBUG
         #include &ltppcol.h&gt

      Compile with: gcc foo.c -o foo.exe -O0 -g3 -lalleg -lppcol
</pre>
Keep in mind that this will slow your program, so, don't do it for the final
release.

This debugging support will detect when you pass NULL pointers to the
collision detection routines. Keep in mind that only static pointers not
initialized or deallocated pointers will be NULL, local pointers will
contain garbage if not initialized thus they will be different than NULL.
When the debugging support detects a NULL pointer, it will generate the
signal SIGINT and a call frame traceback, so you can debug your program and
see where the error happened.

@heading
Authors and contributors
In alphabetical order by name:

Eduardo Roldan (<a href="mailto:trazor@internet.com.uy">trazor@internet.com.uy</a>):
   Contributed the sprites used in this library.

Grzegorz Adam Hankiewicz (<a href="mailto:gah@jet.es">gah@jet.es</a>):
   Contributed the EX2.C example program and reformatted the documentation to
   avoid the Allegro Makedoc utility bugs and match more the formatting of
   the Allegro documentation.

Ivan Baldo (<a href="mailto:lubaldo@adinet.com.uy">lubaldo@adinet.com.uy</a>):
   Modified the Neil Chinnery and Michael de la Pena masked pixel perfect
   collision detection routines to be more dynamic and suitable to go in the
   library, created the normal pixel perfect collision detection routine,
   creator and maintainer of the library. If you cannot reach me within 2
   weeks, try the alternate address ibaldo@usa.net.

Michael de la Pena (aka Vox) (<a href="mailto:vox@bellsouth.net">vox@bellsouth.edu</a>):
   Modified the Neil Chinnery routines to allow masks for sprites larger
   than 32x32 pixels.

Neil Chinnery (<a href="mailto:neich@geocities.com">neich@geocities.com</a>):
   Wrote the original masked pixel perfect collision detection routines.

Peter Wang (<a href="mailto:tjaden@alphalink.com.au">tjaden@alphalink.com.au</a>):
   Contributed the benchmarking program, alpha/beta testing, discovered 1
   bug.


@heading
Thanks
(this list is completely unsorted)

To all the contributors of this library.

To Salvador Eduardo Tropea (SET) for helping me with the 24bpp
pixel-by-pixel collision detection routine and the good idea for the
debugging support.

To Ove Kaaven for helping me with the 24bpp pixel-by-pixel collision
detection routine.

To Eli Zaretskii for helping me with the traceback dumping in the debugging
support.

To Shawn for his Allegro library and his support.

To DJ Delorie for the port of GCC to DOS (DJGPP), his LibC and support.

To Richard Stallman for GCC.

To all the GNU and free software people.

To all the users of this library that email me :-))

To all the people of the Allegro and DJGPP mailing lists and newsgroups.

To Garfield Benjamin for initial support and alpha/beta testing.

@heading
License / legal issues / conditions.
   This library is distributed under the term of freeware.

   You can use this library in your programs freely, then, you can
distribute your programs commercialy or with non profit, your programs will
not fall under any license by the use of this library.

   You can redistribute freely without charge except for copying costs but
keep a link or information to the Ivan Baldo Internet WEB page (look for the
URL in other section in this manual).

   You can modify and maintain an unofficial version of this library but you
have to tell that it is an unofficial version and give users information to
where they can obtain this official library. I reserve the right to decide
where or not to include your code in the official library.

   I reserve the right to change this license without notice in future
versions.

   Optionally, you can contact me if you use this library, I like to hear
about people using this library.

   Also optionally, you can give me credits in your program.


Copyright 1998, Ivan Baldo.
Montevideo, Uruguay.

@heading
Where to obtain the latest version and other related sites over Internet

   To obtain the latest version of this library, go to Ivan Baldo's WEB
page: http://members.xoom.com/baldo, alternate URL:
http://baldo.home.ml.org. To download it directly this is the URL:
http://members.xoom.com/baldo/ppcolXX.zip, where XX is the version number
(ie 11 for version 1.1).

   Alternatively you can download it from SimtelNet:
ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2tk/allegro/ppcolXX.zip

   If you want, take a look at the original masked pixel perfect collision
detection routines by Neil Chinnery and the modified ones of Michael de la
Pena, search for them in this URL:
http://www.geocities.com/SiliconValley/Park/1077

   Richard.P.Gatehouse is doing a tutorial about collision detection, go to
http://www.geocities.com/SiliconValley/Peaks/3008/ and look in the
"Tutorials" section.


@!html
@!text
@headingnocontent
Index

@index

@$@contents
@$@bye

@html
@text
